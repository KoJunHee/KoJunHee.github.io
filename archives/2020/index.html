
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="junhee.ko">
    <title>Archives: 2020 - junhee.ko</title>
    <meta name="author" content="junhee.ko">
    
    
    
    <script type="application/ld+json">{}</script>
    <meta name="description" content="always learning">
<meta property="og:type" content="blog">
<meta property="og:title" content="junhee.ko">
<meta property="og:url" content="https://kojunhee.github.io/archives/2020/index.html">
<meta property="og:site_name" content="junhee.ko">
<meta property="og:description" content="always learning">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="junhee.ko">
<meta name="twitter:description" content="always learning">
    
    
        
    
    
        <meta property="og:image" content="https://kojunhee.github.io/assets/images/profile.jpg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/all.css">
    <link rel="stylesheet" href="/assets/css/jquery.fancybox.css">
    <link rel="stylesheet" href="/assets/css/thumbs.css">
    <link rel="stylesheet" href="/assets/css/tranquilpeak.css">
    <!--STYLES END-->
    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="2">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a class="header-title-link" href="/ ">junhee.ko</a>
    </div>
    
        
            <a  class="header-right-picture "
                href="#about">
        
        
            <img class="header-picture" src="/assets/images/profile.jpg" alt="Author&#39;s picture"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="2">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a href="/#about">
                    <img class="sidebar-profile-picture" src="/assets/images/profile.jpg" alt="Author&#39;s picture"/>
                </a>
                <h4 class="sidebar-profile-name">junhee.ko</h4>
                
                    <h5 class="sidebar-profile-bio"><p>Always Learning</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/ "
                            
                            title="Home"
                        >
                    
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-categories"
                            
                            title="Categories"
                        >
                    
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-archives"
                            
                            title="Archives"
                        >
                    
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Archives</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://github.com/kojunhee" target="_blank" rel="noopener" title="GitHub">
                    
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://facebook.com/kojunheee" target="_blank" rel="noopener" title="Facebook">
                    
                        <i class="sidebar-button-icon fab fa-facebook" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Facebook</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://www.linkedin.com/in/junheeko" target="_blank" rel="noopener" title="LinkedIn">
                    
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="mailto:junheee.ko@gmail.com" target="_blank" rel="noopener" title="Mail">
                    
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="2"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2020/01/05/big-data-chapter5/">
                            [빅데이터를 지탱하는 기술] 5장_빅데이터 파이프라인
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2020-01-05T00:00:00+09:00">
	
		    Jan 05, 2020
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/big-data/">Big Data</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="1-워크-플로우-관리"><a href="#1-워크-플로우-관리" class="headerlink" title="1. 워크 플로우 관리"></a>1. 워크 플로우 관리</h2><h5 id="기초-지식"><a href="#기초-지식" class="headerlink" title="기초 지식"></a>기초 지식</h5><ol>
<li><p>워크 플로우 관리 도구</p>
<p>워크 플로우 관리 도구의 주요 역할은, 정기적으로 태스크를 실행하고 비정상적인 상태를 감지하여 해결을 돕는 것이다.</p>
<p>ex) Airflow, Azkaban, Digdag, Luigi, Oozie</p>
</li>
<li><p>태스크</p>
<p>데이터 파이프라인의 실행 과정에서 데이터를 잇달아 이동하면서 정해진 처리를 반복하는데, 이때 실행되는 개별 처리이다.</p>
</li>
<li><p>기본 기능</p>
<ul>
<li><p>테스크를 정기적인 스케쥴로 실행하고 결과 통지</p>
</li>
<li><p>테스크 간의 의존 관계를 정하고 순서대로 빠지없이 실행</p>
</li>
<li><p>테스크의 실행 결과를 보관하고, 오류 발생하면 재실행 할 수 있도록 하기</p>
</li>
</ul>
</li>
<li><p>선언 형과 스크립트 형</p>
<ul>
<li>선언형 : XML 이나 YAML 등의 서식으로 워크플로우 기술</li>
<li>스크립트형 : 스크립트 언어로 워크플로우 정의</li>
</ul>
</li>
</ol>
<h5 id="오류로부터-복구-방법"><a href="#오류로부터-복구-방법" class="headerlink" title="오류로부터 복구 방법"></a>오류로부터 복구 방법</h5><p>모든 오류를 사전에 예상하는 것은 불가능하기 때문에, 오류 발생 가능성을 고려하여 대처 방법을 결정해야한다.</p>
<ol>
<li><p>Retry</p>
<p>재시도를 반복해도 문제가 없는 태스크라면, 1회나 2회의 재시도를 실행해도 좋다.</p>
<p>그러나, 그 이상은 재시도가 아니라 올바른 문제 해결 방법을 찾아야한다.</p>
</li>
<li><p>Backfill</p>
<p>플로우 전체를 처음부터 다시 실행한다. 다음 상황에 사용한다.</p>
<ul>
<li>태스크의 실패가 며칠 동안이나 계속된 후에 이를 모아서 재시도 하고 싶을 때</li>
<li>새롭게 만든 워크 플로우를 과거로 거슬라 올라가 실행하고 싶을 때</li>
</ul>
</li>
</ol>
<h5 id="재실행의-안정성을-위한-두가지-방법"><a href="#재실행의-안정성을-위한-두가지-방법" class="headerlink" title="재실행의 안정성을 위한 두가지 방법"></a>재실행의 안정성을 위한 두가지 방법</h5><ol>
<li><p>원자성 조작 (Atomic Operation)</p>
<p>예를 들어, INSERT 문 2회를 호출하는 태스크가 있다고 하자.</p>
<p>첫 번째의 INSERT 가 종료되고 오류가 발생하면 태스크를 재실행하면 동일한 데이터가 다시 쓰이게 될 수 있다.</p>
<p>이 문제를 회피하기 위해, 각 태스크가 <code>시스템에 변경을 가하는 것을 한 번만 할 수 있도록</code> 하는 것이다.</p>
<p>쓰기가 필요한 수 만큼 테스크를 나누는 것이다. </p>
<p>하지만, 태스크 구현상의 버그 등으로 원자성 조작 직후에 문제가 발생하면 원자성 조작 자체는 성공했어도 워크 플로우 관리 도구에서는 오류로 여길 수 있다.</p>
</li>
<li><p>멱등한 조작</p>
<p>더 확실한 방법은, <code>동일한 태스크를 여러 번 실행해도 동일한 결과</code>가 되도록 하는 것이다.</p>
<p>예를 들어 분산 스토리지에 파일을 업로드할 때, </p>
<ul>
<li>매번 새로운 파일명을 만들 경우 데이터를 추가 (append) 하는 것이고, </li>
<li>동일 파일명으로 덮어쓰면 치환 (replace)하는 것이다. 치환은 반복해도 결과가 변하지 않으므로 멱등하다.</li>
</ul>
</li>
</ol>
<h5 id="데이터-추가"><a href="#데이터-추가" class="headerlink" title="데이터 추가"></a>데이터 추가</h5><ol>
<li><p>멱등한 추가</p>
<p>과거의 모든 데이터를 치환하면 멱등하지만 부하가 커진다. 그래서, Table Partitioning 이 필요하다.</p>
<p>예를 들면 테이블을 1일마다 또는 1시간 마다 파티션으로 분할하고 파티션 단위로 치환하는 것이다.</p>
<p>파티션의 모든 데이터를 삭제할 때, TRUNCATE 문이나 INSESRT OVERWRITER 문 등을 사용할 수 있다.</p>
<p>ex) Hive 는 파티셔닝 지원, Amazon Redshift 는 파티셔닝을 지원하지 않아 UNION ALL 사용</p>
</li>
<li><p>원자성을 지닌 추가</p>
<p>하나의 테이블에 여러번 데이터를 써넣는 경우, 중간 테이블을 이용해 마지막에 목적 테이블에 한 번 추가한다.</p>
<p>즉, 전반 부분에서는 중간 테이블을 만들기 위해 테이블을 치환하므로 멱등하다.</p>
<p>그러나 마지막에 INSESRT 는 단순히 추가이므로 전체로서는 멱등하지 않다.</p>
<p>단, 마지막에 쓰기를 1회만 실시하므로 이것은 원자성을 지닌 조작이다. </p>
<p>그래서 플로우가 실패해도 아무것도 쓰이지 않아 실패한 태스크를 재실행해도 복구가 완료된다.</p>
</li>
</ol>
<h5 id="워크-플로우-전체를-멱등하게-하기"><a href="#워크-플로우-전체를-멱등하게-하기" class="headerlink" title="워크 플로우 전체를 멱등하게 하기"></a>워크 플로우 전체를 멱등하게 하기</h5><p>재실행의 안정성을 위해서는, 멱등하게 구현해야한다.</p>
<p><img src="/image/big_data_workflow_idemponent.png" alt></p>
<h5 id="Task-Queue-자원의-소비량-컨트롤"><a href="#Task-Queue-자원의-소비량-컨트롤" class="headerlink" title="Task Queue : 자원의 소비량 컨트롤"></a>Task Queue : 자원의 소비량 컨트롤</h5><p>대량의 테스크를 동시 실행하면 서버에 과부하가 걸리므로 어느 정도 제한 해야한다.</p>
<p>워크 플로우 관리 도구는, 태스크의 크기나 동시 실행 수를 변화시켜 자원의 소비량을 조정해 모든 태스크가 원활하게 실행되도록 할 수 있다. </p>
<p>이 때, Job Queue 또는 Task Queue 를 사용할 수 있다. </p>
<p>모든 태스크는 큐에 저장되고 일정 수의 워커 프로세스가 순서대로 꺼내며 병렬화가 실현된다.</p>
<h2 id="2-배치-형-데이터-플로우"><a href="#2-배치-형-데이터-플로우" class="headerlink" title="2. 배치 형 데이터 플로우"></a>2. 배치 형 데이터 플로우</h2><h5 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h5><p><img src="/image/big_data_workflow_mapreduce.png" alt></p>
<p>데이터 처리 첫 번째 단계를 Map, 그 결과를 모아서 집계하는 두 번째 단계를 Reduce 라고 한다.</p>
<p>이렇게 Map 과 Reduce 를 반복하면서 목적하는 결과를 얻을 때 까지 계속 데이터를 변화하는 구조가 MapReduce 이다.</p>
<p>MapReduce 는 Map 과 Reduce 의 하나의 사이클이 끝나지 않으면 다음 처리로 이동하지 않는다. 즉, 하나의 사이클에서 다음 사이클로 이동할 때 까지 대기 시간이 발생한다.</p>
<h5 id="데이터-플로우"><a href="#데이터-플로우" class="headerlink" title="데이터 플로우"></a>데이터 플로우</h5><p>이전의 MapReduce 를 사용한 데이터 처리에서는, MapReduce 프로그램을 워크플로우의 태스크로 등록해 다단계의 복잡한 데이터 처리를 할 수 있었다.</p>
<p>현재는, 다단계의 데이터 처리를 분산 시스템 내부에서 실행할 수 있다. 이것을 데이터 플로우라고 한다. </p>
<p>ex) 데이터 플로우를 위한 프레임워크 :  Google Cloud Dataflow, Apache Spark, Apache Flick</p>
<h5 id="MapReduce-를-대신할-세로운-프레임워크"><a href="#MapReduce-를-대신할-세로운-프레임워크" class="headerlink" title="MapReduce 를 대신할 세로운 프레임워크"></a>MapReduce 를 대신할 세로운 프레임워크</h5><p>세로운 프레임워크의 공통 특징은 DAG (Direct Acyclic Graph) 이다.</p>
<p>다음 두 가지 성질이 있다.</p>
<ol>
<li>방향성 : 노드와 노드가 화살표로 연결</li>
<li>비순환 : 화살표를 따라가도 동일 노드로 돌아오지 않음</li>
</ol>
<p>DAG 관점에서 MapReduce 와 데이터 플로우의 차이는,</p>
<ol>
<li><p>MapReduce</p>
<p>MapReduce 도 Map 과 Reduce 의 두 종류 노드로 이루어진 DAG 라 생각할 수 있다. </p>
<p>하지만, 하나의 노드에서 처리가 끝나지 않으면 다음 처리로 진행할 수 없다.</p>
</li>
<li><p>데이터플로우</p>
<p>DAG 를 구성하는 노드가 모두 동싱 병행으로 실행된다.</p>
<p>처리가 끝난 데이터는 네트워크를 거쳐 차례대로 전달된다. </p>
<p>먼저 데이터 파이프라인 전체를 DAG 로 조립한 뒤 실행해서, 내부 스캐쥴러가 분산 시스템에 효과적인 실행 계획을 세운다.</p>
</li>
</ol>
<h5 id="데이터-플로우와-워크플로우-조합하기"><a href="#데이터-플로우와-워크플로우-조합하기" class="headerlink" title="데이터 플로우와 워크플로우 조합하기"></a>데이터 플로우와 워크플로우 조합하기</h5><p>테스크를 정기적으로 실행하거나 실패한 테스크를 기록하여 복구하는 것은, 데이터플로우가 아니라 워크 플로우의 관리가 필요하다. 따라서, 데이터 플로우의 프로그램도 워크 플로우의 일부로 실행되는 하나의 태스크로 고려될 수 있다.</p>
<ol>
<li><p>데이터를 읽어들이는 플로우</p>
<p><img src="/image/big_data_workflow_store.png" alt></p>
<p>데이터 플로우로부터 읽어 들일 데이터는 성능적으로 안정된 분산 스토리지에 배치해야한다. 외부의 데이터 소스에서 데이터를 읽어들일 때는 읽기 속도에 한계가 있으므로 데이터 플로우를 사용한다고 해도 빨라진다고 단언할 수 없다.</p>
<p><img src="/image/big_data_workflow_after_store.png" alt></p>
<p>분산스토리지로 데이터 복사가 완료되면 데이터 플로우로 처리한다.</p>
</li>
<li><p>데이터를 써서 내보내는 워크플로우</p>
<p>데이터 플로우 안에서 대량의 데이터를 외부에 전송해서는 안된다. 왜냐하면,</p>
<ul>
<li><p>쓰기 작업에 오래 걸리면, 실행이 완료되지 않아 자원을 계속해서 소비 할 수 있다.</p>
</li>
<li><p>최악의 경우, 쓰기 작업이 실패해 처음부터 다시 데이터 처리를 재실행 해야 할 수 있다.</p>
</li>
</ul>
<p>그래서, 데이터 플로우는 CSV 파일과 같이 취합하기 쉬운 형식으로 분산 스토리지에 넣는 것 까지한다. </p>
<p>외부 시스템에 데이터를 전송하는 것은 워크 플로우의 역할이다. </p>
<ul>
<li><p>벌크 형 전송 도구를 사용해 태스크를 구현하거나</p>
</li>
<li><p>외부 시스템쪽에 파일을 읽어들이도록 지시한다.</p>
</li>
</ul>
<p><img src="/image/big_data_workflow_write.png" alt></p>
</li>
</ol>
<h5 id="데이터-플로우와-SQL-을-나누어-사용하기"><a href="#데이터-플로우와-SQL-을-나누어-사용하기" class="headerlink" title="데이터 플로우와 SQL 을 나누어 사용하기"></a>데이터 플로우와 SQL 을 나누어 사용하기</h5><p><img src="/image/big_data_workflow_sql.png" alt></p>
<ol>
<li><p>SQL을 MPP 데이터베이스에서 실행</p>
<p>데이터웨어하우스의 파이프라인 </p>
<p>로드되는 데이터를 만드는 부분까지가 데이터 플로의 역할</p>
</li>
<li><p>SQL을 분산 시스템 상의 쿼리 엔진에서 실행 </p>
<p>데이터마트의 파이프라인</p>
<p>구조화된 데이터를 만드는 부분까지가 데이터플로우의 역할</p>
</li>
</ol>
<h2 id="3-스트리밍-형-데이터-플로우"><a href="#3-스트리밍-형-데이터-플로우" class="headerlink" title="3. 스트리밍 형 데이터 플로우"></a>3. 스트리밍 형 데이터 플로우</h2><h5 id="배치-처리와-스트림-처리"><a href="#배치-처리와-스트림-처리" class="headerlink" title="배치 처리와 스트림 처리"></a>배치 처리와 스트림 처리</h5><p><img src="/image/big_data_workflow_stream.png" alt></p>
<ol>
<li><p>배치 처리</p>
<p>도달한 데이터를 우선 분산 스토리지에 보관한다.</p>
<p>데이터가 영속적으로 보관되기 때문에 몇 번이고 재실행 가능하다. </p>
<p>집계 효율이 높은 열 지향 스토리지를 구축할 수 있다. </p>
<p>실행 시에 데이터 양이 정해지기 때문에 유한 데이터 (bounded data)</p>
</li>
<li><p>스트림 처리</p>
<p>데이터 도달과 동시에 처리가 시작된다.</p>
<p>재실행하는 것은 고려하지 않는다.</p>
<p>처리한 결과는 시계열 데이터에 적합한 데이터 스토어에 보관하거나 실시간 시스템에 전송한다.</p>
<p>제한 없이 데이터가 보내지기 때문에 무한 데이터 (unbounded data)</p>
<p>ex) Spark Streaming</p>
</li>
</ol>
<h5 id="스트림-처리에-의한-1차-집계"><a href="#스트림-처리에-의한-1차-집계" class="headerlink" title="스트림 처리에 의한 1차 집계"></a>스트림 처리에 의한 1차 집계</h5><p><img src="/image/big_data_workflow_stream_first.png" alt></p>
<p>분산 스토리지에도 성능 상이나 비용 상의 한계가 있다.</p>
<p>데이터 양이 많아 한계를 넘어서면, 스트림 처리를 사용해 흐름량을 줄일 수 있다.</p>
<h5 id="스트림-처리의-두-가지-문제에-대한-대처"><a href="#스트림-처리의-두-가지-문제에-대한-대처" class="headerlink" title="스트림 처리의 두 가지 문제에 대한 대처"></a>스트림 처리의 두 가지 문제에 대한 대처</h5><p>스트림 처리의 문제 두 가지가 있다.</p>
<ol>
<li><p>틀린 결과를 어떻게 수정할 것인가</p>
<p>새롭게 도달한 데이터만 처리한다.</p>
</li>
<li><p>늦게 전송된 데이터 취급을 어떻게 할 것인가</p>
<p>집계가 종료된 후에 도착한 데이터가 있어서, 스트림 처리의 결과가 부정확해질 수 있다.</p>
</li>
</ol>
<p>이 문제 해결을 위해, 스트림 처리와 별개로 배치 처리를 실행시켜 배치 처리의 결과가 옳다고 할 수 있다.</p>
<p>예를 들어, 일별 보고서를 속보 값으로 하고 월별 보고서를 확정값으로 분류하는 것이다.</p>
<p>이를 발전 시킨 방법이 람다 아키텍쳐, 람다 아키텍쳐를 단순화한 카파 아키텍쳐가 있다.</p>
<ol>
<li><p>람다</p>
<p><img src="/image/big_data_workflow_lamda.png" alt></p>
<p>세 레이어로 구성된다.</p>
<ul>
<li><p>배치 레이어</p>
<p>모든 데이터는 배치 레이어에서 처리한다. 대규모 배치 처리를 위해 실행하며 1회 처리가 오래 걸린다.</p>
</li>
<li><p>서빙 레이어</p>
<p>배치 처리 결과는 서빙 레이어를 통해 접근한다. 응답이 빠른 데이터베이스를 설치해서 집계 결과를 바로 추출한다. </p>
<p>서빙 레이어에서 얻어진 결과를 배치 뷰 라고 한다. 정기적으로 업데이트 되지만 실시간 정보는 얻을 수 없다.</p>
</li>
<li><p>스피드 레이어</p>
<p>스피드 레이어에서 얻은 결과를 실시간 뷰라고 한다. 배치 뷰가 업데이트 될 동안에만 이용되고 오래된 데이터를 순서대로 삭제된다.</p>
</li>
</ul>
<p>배치뷰와 실시간 뷰를 조합시키는 형태로 쿼리를 실행한다. 최근 24시간 집계 결과는 실시간 뷰를 참고하고 그 이전 데이터는 배치뷰를 이용할 수 있다. </p>
<p>실시간 뷰의 결과는 나중에 배치 뷰로 치환된다. 그래서 스트림 처리가 정확하지 않아도 길게 보면 문제가 없다.</p>
</li>
<li><p>카파</p>
<p>람다 아키텍쳐는 스피드 레이어와 배치 레이어가 모두 같은 처리를 구현하고 있으므로 번거롭다.</p>
<p>그래서, 카파 아키테쳐는 스피드 레이어만 남긴다. 대신, 메세지 브로커의 데이터 보관 기한을 길게하여 문제 발생시 메세지 배송 시간을 과거로 다시 설정한다. 그러면 과거의 데이터가 다시 스트림 처리로 흘러 들어 실질적으로 재실행이 이루어진다.</p>
<p>문제점은, 부하가 높아진다는 것이다. 대량의 과거 데이터를 흘려보내면 평상시와 비교해 몇 배의 자원을 소비하기 때문이다. 클라우드 서비스 보급에 그런 자원을 확보하는 것이 어렵지 않으므로 필요에 따라 스트림 처리를 다시 하는것이 간단하는 것이 카파 아키텍쳐의 주장이다.</p>
</li>
</ol>
<h5 id="Out-of-Order-의-데이터-처리"><a href="#Out-of-Order-의-데이터-처리" class="headerlink" title="Out of Order 의 데이터 처리"></a>Out of Order 의 데이터 처리</h5><p><img src="/image/big_data_workflow_out_of_order.png" alt></p>
<p>스트림 처리를 할때 늦게 도달한 메세지, 즉 프로세스 시간과 이벤트 시간의 차이는, 이벤트 시간 윈도윙으로 해결한다.</p>
<p>즉, 이벤트 시간에 의해 윈도우를 나누는 것이다. </p>
<p>메세지가 배송된 데이터는 무작위 순이기 때문에 적절히 순서를 바꿔 집계 결과를 업데이트해야한다.</p>
<p>데이터가 도달할 때마다 해당하는 윈도우를 재집계한다. 데이터를 무한히 계속 보관할 수 없으므로 일정 이상 늦게 온 데이터는 무시한다.</p>
<hr>
<p>빅데이터를 지탱하는 기술 &lt;니시다 케이스케&gt;</p>

                    
                        

                    
                    
                        <p>
                            <a href="/2020/01/05/big-data-chapter5/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2020/01/02/big-data-chapter4/">
                            [빅데이터를 지탱하는 기술] 4장_빅데이터 축적
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2020-01-02T00:00:00+09:00">
	
		    Jan 02, 2020
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/big-data/">Big Data</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="1-벌크-형과-스트리밍-형의-데이터-수집"><a href="#1-벌크-형과-스트리밍-형의-데이터-수집" class="headerlink" title="1. 벌크 형과 스트리밍 형의 데이터 수집"></a>1. 벌크 형과 스트리밍 형의 데이터 수집</h2><p>데이터 수집 방법으로 두 가지 방법이 있다. </p>
<p>이 챕터에서는 각각의 방법으로, 분산 스토리지에 데이터가 저장되기 까지의 흐름을 정리한다.</p>
<ol>
<li>벌크 형 </li>
<li>스트리밍 형</li>
</ol>
<h5 id="객체-스토리지와-데이터-수집"><a href="#객체-스토리지와-데이터-수집" class="headerlink" title="객체 스토리지와 데이터 수집"></a>객체 스토리지와 데이터 수집</h5><p>빅데이터는 확장성이 높은 분산 스토리지에 저장된다. 분산 스토리지로,</p>
<ol>
<li><p>분산형 데이터베이스</p>
</li>
<li><p>대량으로 파일을 저장하는 객체 스토리지</p>
<p>객체 스토리지는 다수의 컴퓨터를 사용해 파일을 여러 디스크에 복사해서 데이터 중복화 및 부하 분산을 실현한다.</p>
<p>객체 스토리지의 구조는 데이터 양이 많을 때는 우수하지만, 소량의 데이터에 대해서는 비효율적이다.</p>
<p>하둡의 HDFS, 클라우드 서비스의 Amazon S3 가 대표적이다.</p>
</li>
</ol>
<h5 id="데이터-수집"><a href="#데이터-수집" class="headerlink" title="데이터 수집"></a>데이터 수집</h5><p>데이터 수집이란, 수집한 데이터를 가공해 집계 효율이 좋은 분산 스토리지를 만드는 일련의 프로세스이다. </p>
<p>작은 데이터는 적당히 모아서 하나의 큰 파일로 만들어 효율을 높이는데 도움이 된다. </p>
<p>파일이 지나치게 크면, 네트워크 전송 시간이 오래 걸려 오류 발생률이 높다. </p>
<h5 id="벌크-형-데이터-전송"><a href="#벌크-형-데이터-전송" class="headerlink" title="벌크 형 데이터 전송"></a>벌크 형 데이터 전송</h5><p><img src="/image/big_data_bulk_data.png" alt></p>
<p>전통적인 데이터 웨어하우스에서는 주로 벌크 형 방식으로 데이터베이스나 파일 서버 또는 웹 서비스 등에서 각각의 방식 (SQL, API …) 으로 정리해 데이터를 추출한다.</p>
<p>처음부터 분산 스토리지에 데이터가 저장되어 있지 않으면 데이터 전송을 위한 ETL 서버를 설치한다. </p>
<p>데이터 전송의 신뢰성이 중요하면 벌크형 도구를 사용하는 것이 좋다.</p>
<h5 id="파일-사이즈의-적정화"><a href="#파일-사이즈의-적정화" class="headerlink" title="파일 사이즈의 적정화"></a>파일 사이즈의 적정화</h5><p>ETL 프로세스는 하루마다 또는 한시간 마다의 간격으로 정기적인 실행을 하므로 그 동안 축적된 데이터는 하나로 모인다.</p>
<p>데이터 양이 많을 떄는 한 달씩이나 하루 단위로 전송하도록 작은 태스크로 분해해 한 번의 태스크 실행이 커지지 않도록 조정해야한다. </p>
<p>워크 플로우 관리 도구를 사용하면 쉽게 관리 할 수 있다.</p>
<h5 id="스트리밍-형의-데이터-전송"><a href="#스트리밍-형의-데이터-전송" class="headerlink" title="스트리밍 형의 데이터 전송"></a>스트리밍 형의 데이터 전송</h5><p><img src="/image/big_data_message_delivery.png" alt></p>
<p>계속해서 전송되어 오는 작은 데이터를 취급하기 위한 데이터 전송이다.</p>
<p>이러한 데이터 전송은 다수의 클라이언트에서 계속 작은 데이터가 전송된다. 이러한 데이터 전송 방식이 메세지 배송 (Message Delivery) 이다. </p>
<p>보내온 메세지를 저장하는 방법으로,</p>
<ol>
<li><p>NoSQL 데이터베이스</p>
<p>Hive 와 같은 쿼리 엔진으로 NoSQL 데이터베이스에 연결해 데이터를 읽을 수 있다. </p>
</li>
<li><p>Message Queue</p>
<p>데이터를 일정 간격으로 꺼내고 모아서 분산 스토리지에 저장한다.</p>
</li>
</ol>
<h5 id="웹-브라우저에서-메세지-배송"><a href="#웹-브라우저에서-메세지-배송" class="headerlink" title="웹 브라우저에서 메세지 배송"></a>웹 브라우저에서 메세지 배송</h5><p><img src="/image/big_data_message_web_browser.png" alt></p>
<ol>
<li><p>상주형 로그 수집 소프트웨어</p>
<p>자체 개발한 웹 애플리케이션 등에서는 웹 서버 안에서 메세지를 만들어서 배송한다. 전송 효율을 높이기 위해 서버상에서 일단 데이터를 축적해 놓고 나중에 모아서 보내는 경우가 있다. 이 때, Fluentd 나 Logstash 같은 상주형 로그 수집 소프트웨어가 자주 사용된다.</p>
</li>
<li><p>웹 이벤트 추적</p>
<p>자바스크립트를 이용해 웹 브라우에서 직접 메세지를 보내는 경우도 있다.</p>
</li>
</ol>
<h5 id="모바일-앱에서-메세지-배송"><a href="#모바일-앱에서-메세지-배송" class="headerlink" title="모바일 앱에서 메세지 배송"></a>모바일 앱에서 메세지 배송</h5><p><img src="/image/big_data_message_mobile.png" alt></p>
<ol>
<li><p>MBaaS</p>
<p>모바일 앱에서는 서버를 직접 마련하는 것이 아니라, MBaaS (Mobile Backend as a Serivce) 라는 백엔드의 각종 서비스를 이용할 수 있다. </p>
</li>
<li><p>SDK</p>
<p>모바일 앱이 오프라인이 되었을 때는 발생한 이벤트를 SDK 내부에 축적하고 온라인 상태 되었을 때 모아서 보낼 수 있다.</p>
</li>
</ol>
<h5 id="디바이스에서-메세지-배송"><a href="#디바이스에서-메세지-배송" class="headerlink" title="디바이스에서 메세지 배송"></a>디바이스에서 메세지 배송</h5><p><img src="/image/big_data_message_device.png" alt></p>
<p>MQTT (MQ Telemetry Transport) 는 TCP/IP 를 이용하여 데이터 전송하는 프로토콜 중 하나이다. 일반적으로 Pub/Sub 메세지 배송 구조이다. </p>
<h5 id="메세지-배송의-공통화"><a href="#메세지-배송의-공통화" class="headerlink" title="메세지 배송의 공통화"></a>메세지 배송의 공통화</h5><p>메세지가 처음 생성되는 기기를 클라이언트, 해당 메세지를 먼저 받는 서버를 프론트엔드라고 한다.</p>
<p>프론트 엔드는 단지 데이터를 받는 것에 전념하고, 그 이후의 문제는 백엔드의 공통 시스템에 맡길 수 있다.</p>
<h2 id="2-성능-신뢰성-메세지-배송의-트레이드오프"><a href="#2-성능-신뢰성-메세지-배송의-트레이드오프" class="headerlink" title="2. 성능, 신뢰성 : 메세지 배송의 트레이드오프"></a>2. 성능, 신뢰성 : 메세지 배송의 트레이드오프</h2><p>이 챕터는 메세지 브로커를 중심으로 메세지 배송 구조와 한계를 정리한다.</p>
<h5 id="메세지-브로커"><a href="#메세지-브로커" class="headerlink" title="메세지 브로커"></a>메세지 브로커</h5><p>메세지 배송에 의해 보내진 데이터를 분산 스토리지에 저장할 때, 데이터 양이 적을 때는 문제가 되지 않지만 쓰기의 빈도가 증가하면 디스크 성능의 한계에 도달해 더 쓸 수 없게 될 우려가 있다.</p>
<p>대량의 메세지를 안정적으로 받기 위해서는 빈번한 쓰기에도 견딜 수 있는 성능이 높고, 필요에 따라 성능을 얼마든지 올릴 수 있는 스토리지가 필요하다.</p>
<p>분산 스토리지가 반드시 이 성격을 가질 수 있다고 할 수 없기 때문에, 메세지를 일시적으로 축적하는 중산층이 설치된다. 이것이 메세지 브로커이다.</p>
<p>ex) Apache Kafka, Amazon Kinesis</p>
<h5 id="push-형-pull-형"><a href="#push-형-pull-형" class="headerlink" title="push 형, pull 형"></a>push 형, pull 형</h5><p>송신 측의 제어로 데이터를 보내는 방식을 push 형, 수신 측 주도로 데이터를 가져오는 것을 pull 형이라고 한다.</p>
<p>메세지 브로커에 데이터를 push 하는 것을 producer, pull 하는 것을 consumer 라고 한다.</p>
<p>push 형의 메세지 배송은 모두 메세지 브로커에 집중 시키고 거기에서 일정한 빈도로 꺼낸 데이터를 분산 스토리지에 기록한다.</p>
<p>또한, pull 형의 메세지 배송은 파일 사이즈 적정화에도 도움이 된다. consumer 는 메세지 브로커로부터 일정한 간격으로 데이터를 취해 적당히 모아진 데이터를 분산 스토리지에 저장한다.</p>
<h5 id="메세지-라우팅"><a href="#메세지-라우팅" class="headerlink" title="메세지 라우팅"></a>메세지 라우팅</h5><p>메세지 브로커에 써넣은 데이터는 다수의 다른 consumer 에서 읽을 수 있다. 이를 통해 메세지가 복사되어 데이터를 여러 경로로 분기 시킬 수 있다. 이것이 메세지 라우팅이다.</p>
<p>예를 들어, 메세지 일부를 실시간 장애 감지를 사용하면서, 같은 메세지를 장기적인 데이터 분석을 위한 분산 스토리지에 저장하는 것도 가능하다.</p>
<h5 id="메세지-배송-신뢰성-문제와-세-가지-설계-방식"><a href="#메세지-배송-신뢰성-문제와-세-가지-설계-방식" class="headerlink" title="메세지 배송 신뢰성 문제와 세 가지 설계 방식"></a>메세지 배송 신뢰성 문제와 세 가지 설계 방식</h5><p>대부분의 경우 다음 중 하나를 보장하도록 설계된다.</p>
<ol>
<li><p>at most once</p>
<p>메세지는 한 번만 전송된다. 도중에 전송 실패로 사라질 가능성이 있다.</p>
</li>
<li><p>exactly once</p>
<p>메세지는 손실 되거나 중복 없이 한 번만 전달된다.</p>
<p>네트워크 상에 두 개의 노드가 있는 경우 양쪽의 통신 내용을 보장하기 위해 coorninator 가 필요하다. 문제가 생기면 송신 측과 수신 측 모두 서로의 정보를 코디네이터에게 전달해서 문제가 발생하면 코디네이터의 지시에 따라 해결할 수 있다.</p>
<p>그러나 분산 시스템에서는 코디네이터와의 통신이 끊길 수 있고 코데네이터가 정지될 수도 있다. 따라서 코디네이터의 부재 시에 어덯게 할 것인지에 대한 consensus 가 필요하다. 보통, 단시간 장애 가능성은 받아 들인다.</p>
<p>또한, 코디네이터의 판단에만 따르고 있으면 시간이 너무 소요된다. </p>
<p>그래서 메세지 배송 시스템에서는 코디네이터를 도입하지 않고 at least once 를 따른다. </p>
</li>
<li><p>at least once</p>
<p>메세지는 확실히 전달된다. 단, 같은 것이 여러번 전달될 가능성이 있다.</p>
<p>메세지가 재전송되어도 그것을 없앨 수 있는 구조가 있으면 보기에 중복이 없는 것처럼 할 수 있다. 이러한 구조를 ‘중복 제거’ 라고 한다. </p>
<p>예를 들어, TCP 는 메세지 수신 확인을 위해 ‘ack’ 플래그를 도입했다. 메세지 재전송에 의한 중복이 발생하지만, 모든 TCP 패킷에서는 이것을 식별하는 시퀀스 번호를 이용해 중복 제거가 이뤄진다.</p>
<p>대부분의 메세지 배송 시스템은 at least once 를 보장하는 한편, 중복 제거는 이용자에게 맡기고 있어서 TCP/IP 처럼 자동으로 중복을 제거해주지 않는다. (ex) Apache Kafka, Apache Flume, Logstash</p>
</li>
</ol>
<h5 id="중복-제거는-높은-비용의-오퍼레이션"><a href="#중복-제거는-높은-비용의-오퍼레이션" class="headerlink" title="중복 제거는 높은 비용의 오퍼레이션"></a>중복 제거는 높은 비용의 오퍼레이션</h5><p>중복 제거 방법으로 다음과 같은 방법이 있다.</p>
<ol>
<li><p>오프셋 이용</p>
<p>각 메세지에는 파일 안의 시작 위치 (오프셋) 를 붙인다.</p>
<p>메세지가 중복되어도 같은 파일의 같은 장소를 덮어쓸 뿐이므로 문제되지 않는다.</p>
<p>벌 크형 데이터 전송과 같이 데이터양이 고정된 경우에 사용한다.</p>
</li>
<li><p>고유 ID 이용</p>
<p>모든 메세지에 UUID 등의 고유 ID 를 지정한다.</p>
<p>메세지가 늘어남에 따라 ID 가 증가하므로 그것을 어떻게 관리하느냐가 문제이다.</p>
<p>스트리밍 형의 메세지 배송에서 자주 사용된다. </p>
</li>
</ol>
<h5 id="End-to-End-신뢰성"><a href="#End-to-End-신뢰성" class="headerlink" title="End to End 신뢰성"></a>End to End 신뢰성</h5><p>클라이언트가 생성한 메세지를 최종 도달 지점인 분산 스토리지에 기록하는 단계에서 중복 없는 상태로 해야한다.</p>
<p>중간에 한 부분이라도 at most once 가 있으면 메세지를 빠뜨릴 가능성이 있고, at least once 가 있으면 중복될 수 있다. </p>
<p>신뢰성이 높은 메세지 배송을 실현하려면 중간 경로를 모두 at least once 로 통일한 후 클라이언트 상에서 모든 메세지에 고유 ID 를 포함하도록 하고 경로의 말단에서 중복 제거를 실행해야한다.</p>
<h5 id="고유-ID-를-사용한-중복-제거-방법"><a href="#고유-ID-를-사용한-중복-제거-방법" class="headerlink" title="고유 ID 를 사용한 중복 제거 방법"></a>고유 ID 를 사용한 중복 제거 방법</h5><p>두가지 방법이 있다.</p>
<ol>
<li><p>분산 스토리지로 NoSQL 데이터베이스 사용</p>
<p>Cassandra 나 Elasticsearch 등은 데이터를 쓸 대 고유 ID 를 지정하게 되어 있어 동일한 ID 의 데이터는 덮어쓴다.</p>
</li>
<li><p>SQL</p>
<p>보내온 데이터는 일단 그대로 객체 스토리지 등에 저장하고, 나중에 읽어 들이는 단계에서 중복을 제거한다. </p>
<p>Hive 와 같은 배치형 쿼리 엔진에서 실행할 수 있다.</p>
</li>
</ol>
<h5 id="데이터-수집-파이프라인"><a href="#데이터-수집-파이프라인" class="headerlink" title="데이터 수집 파이프라인"></a>데이터 수집 파이프라인</h5><p><img src="/image/big_data_stream_pipeline.png" alt></p>
<p>일련의 프로세스를 거쳐 마지막으로 데이터를 구조화해서 열 지향 스토리지로 변환함으로써, 장기간의 데이터 분석에 적합한 스토리가 완성된다. 이것인 데이터 수집 파이프라인이다.</p>
<p>실제로 어떤 파이프라인을 만들지는 요구사항에 따라 다르므로, 필요에 따라 시스템을 조합한다. </p>
<p>예를 들어, 쓰기 성능에 불안감이 없으면 메세지 브로커가 불필요 하므로 클라이언트에서 직접 NoSQL 데이터베이스에 데이터를 써도 된다. 중복이 허용된다면 중복 제거를 생략할 수 있다.</p>
<h5 id="중복을-고려한-시스템-설계"><a href="#중복을-고려한-시스템-설계" class="headerlink" title="중복을 고려한 시스템 설계"></a>중복을 고려한 시스템 설계</h5><p>스트리밍 형의 메세지 배송 방식에서는 중간에 중복 제거 방식을 도입하지 않으면 중복 가능성이 있다고 생각하면 된다.</p>
<p>신뢰성이 중시되는 경우에는 스트리밍 형의 메세지 배송을 피하는 것이 좋다.</p>
<p>예를 들어, 과금 데이터같은 오차가 불허용 되는 경우 트랜잭션 처리르 지원하는 데이터베이스에 직접 애플리케이션이 기록해야한다. 그 후에 벌크 형의 데이터 전송을 함으로써 중복도 결손도 확실히 피해야한다.</p>
<h2 id="3-TODO"><a href="#3-TODO" class="headerlink" title="3. TODO"></a>3. TODO</h2><h5 id="ㅇㅇㅇ"><a href="#ㅇㅇㅇ" class="headerlink" title="ㅇㅇㅇ"></a>ㅇㅇㅇ</h5><p>팩트 테이블 작성 방법으로,</p>
<ol>
<li><p>추가</p>
<p>새로 도착한 데이터만을 증분으로 추가</p>
</li>
<li><p>치환</p>
<p>과거 데이터를 포함하여 테이블 전체 치환</p>
</li>
</ol>
<h5 id="테이블-파티셔닝"><a href="#테이블-파티셔닝" class="headerlink" title="테이블 파티셔닝"></a>테이블 파티셔닝</h5><p>위의 ‘추가’ 방법은 다음 문제가 있다.</p>
<ol>
<li>추가에 실패한것을 알아채지 못하면, 팩트 테이블의 일부에 결손</li>
<li>추가를 잘못해서 여러번 실행하면, 일부 중복</li>
<li>나중에 팩트 테이블 다시 만들고 싶으면, 관리 복잡</li>
</ol>
<p>그래서 파티셔닝이 필요하다.</p>
<p>하나의 테이블을 여러 물리적인 파티션으로 나눠서 파티션 단위로 정리하여 데이터를 쓰거나 삭제하는 것이다.</p>
<h5 id="집계-테이블"><a href="#집계-테이블" class="headerlink" title="집계 테이블"></a>집계 테이블</h5><p>팩트 테이블을 어느 정도 모아서 집계하면 데이터의 양이 줄어든다. 이것은 집계 테이블이라고 한다.</p>
<p>각 칼럼이 취하는 값의 범위란, 카디널리티이다. ‘성별’ 과 같이 취할 수 있는 값이 적은 것은 카디널리티가 작은 것이다.</p>
<p>집계 테이블을 작게 하려면 모든 칼럼의 카디널리티를 줄여야한다.</p>
<h5 id="스냅샷-테이블-이력-테이블"><a href="#스냅샷-테이블-이력-테이블" class="headerlink" title="스냅샷 테이블, 이력 테이블"></a>스냅샷 테이블, 이력 테이블</h5><p>마스터 데이터처럼 업데이트 될 가능성이 있는 테이블은,</p>
<p>정기적으로 테이블을 통째로 저장하는 스탭샷 테이블, 또는 변경 내용만을 저장하는 이력 테이블로 관리할 수 있다.</p>
<h5 id="디멘전을-추가하여-비정규화-테이블-완성시키기"><a href="#디멘전을-추가하여-비정규화-테이블-완성시키기" class="headerlink" title="디멘전을 추가하여 비정규화 테이블 완성시키기"></a>디멘전을 추가하여 비정규화 테이블 완성시키기</h5><p>팩트 테이블과 디멘젼 테이블을 결합하여 비정규화 테이블을 만든다.</p>
<hr>
<p>빅데이터를 지탱하는 기술 &lt;니시다 케이스케&gt;</p>

                    
                        

                    
                    
                        <p>
                            <a href="/2020/01/02/big-data-chapter4/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
        
        <li class="pagination-number">page 1 of 1</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2020 junhee.ko. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/profile.jpg" alt="Author&#39;s picture"/>
        
            <h4 id="about-card-name">junhee.ko</h4>
        
            <div id="about-card-bio"><p>Always Learning</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>Engineer</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                Incheon
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/jquery.js"></script>
<script src="/assets/js/jquery.fancybox.js"></script>
<script src="/assets/js/thumbs.js"></script>
<script src="/assets/js/tranquilpeak.js"></script>
<!--SCRIPTS END-->



    </body>
</html>
