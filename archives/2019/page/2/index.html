
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="junhee.ko">
    <title>Archives: 2019 - junhee.ko</title>
    <meta name="author" content="junhee.ko">
    
    
    
    <script type="application/ld+json">{}</script>
    <meta name="description" content="always learning">
<meta property="og:type" content="blog">
<meta property="og:title" content="junhee.ko">
<meta property="og:url" content="https://kojunhee.github.io/archives/2019/page/2/index.html">
<meta property="og:site_name" content="junhee.ko">
<meta property="og:description" content="always learning">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="junhee.ko">
<meta name="twitter:description" content="always learning">
    
    
        
    
    
        <meta property="og:image" content="https://kojunhee.github.io/assets/images/profile.jpg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/all.css">
    <link rel="stylesheet" href="/assets/css/jquery.fancybox.css">
    <link rel="stylesheet" href="/assets/css/thumbs.css">
    <link rel="stylesheet" href="/assets/css/tranquilpeak.css">
    <!--STYLES END-->
    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="2">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a class="header-title-link" href="/ ">junhee.ko</a>
    </div>
    
        
            <a  class="header-right-picture "
                href="#about">
        
        
            <img class="header-picture" src="/assets/images/profile.jpg" alt="Author&#39;s picture"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="2">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a href="/#about">
                    <img class="sidebar-profile-picture" src="/assets/images/profile.jpg" alt="Author&#39;s picture"/>
                </a>
                <h4 class="sidebar-profile-name">junhee.ko</h4>
                
                    <h5 class="sidebar-profile-bio"><p>Always Learning</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/ "
                            
                            title="Home"
                        >
                    
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-categories"
                            
                            title="Categories"
                        >
                    
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-archives"
                            
                            title="Archives"
                        >
                    
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Archives</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://github.com/kojunhee" target="_blank" rel="noopener" title="GitHub">
                    
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://facebook.com/kojunheee" target="_blank" rel="noopener" title="Facebook">
                    
                        <i class="sidebar-button-icon fab fa-facebook" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Facebook</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://www.linkedin.com/in/junheeko" target="_blank" rel="noopener" title="LinkedIn">
                    
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="mailto:junheee.ko@gmail.com" target="_blank" rel="noopener" title="Mail">
                    
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="2"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2019/06/23/spark-intro/">
                            [스파크2 프로그래밍] 1장_스파크 소개
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-06-23T00:00:00+09:00">
	
		    Jun 23, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/spark/">Spark</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h3 id="1-1-스파크"><a href="#1-1-스파크" class="headerlink" title="1.1 스파크"></a>1.1 스파크</h3><h4 id="1-1-2-빅데이터의-정의"><a href="#1-1-2-빅데이터의-정의" class="headerlink" title="1.1.2 빅데이터의 정의"></a>1.1.2 빅데이터의 정의</h4><p>“다앙햔 형태를 지닌 대량의 데이터가 빠른 속도로 쌓이고 있다면 이를 빅데이터라고 부를 수 있다”</p>
<p>빅데이터의 중요한 특성 세 가지는 크기, 속도, 댜양성입니다.</p>
<ul>
<li>크기 : 대량의 데이터를 처리</li>
<li>속도 : 데이터의 증가가 지속적이고 빠르기 때문에 이에 부합하는 빠른 데이터 처리 기술이 필요</li>
<li>다양성 : 빅데이터의 다양성</li>
</ul>
<h4 id="1-1-3-빅데이터-솔루션"><a href="#1-1-3-빅데이터-솔루션" class="headerlink" title="1.1.3 빅데이터 솔루션"></a>1.1.3 빅데이터 솔루션</h4><p>먼저 빅데이터를 처리하는 플랫폼이니만큼 데이터를 가져오는 데이터 수집 모듈이 필요합니다. 다음으로는, 이렇게 수집된 데이터를 저장하고 조회하는 저장 및 조회 모듈이 필요합니다. 다음으로, 데이터를 분석하고 그 결과를 가공할 수 있는 모듈이 필요합니다. 그리고, 이제 이 모든 과정을 제어할 수 있는 워크플로우 엔진이 필요할 수도 있습니다. </p>
<ul>
<li>데이터 수집 : 플럼 / 카프카 / 스쿱</li>
<li>데이터 저장 및 처리 : 하둡 / HBase / 카산드라 / 레디스 / 피그 / 하이브 / 스파크</li>
<li>데이터 분석 및 기타 소프트웨어 : R / 클라우데라 / 엘라스틱서치</li>
</ul>
<h4 id="1-1-4-스파크"><a href="#1-1-4-스파크" class="headerlink" title="1.1.4 스파크"></a>1.1.4 스파크</h4><h5 id="하둡이란"><a href="#하둡이란" class="headerlink" title="하둡이란"></a>하둡이란</h5><p>빅데이터라는 용어가 이렇게 대중적으로 알려지게 된 데는 하둡의 탄생과 성공이 크게 기여했습니다. 하둡은 구글이 대용량 처리와 관련해서 공개한 두 개의 논문을 Doug Cutting 이 실제 제품으로 구현하면서 시작된 아파치 프로젝트를 가리키는 이름입니다. </p>
<p>하둡은 여러 대의 서버를 이용해서 하나의 클러스터를 구성하며, 이렇게 클러스터로 묶인 서버의 자원을 하나의 서버처럼 사용할 수 있는 클러스터 컴퓨팅 환경을 제공합니다. 기본 동작 방법은 <strong>분석할 데이터를 하둡 파일 시스템인 HDFS 에 저장해 두고, HDFS 상에서 Map Reduce 프로그램을 이용해 데이터 처리를 수행하는 방식</strong>입니다.</p>
<p>데이터를 저장할 때는 전체 데이터를 ‘블록’ 이라고 하는 일정한 크기로 나눠서 여러 데이터 노드에 분산해서 저장합니다. 이 때, 각 블록들이 어느 데이터 노드에 저장돼 있는지에 대한 메타정보를 네임 노드에 기록합니다. 그리고 맵 리듀스 작업을 실행할때는 네임노드로부터 메타정보를 읽어서 처리할 데이터의 위치를 확인하고 분산 처리를 수행합니다.</p>
<h5 id="맵리듀스란"><a href="#맵리듀스란" class="headerlink" title="맵리듀스란"></a>맵리듀스란</h5><p>맵리듀스 프레임워크는 하둡의 대표적인 데이터 처리 프레임워크입니다. 데이터를 여러 개 의 맵 프로세스와 리듀서 프로세스로 나눠서 처리하는 방식입니다. <strong>맵 프로세스는 여러 데이터 노드에서 분산 저장된 데이터를 각 서버에서 병렬로 나누어서 처리하며, 리듀서는 그러한 맵 프로세스들의 결과를 조합해 최종 결과를 만들어냅니다</strong>.</p>
<p>맵리듀스 잡의 제어는 네임노드에서 구동되는 잡 스케쥴러와 태스크 스케쥴러라는 프로세스가 처리했습니다. 하지만, 기본적으로 하나의 클러스터에서 한개의 맵리듀서 잡만 구동할 수 있었기 때문에 CPU와 메모리를 효율적으로 사용하지 못했습니다. 그래서, 하둡 2.0 부터 데이터 처리 작업에 대한 스케쥴링과 서버 자원 관리를 YARN 이라는 자원 관리 시스템에서 전담하면서 이러한 문제점이 개선됐습니다. </p>
<p>하둡만으로는 모든 데이터 처리를 수행하기에는 부족한 부분이 있었습니다.</p>
<ul>
<li>하둡의 맵리듀스 잡은 대부분의 연산 작업을 파일 시스템 기반으로 처리해서, 스파크 같은 메모리 기반 데이터 처리 방식에 비해 상대적으로 높은 성능을 기대하기 어려웠습니다.</li>
<li>맵리듀스 잡을 이용해서 데이터를 처리하려면 대부분 자바 언어를 사용해서 맵리듀스 프로그램을 작성해야했습니다.</li>
<li>외부 라이브러리의 도움 없이 단위 테스트를 작성하거나 실제 데이터를 대상으로 간단한 시뮬레이션을 하기 어려웠습니다.</li>
<li>SQL on Hadoop 인 하이브의 경우, 개발자들에게 친숙한 SQL 을 사용해서 맵리듀스 잡을 생성할 수 있지만, 이를 위해서는 미리 사용할 테이블과 데이터를 설계해야합니다.</li>
</ul>
<p>스파크는 하둡과 달리 <strong>메모리를 이용한 데이터 저장 방식을 제공</strong>함으로써 머신러닝 등 반복적인 데이터 처리가 필요한 분야에서 높은 성능을 보여줬습니다. 또한, <strong>작업을 실행하기 전에 최적의 처리 흐름을 찾는 과정</strong>으로 성능 향과 더불어 여러 개의 맵리듀스 잡을 직접 순차적으로 실행해야하는 수고를 덜 수 있게 됐습니다. 특히, 맵리듀스에 비해 훨씬 자연스럽고 강력한 다수의 데이터 처리 함수를 제공함으로써 프로그램의 복잡도를 낮춰줍니다. 또한, 스파크 2.0 부터 자바, 스칼라, 파이썬 뿐만 아니라 R 스크립트를 이용해서도 스파크 어플리케이션을 작성할수 있게 됐습니다.</p>
<h4 id="1-1-5-RDD-Dataset-DataFrame-소개와-연산"><a href="#1-1-5-RDD-Dataset-DataFrame-소개와-연산" class="headerlink" title="1.1.5 RDD, Dataset, DataFrame 소개와 연산"></a>1.1.5 RDD, Dataset, DataFrame 소개와 연산</h4><p>스파크 프로그램 내에서 데이터를 표현하고 처리하기 위한 프로그래밍 모델을 제공하는에 용도에 따라, RDD / Dataset / DataFrame 이라는 세가지 모델을 제공합니다.</p>
<p>RDD 는 스파크에서 정의한 분산 데이터 모델로서 병렬 처리가 가능한 요소로 구성되며 데이터를 처리하는 과정에서 프로그램 오류가 아닌 메모리 공간 부족 등의 이유로 일시적인 문제가 발생하더라도 <strong>스스로 에러를 복구 할 수 있는 능력을 가진 데이터 모델</strong>입니다.</p>
<p>스파크는 RDD 가 생성되어 변경되는 모든 광정을 일일이 기억 (Lineage) 하는 대신에 RDD 를 한번 생성되면 변경되지 않는 읽기 전용 모델로 만든 후 RDD 생성과 관련된 내용만 기억하고 있다가 장애가 발생하면 이전에 RDD 를 만들 때 수행했던 작업을 똑같이 실행해 (똑같은 데이터를 가진 새로운 RDD를 만들어) 데이터를 복구하는 방식을 사용하는 것입니다.</p>
<p>RDD 는 크게 세가지 방법으로 생성할 수 있습니다.</p>
<ul>
<li>List 나 Set 같은 기존 프로그램의 메모리에 생성된 데이터를 이용하는 것입니다.</li>
<li>로컬 파일시스템이나 하둡의 HDFS 같은 외부 저장소에 저장된 데이터를 읽어서 생성합니다.</li>
<li>기존에 생성되어 있는 RDD 로부터 또 다른 RDD 를 생성하는 방법입니다.</li>
</ul>
<p>RDD 를 생성하고 나면, RDD 가 제공하는 다양한 연산을 이용해 데이터를 처리하면 되는데, RDD 에서 제공하는 연산은 크게 Transformation 과 Action 이라는 두 종류로 나눌 수 있습니다.</p>
<ul>
<li>Transformation<ul>
<li>어떤 RDD 에 변형을 가해 새로운 RDD 를 생성하는 연산입니다. 변환 연산은 연산이 호출되는 시점에 바로 실행되는 것이 아니라, 변환을 어떻게 수행할 것인지에 대한 정보만 누적해서 가지고 있다가 Action 에 해당하는 연산이 호출될 때 한꺼번에 실행됩니다. 따라서 최종 실행이 필요한 시점에 누적된 변환 연산을 분석하고 그 중에서 최적의 방법을 찾아 변환 연산을 실행할 수 있습니다.</li>
</ul>
</li>
<li>Action<ul>
<li>연산의 결과로 RDD 가 아닌 다른 값을 반환하거나 아예 반환하지 않는 연산입니다.</li>
</ul>
</li>
</ul>
<h4 id="1-1-6-DAG"><a href="#1-1-6-DAG" class="headerlink" title="1.1.6 DAG"></a>1.1.6 DAG</h4><p>여러개의 꼭지점 또는 노드와 그 사이를 이어주는 방향성을 지닌 선으로 구성되고, 그래프를 구성하는 어느 꼭지점이나 노드에서 출발하더라도 다시 원래의 꼭지점으로 돌아오지 않도록 구성된 그래프 모델입니다.</p>
<p>스파크는 트렌스포메이션과 액션의 조합으로 데이터 흐름을 손쉽게 표현할 수 있습니다. 스파크에서 DAG 처리를 담당하는 부분을 DAG 스케쥴러라고합니다. 스케쥴러의 동작방식을 이해하기 위해서는 스파크의 작업 실행이 어떻게 수행되는지 이해해야합니다.</p>
<h5 id="스파크-작업-실행-순서-Driver-gt-DAG-Scheduler-gt-Cluster-Manager"><a href="#스파크-작업-실행-순서-Driver-gt-DAG-Scheduler-gt-Cluster-Manager" class="headerlink" title="스파크 작업 실행 순서 : Driver -&gt; DAG Scheduler -&gt; Cluster Manager"></a>스파크 작업 실행 순서 : Driver -&gt; DAG Scheduler -&gt; Cluster Manager</h5><p>스파크는 전체 작업을 Stage 라는 단위로 나누고, 각 스테이지를 다시 여러 개의 테스크로 나누어 실행합니다. 이 때, 최초의 메인함수를 실행해 RDD 등을 생성하고 각종 연산을 호출하는 프로그램을 Driver 프로그램이라고 합니다. Driver 프로그램은 메인 함수를 가진 일발적인 프로그램으로 작성하면 됩니다.</p>
<p>드라이버의 메인 함수에서는 스파크 애플리케이션과 스파크 클러스터의 연동을 담당하는 SparkContext 또는 SparkSession 이라는 객체를 만들고 이를 이용해 잡을 실행하고 종료하는 역할을 수행합니다. 드라이버가 스파크컨텍스트를 통해 RDD 의 연산정보를 DAG 스케쥴러에게 전달하면 스케쥴러는 이 정보를 가지고 실행 계획을 수립한 후에 이를 클러스터 메니저에게 전달합니다. 이 때, 스케쥴러가 생성하는 정보는 주로 데이터에 대한 지역성을 높이는 전략과 관련된것입니다. 전체 데이터 처리 흐름을 분석해서 네트워크를 통한 데이터 이동이 최소화 되도록 스테이지를 구성하는 것을 주로 수행합니다.</p>
<h4 id="1-1-7-람다-아키텍쳐"><a href="#1-1-7-람다-아키텍쳐" class="headerlink" title="1.1.7 람다 아키텍쳐"></a>1.1.7 람다 아키텍쳐</h4><p>빅데이터 처리를 위한 시스템을 구성하는 방법 중 하나입니다. 데이터를 처리하는 시스템을 일괄 처리를 담당하는 영역 (일괄 처리 계층) 과, 실시간 처리를 담당하는 영역 (속도 계층) 으로 나눈후 다음과 같이 운영합니다.</p>
<ol>
<li>새로운 데이터는 일관 처리 계층과 속도 계층 모두에 전달</li>
<li>일괄 처리 계층은 원본 데이터를 저장하고 일정 주기마다 한번씩 일괄적으로 가공해서 Batch View (결과 데이터) 를 생성</li>
<li>속도 계층은 들어오는 데이터를 즉시 또는 매우 짧은 주기로 처리해서 실시간 뷰를 생성</li>
<li>서빙 계층은 실시간 뷰와 배치 뷰의 결과를 적절히 조합해서 사용자에게 데이터를 전달</li>
</ol>
<p>정리하면, <strong>일괄 처리 작업을 통해 데이터를 처리하되 아직 배치 처리가 수행되지 않은 부분은 실시간 처리를 통해 보완</strong>한다는 개념입니다.</p>
<h3 id="1-2-스파크-설치"><a href="#1-2-스파크-설치" class="headerlink" title="1.2 스파크 설치"></a>1.2 스파크 설치</h3><h4 id="1-2-1-스파크-실행-모드의-이해"><a href="#1-2-1-스파크-실행-모드의-이해" class="headerlink" title="1.2.1 스파크 실행 모드의 이해"></a>1.2.1 스파크 실행 모드의 이해</h4><p>대부분의 빅데이터 소프트웨어들이 클러스터 환경에서 동작합니다. 클러스터란 <strong>여러대의 컴퓨터가 하나의 그룹을 형성해서 마치하나의 컴퓨터인 것처럼 동작하는 것</strong>을 의미합니다. 이처럼 여러 대의 서버가 마치 한 대의 서버처럼 동작해야하기 때문에 CPU 나 메모리, 디스크 등의 자원관리가 쉽지 않습니다. </p>
<p>스파크나 하둡과 같이 클러스터 환경에서 동작하는 대부분의 프레임워크는 실행 모드라는 개념을 가지고 있습니다. 즉, 개발 및 테스트를 위해서는 1대의 단독 서버 혹은 개인 PC 에서 애플리케이션을 실행하고, 실 서비스에서는 여러 서버로 구성된 클러스터 환경에서 동일한 어플리케이션을 실행할 수 있는 것입니다.</p>
<h4 id="1-2-5-스파크-쉘"><a href="#1-2-5-스파크-쉘" class="headerlink" title="1.2.5 스파크 쉘"></a>1.2.5 스파크 쉘</h4><p>스파크 어플리케이션을 실행하기 위해서는 <strong>메인 함수를 가진 어플리케이션을 작성하고, 스파크에서 제공하는 spark-submit 스크립트를 이용해서 실행</strong>합니다. </p>
<p>스파크는 프로그램을 작성해서 실행하는 방법 외에도, 인터렉티브 방식으로 프로그램을 작성할 수 있는 스파크 쉘도 제공합니다. 스파크 쉘은 사용하는 언어에 따라 스칼라, 파이썬, R 버젼으로 나눌 수 있습니다. </p>
<h4 id="1-2-6-실행-옵션"><a href="#1-2-6-실행-옵션" class="headerlink" title="1.2.6 실행 옵션"></a>1.2.6 실행 옵션</h4><p>스파크 쉘은 실행과 관련된 다양한 옵션을 제공합니다. “–help” 옵션으로 확인할 수 있습니다.</p>
<p>“–master” 옵션은 스파크가 사용할 <strong>클러스터의 마스터 정보를 지정하는 옵션</strong>입니다. 사용하는 클러스터 마스터 ( 혹은 메니저) 정보를 지정하는 옵션입니다.</p>
<p>만약 클러스터가 아닌 단일서버에서 동작시킬 경우에 “local” 이라고 입력합니다. 이 경우, 스파크 잡은 하나의 서버에서 하나의 스레드만 이용해서 동작합니다. 따라사 여러개의 스레들르 이용하려면 “local[2]” 처럼 지정합니다. 스레드 두 개를 사용한다는 의미입니다. “local[*]” 는 사용 가능한 모든 스레드를 사용합니다.</p>
<h3 id="1-4-예제-프로젝트-설정"><a href="#1-4-예제-프로젝트-설정" class="headerlink" title="1.4 예제 프로젝트 설정"></a>1.4 예제 프로젝트 설정</h3><h4 id="1-4-1-WordCount-예제-실행"><a href="#1-4-1-WordCount-예제-실행" class="headerlink" title="1.4.1 WordCount 예제 실행"></a>1.4.1 WordCount 예제 실행</h4><p>스파크 어플리케이션을 프로그래밍 하는 방법은, </p>
<ol>
<li>SparkContext 생성</li>
<li>입력 소스로부터 RDD 생성</li>
<li>RDD 처리</li>
<li>결과 파일 처리</li>
<li>SparkContext 종료</li>
</ol>

                    
                        

                    
                    
                        <p>
                            <a href="/2019/06/23/spark-intro/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2019/06/19/collections/">
                            [자바 ORM 표준 JPA 프로그래밍] 14장_컬렉션과 부가 기능
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-06-19T00:00:00+09:00">
	
		    Jun 19, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/jpa/">JPA</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>이 장에서 다루는 내용입니다.</p>
<ul>
<li>컬렉션</li>
<li>컨버터<ul>
<li>엔티티의 데이터를 변환해서 데이터베이스에 저장</li>
</ul>
</li>
<li>리스너<ul>
<li>엔티티에서 발생한 이벤트 처리</li>
</ul>
</li>
<li>엔티티 그래프<ul>
<li>엔티티를 조회할 때 연관된 엔티티를 선택해서 같이 조회</li>
</ul>
</li>
</ul>
<h4 id="14-1-컬렉션"><a href="#14-1-컬렉션" class="headerlink" title="14.1 컬렉션"></a>14.1 컬렉션</h4><p>JPA 는 자바에서 기본으로 제공하는 Collection / List / Set / Map 컬렉션을 지원합니다. </p>
<h5 id="14-1-1-JPA-와-컬렉션"><a href="#14-1-1-JPA-와-컬렉션" class="headerlink" title="14.1.1 JPA 와 컬렉션"></a>14.1.1 JPA 와 컬렉션</h5><p>하이버네이트는 엔티티를 영속 상태로 만들 때 컬렉션 필드를 하이버네이트에서 준비한 컬렉션으로 감싸서 사용합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Team</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Id</span></span><br><span class="line">  <span class="keyword">private</span> String id;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@OneToMany</span></span><br><span class="line">  <span class="meta">@JoinColumn</span></span><br><span class="line">  <span class="keyword">private</span> Collection&lt;Member&gt; members = <span class="keyword">new</span> ArrayList&lt;Member&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Team team = <span class="keyword">new</span> Team();</span><br><span class="line">System.out.println(<span class="string">"before Persist = "</span> + team.getMembers().getClass());</span><br><span class="line">em.persist(parent);</span><br><span class="line">System.out.println(<span class="string">"after Persist = "</span> + team.getMembers().getClass());</span><br></pre></td></tr></table></figure>

<p>출력 결과는 </p>
<p>before Persist = class java.util.ArrayList</p>
<p>after Persist = class org.hibernate.collection.internal.PersistentBag</p>
<p>하이버네이트는 컬렉션을 효율적으로 관리하기 위해, 엔티티를 영속 상태로 만들 때 원본 컬렉션을 감싸고 있는 내장 컬렉션을 생성해서 이 내장 컬렉션을 사용하도록 참조를 변경합니다. 하이버네이트가 제공하는 내장 컬렉션은 원본 컬렉션을 감싸고 있어서 래퍼 컬렉션이라고 부릅니다.</p>
<h5 id="14-1-2-Collection-List"><a href="#14-1-2-Collection-List" class="headerlink" title="14.1.2 Collection, List"></a>14.1.2 Collection, List</h5><p>중복을 허용하는 컬렉션이고 PersistentBag 을 래퍼 컬렉션으로 사용합니다. 이 인터페이스는 ArrayList 로 초기화하면 됩니다.</p>
<h5 id="14-1-3-Set"><a href="#14-1-3-Set" class="headerlink" title="14.1.3 Set"></a>14.1.3 Set</h5><p>중복을 허용하지 않는 컬렉션입니다. 하이버네이트는 PersistentSet 을 컬렉션 래퍼로 사용합니다. HashSet 으로 초기화하면 됩니다.</p>
<h5 id="14-1-4-List-OrderColumn"><a href="#14-1-4-List-OrderColumn" class="headerlink" title="14.1.4 List + @OrderColumn"></a>14.1.4 List + @OrderColumn</h5><p>List 인터페이스에 @OrderColumn 을 추가하면 순서가 있는 특수한 컬렉션으로 인식합니다. 순서가 있다는 의미는 데이터베이스에 순서 값을 저장해서 조회할 때 사용한다는 의미입니다. 하이버네이트는 내부 컬렉션인 PersistentList 를 사용합니다. </p>
<h5 id="14-1-5-OrderBy"><a href="#14-1-5-OrderBy" class="headerlink" title="14.1.5 @OrderBy"></a>14.1.5 @OrderBy</h5><p>데이터베이스의 ORDER BY 절을 사용해서 컬렉션을 정렬합니다. 따라서, 순서용 칼럼을 매핑하지 않아도 됩니다. 그리고 @OrderBy 는 모든 컬렉션에서 사용할 수 있습니다. </p>
<h4 id="14-2-Converter"><a href="#14-2-Converter" class="headerlink" title="14.2 @Converter"></a>14.2 @Converter</h4><p>엔티티의 데이터를 변환해서 데이터베이스에 저장합니다. </p>
<h4 id="14-3-리스너"><a href="#14-3-리스너" class="headerlink" title="14.3 리스너"></a>14.3 리스너</h4><p>엔티티의 생명주기에 따른 이벤트를 처리할 수 있습니다.</p>
<h5 id="14-3-2-이벤트-적용-위치"><a href="#14-3-2-이벤트-적용-위치" class="headerlink" title="14.3.2 이벤트 적용 위치"></a>14.3.2 이벤트 적용 위치</h5><ul>
<li>엔티티에 직접 적용<ul>
<li>엔티티에 이벤트가 발생할 때마다 어노테이션으로 지정한 메소드가 실행됩니다.</li>
</ul>
</li>
<li>별도의 리스너 등록<ul>
<li>대상 엔티티를 파라미터로 받을 수 있습니다. </li>
</ul>
</li>
<li>기본 리스너 사용 <ul>
<li>모든 엔티티의 이벤트를 처리하려면 META-INF/orm.xml 에 default 리스너로 등록하면 됩니다. </li>
</ul>
</li>
</ul>
<h4 id="14-4-엔티티-그래프"><a href="#14-4-엔티티-그래프" class="headerlink" title="14.4 엔티티 그래프"></a>14.4 엔티티 그래프</h4><p>엔티티를 조회할 때 연관된 엔티티를 함께 조회하려면 글로벌 fetch 옵션을 FetchType.EAGER 로 설정하거나 JPQL 엣 ㅓ페치 조인을 사용합니다. </p>
<p>엔티티 그래프 기능은 엔티티 조회 시점에 연관된 엔티티를 함께 조회하는 기능입니다. 엔티티 그래프는 정적으로 정의하는 Named 엔티티 그래프와 동적으로 정의하는 엔티티 그래프가 있습니다.</p>

                    
                        

                    
                    
                        <p>
                            <a href="/2019/06/19/collections/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2019/06/12/web-application-persistencen-context/">
                            [자바 ORM 표준 JPA 프로그래밍] 13장_웹 어플리케이션과 영속성 관리
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-06-12T00:00:00+09:00">
	
		    Jun 12, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/jpa/">JPA</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>이번 장에서는 컨테이너 환경에서 JPA 가 동작하는 내부 동작 방식을 이해하고, 발생할 수 있는 문제점과 해결방안을 정리합니다.</p>
<h4 id="13-1-트렌젝션-범위의-영속성-컨텍스트"><a href="#13-1-트렌젝션-범위의-영속성-컨텍스트" class="headerlink" title="13.1 트렌젝션 범위의 영속성 컨텍스트"></a>13.1 트렌젝션 범위의 영속성 컨텍스트</h4><p>스프링이나 J2EE 컨테이너 환경에서 JPA 를 사용하면 컨테이너가 제공하는 전략을 따라야합니다.</p>
<h5 id="13-1-1-스프링-컨테이너의-기본-전략"><a href="#13-1-1-스프링-컨테이너의-기본-전략" class="headerlink" title="13.1.1 스프링 컨테이너의 기본 전략"></a>13.1.1 스프링 컨테이너의 기본 전략</h5><p>스프링 컨테이너는 트렌젝션 범위의 영속성 컨텐스트 전략을 기본으로 합니다. 즉, 트렌젝션을 시작할 때 영속성 컨텍스트를 생성하고 끝날 때 영속성 컨텍스트를 종료합니다. 그리고, 같은 트렌젝션 안에서는 항상 같은 영속성 컨텍스트에 접근합니다. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloController</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Autowired</span> HelloService helloService;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//반환된 member 엔티티는 준영속 상태</span></span><br><span class="line">    Member member = helloService.logic();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloService</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 엔티티 메니저 주입</span></span><br><span class="line">  <span class="meta">@PersistenceContext</span></span><br><span class="line">  EntityManager em;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Autowired</span> Repository1 repository1;</span><br><span class="line">  <span class="meta">@Autowired</span> Repository2 repository2;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//트랜잭션 시작</span></span><br><span class="line">  <span class="meta">@Transactional</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logic</span><span class="params">()</span></span>&#123;</span><br><span class="line">    repository1.hello();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Member 는 영속상태</span></span><br><span class="line">    Member member = repository2.findMember();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> member;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//트렌젝션 종료</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Repository1</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@PersistenceContext</span></span><br><span class="line">  EntityManager em;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">    em.xxx(); <span class="comment">//영속성 컨텍스트 접근</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Repository2</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@PersistenceContext</span></span><br><span class="line">  EntityManager em;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Member <span class="title">findMember</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> em.find(Member.class, <span class="string">"id1"</span>); <span class="comment">//영속성 컨텍스트 접근</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="13-2-준영속-상태와-지연-로딩"><a href="#13-2-준영속-상태와-지연-로딩" class="headerlink" title="13.2 준영속 상태와 지연 로딩"></a>13.2 준영속 상태와 지연 로딩</h4><p>조회한 엔티티가 서비스와 리포지토리 계층에서는 영속성 컨텍스트에 관리되면서 영속 상태를 유지하지만, 컨트롤러나 뷰 같은 프리젠테이션 계층에서는 준영속 상태가 됩니다. 따라서, 변경감지와 지연로딩이 동작하지 않습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span></span>&#123;</span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@GeneratedValue</span></span><br><span class="line">  <span class="keyword">private</span> Long id;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@ManyToOne</span>(fetch = FetchType.LAZY) <span class="comment">//지연로딩</span></span><br><span class="line">  <span class="keyword">private</span> Member member; <span class="comment">//주문 회원</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderController</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">view</span><span class="params">(Long orderId)</span></span>&#123;</span><br><span class="line">    Order order = orderService.findOne(orderId);</span><br><span class="line">    Member member = order.getMember();</span><br><span class="line">    member.getName(); <span class="comment">//지연로딩 시 예외 발생</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>준영속 상태와 변경 감지</li>
</ul>
<p>변경감지 기능이 프리젠테이션 계층에서 동작하지 않는것은 문제가 되지 않습니다. 변경 감지 기능이 프리젠테이션 계층에서도 동작하면 애플리케이션 계층이 가지는 책임이 모호해지고, 데이터를 어디서 어떻게 변경했는지 프리젠테이션 계층까지 다 찾아야 하므로 유지보수하기 어렵습니다. 비즈니스 로직은 서비스 계층에서 끝내야합니다.</p>
<ul>
<li>준영속 상태와 지연 로딩</li>
</ul>
<p>준영속 상태의 지연 로딩을 해결하는 방법은 두 가지 입니다. </p>
<ol>
<li>뷰가 필요한 엔티티를 미리 로딩</li>
<li>OSIV</li>
</ol>
<p>뷰가 필요한 엔티티를 미리 로딩하는 방법은 어디서 미리 로딩 하느냐에 따라 세가지가 있습니다.</p>
<ol>
<li>글로벌 페치 전략 수정</li>
<li>JPQL Fetch Join</li>
<li>강제 초기화</li>
</ol>
<h5 id="13-2-1-글로벌-페치-전략-수정"><a href="#13-2-1-글로벌-페치-전략-수정" class="headerlink" title="13.2.1 글로벌 페치 전략 수정"></a>13.2.1 글로벌 페치 전략 수정</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span></span>&#123;</span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@GeneratedValue</span></span><br><span class="line">  <span class="keyword">private</span> Long id;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@ManyToOne</span>(fetch = FetchType.EAGER) <span class="comment">//즉시 로딩 전략</span></span><br><span class="line">  <span class="keyword">private</span> Member member; <span class="comment">//주문 회원</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Presentation Logic</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderController</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">view</span><span class="params">(Long orderId)</span></span>&#123;</span><br><span class="line">    Order order = orderService.findOne(orderId);</span><br><span class="line">    Member member = order.getMember();</span><br><span class="line">    member.getName(); <span class="comment">//이미 로딩된 엔티티</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>글로벌 페치 전략에 즉시 로딩 사용시 단점은 두가지가 있습니다.</p>
<ol>
<li>사용하지 않는 엔티티를 로딩</li>
</ol>
<p>order 를 조회하면서 사용하지 않는 member 도 함께 조회</p>
<ol start="2">
<li>N+1 문제</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Order order = em.find(Order.class, <span class="number">1L</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//실행된 SQL</span></span><br><span class="line">select o.*, m.*</span><br><span class="line">from Order o</span><br><span class="line">left outer join Member m on o.MEMBER_ID = m.MEMBER_ID</span><br><span class="line">where o.id = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>여기까지 보면 글로벌 즉시 로딩 전략이 좋아보이지만, 문제는 JPQL 을 사용할 때 발생합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List &lt;Order&gt; orders = em.createQuery(<span class="string">"select o from Order o"</span>, Order.class).getResultList();</span><br><span class="line"></span><br><span class="line"><span class="comment">//실행된 SQL</span></span><br><span class="line">select * from Order <span class="comment">//JPQL 로 실행된 SQL</span></span><br><span class="line">select * from Member where id = ? <span class="comment">//EAGER 로 실행된 SQL</span></span><br><span class="line">select * from Member where id = ? <span class="comment">//EAGER 로 실행된 SQL</span></span><br><span class="line">select * from Member where id = ? <span class="comment">//EAGER 로 실행된 SQL</span></span><br><span class="line">select * from Member where id = ? <span class="comment">//EAGER 로 실행된 SQL</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>JPA 가 JPQL 을 분석해서 SQL 을 생성할 때, 글로벌 패치 전략을 참고하지 않고 오직 JPQL 자체만 사용합니다. 따라서, 즉시로딩이든 지연 로딩이등 구분하지 않고 JPQL 쿼리 자체에 충신한 SQL 을 만듦니다.</p>
<p>이런 N+1 문제는 이어서 소개할 JPQL Fetch Join 으로 해결할 수 있습니다.</p>
<h5 id="13-2-2-JPQL-Fetch-Join"><a href="#13-2-2-JPQL-Fetch-Join" class="headerlink" title="13.2.2 JPQL Fetch Join"></a>13.2.2 JPQL Fetch Join</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Fetch Join 사용 전</span></span><br><span class="line">JPQL : select o from Order o</span><br><span class="line">SQL : select * from Order</span><br><span class="line"></span><br><span class="line"><span class="comment">//Fetch Join 사용 후</span></span><br><span class="line">JPQL :</span><br><span class="line">	select o </span><br><span class="line">	from Order o</span><br><span class="line">	join fetch o.member</span><br><span class="line">	</span><br><span class="line">SQL :</span><br><span class="line">	select o.*, m.*</span><br><span class="line">	from Order o</span><br><span class="line">	join Member m on o.MEMBER_ID = m.MEMBER_ID</span><br></pre></td></tr></table></figure>

<p>Fetch Join 을 사용하면, SQL JOIN 을 사용해서 페치 조인 대상까지 함께 조회합니다. N+1 문제가 발생하지 않습니다.</p>
<ul>
<li>JPQL Fetch Join 의 단점</li>
</ul>
<p>무분별하게 사용하면 화면에 맞춘 리포지토리 메소드가 증가할 수 있습니다. 결국 프리젠테이션 계층이 데이터 접근 계층을 침범하는 것입니다.</p>
<h5 id="13-2-3-강제로-초기화"><a href="#13-2-3-강제로-초기화" class="headerlink" title="13.2.3 강제로 초기화"></a>13.2.3 강제로 초기화</h5><p>영속성 컨테스트가 살아있을 때 프리젠테이션 계층이 필요한 엔티티를 강제로 초기화해서 반환하는 방법입니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderService</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Transactional</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Order <span class="title">findOrder</span><span class="params">(id)</span></span>&#123;</span><br><span class="line">    Order order = oderRepository.findOrder(id);</span><br><span class="line">    order.getMember().getName(); <span class="comment">//프록시 객체를 강제로 초기화</span></span><br><span class="line">    <span class="keyword">return</span> order;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>글로벌 페치 전략을 지연로딩으로 설정하면, 연관된 엔티리를 실제 엔티티가 아닌 프록시 객체로 조회합니다. 프록시 객체는 실제 사용하는 시점에 초기화됩니다. order.getMember() 까지만 호출하면. 단순히 프록시 객체만 반환합니다. 아직 초기화 하지 않습니다. member.getName() 처럼 실제 값을 사용할 때 초기화됩니다.</p>
<p>프록시 초기화 하는 역하을 서비스 계층이 담당하면, 뷰가 필요한 엔티티에 따라 서비스 계층의 로직을 변경해야 합니다. 비즈니스 로직을 담당하는 서비스 계층에서 프리젠테이션 계층을 위한 프록시 초기화 역할을 하는 FACADE 계층이 그 역할을 담당해줍니다.</p>
<h5 id="13-2-4-FACADE-계층-추가"><a href="#13-2-4-FACADE-계층-추가" class="headerlink" title="13.2.4 FACADE 계층 추가"></a>13.2.4 FACADE 계층 추가</h5><ul>
<li><p>프리젠테이션 계층과 도메인 모델 계층간의 논리적 의존성을 분리합니다. </p>
</li>
<li><p>프리젠테이션 계층에서 필요한 프록시 객체를 초기화합니다.</p>
</li>
<li><p>서비스 계층을 호출해서 비즈니스 로직을 실행합니다.</p>
</li>
<li><p>리포지토리를 직접 호출해서 뷰가 요구하는 엔티티를 찾습니다.</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderFacade</span></span>&#123;</span><br><span class="line">	<span class="meta">@Autowired</span> OrderService orderService;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Order <span class="title">findOrder</span><span class="params">(id)</span></span>&#123;</span><br><span class="line">    Order order = orderService.findOrder(id);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//프리젠테이션 계층이 필요한 프록시 객체를 강제 초기화</span></span><br><span class="line">    order.getMember().getName();</span><br><span class="line">    <span class="keyword">return</span> order;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderService</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Order <span class="title">findOrder</span><span class="params">(id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> orderRepository.findOrder(id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="13-3-OSIV-Open-Session-in-View"><a href="#13-3-OSIV-Open-Session-in-View" class="headerlink" title="13.3 OSIV (Open Session in View)"></a>13.3 OSIV (Open Session in View)</h4><p>영속성 컨텍스트를 뷰까지 열어둔다는 뜻입니다. </p>
<h5 id="13-3-1-과거-OSIV-요청-당-트렌젝션"><a href="#13-3-1-과거-OSIV-요청-당-트렌젝션" class="headerlink" title="13.3.1 과거 OSIV : 요청 당 트렌젝션"></a>13.3.1 과거 OSIV : 요청 당 트렌젝션</h5><p>OSIV 의 핵심은 뷰에서도 지연로딩이 가능하도록 하는 것입니다. 가장 단순한 구현은 클라이언트의 요청이 들어오자마자 서플릿 필터나 스프링 인터셉터에서 트렌젝션을 시작하고 요청을 끝날 때 트렌젝션도 끝내는 것입니다. 이것을 요청 당 트렌젝션 방식의 OSIV 라고 합니다.</p>
<p>문제는, 프레센테이션 계층이 엔티티를 변경할 수 있다는 것입니다. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MemberControlelr</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">viewMember</span><span class="params">(Long id)</span></span>&#123;</span><br><span class="line">    Member member = memberService.getMember(id);</span><br><span class="line">    member.setName(<span class="string">"XXX"</span>);</span><br><span class="line">    model.addAttribute(<span class="string">"member"</span>, member);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>개발자의 의도는 단순히 뷰에 노출할 때만 고객이름을 XXX 로 변경하고 싶은 것이지, 데이터베이스에 있는 고객 이름까지 변경하고자 하는 것이 아니었습니다. 하지만 요청당 트렌젝션 방식은 뷰 렌더링 이후에 트렌젝션으 커밋합니다. 커밋을 하면 영속성 컨텍스트를 플러쉬합니다. 영속성 컨텍스트의 변경 감지 기능이 동작해서 변경된 엔티티를 데이터베이스에 반영해버립니다.</p>
<p>따라서, 프레젠테이션 계층에서 엔티티를 수정하지 못하게 해야합니다.</p>
<ul>
<li>엔티티를 읽기 전용 인터페이스로 제공</li>
<li>엔티티 레핑</li>
<li>DTO 만 반환</li>
</ul>
<h6 id="엔티티를-읽기-전용-인터페이스로-제공"><a href="#엔티티를-읽기-전용-인터페이스로-제공" class="headerlink" title="엔티티를 읽기 전용 인터페이스로 제공"></a>엔티티를 읽기 전용 인터페이스로 제공</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MemberView</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Member</span> <span class="keyword">implements</span> <span class="title">MemberView</span></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MemberService</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> MemberView <span class="title">getMember</span><span class="params">(id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> memberRepository.findById(id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="엔티티-레핑"><a href="#엔티티-레핑" class="headerlink" title="엔티티 레핑"></a>엔티티 레핑</h6><p>엔티티의 읽기 전용 메소드만 가지고 있는 엔티티를 감싼 객체를 만들고, 이것을 프리젠테이션 계층에 반환하는 방법입니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MemberWrapper</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Member member;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MemberWrapper</span><span class="params">(member)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.member = member;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 읽기 전용 메소드만 제공</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">    member.getName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="DTO-만-반환"><a href="#DTO-만-반환" class="headerlink" title="DTO 만 반환"></a>DTO 만 반환</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MemberDTO</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> STring name;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//GETTER, SETTER</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">MemberDTO memberDTO = <span class="keyword">new</span> MemberDTO();</span><br><span class="line">memberDTO.setName(member.getName());</span><br><span class="line"><span class="keyword">return</span> memberDTO;</span><br></pre></td></tr></table></figure>

<p>최근에는 비즈니스 계층에서만 트렌젝션을 유지하는 방식의 OSIV 를 사용합니다. 스프링 프레임워크가 제공하는 OSIV 방식입니다.</p>
<h5 id="13-3-2-스프링-OSIV-비즈니스-계층-트렌젝션"><a href="#13-3-2-스프링-OSIV-비즈니스-계층-트렌젝션" class="headerlink" title="13.3.2 스프링 OSIV : 비즈니스 계층 트렌젝션"></a>13.3.2 스프링 OSIV : 비즈니스 계층 트렌젝션</h5><p>클라이언트의 요청이 들어오면 영속성 컨텍스트를 생성합니다. 이 때, 트렌젝션을 시작하지 않습니다. 서비스 계층에서 트렌젝션을 시작하면 앞에서 생성해둔 영속성 켄텍스트에 트렌젝션을 시작합니다. 비즈니스 로직을 실행하고 서비스 계층이 끝나면 트렌젝셩르 커밋하면서 영속성 컨텍스트를 플러쉬합니다. 이때, 트렌젝션만 종료하고 영속성 컨텍스트를 살려둡니다. 클라이언트의 요청이 끝날 때 영속성 컨텍스트를 종료합니다.</p>
<p>엔티티를 변경하지 않고 단순히 조회만 할 때는 트렌젝션이 없어도 되는데, 이것을 트렌젝션 없이 읽기라고 합니다. 영속성 컨텍스트는 트렌젝션 범위 안에서 엔티티를 조회하고 수정할 수 있습니다. 영속성 컨텍스트는 트렌젝션 범위 밖에서 엔티리를 조회만 할 수 있습니다.</p>

                    
                        

                    
                    
                        <p>
                            <a href="/2019/06/12/web-application-persistencen-context/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2019/06/05/web-application/">
                            [자바 ORM 표준 JPA 프로그래밍] 11장_웹 어플리케이션 제작
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-06-05T00:00:00+09:00">
	
		    Jun 05, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/jpa/">JPA</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>11장은 Spring Framework 와 JPA 를 사용해서 Web Application 을 만들어보는 장입니다. 진행 순서는 다음과 같습니다.</p>
<ol>
<li>프로젝트 환경설정</li>
<li>도메인 모델과 테이블 설계</li>
<li>기능 구현</li>
</ol>
<p>코드 위주의 챕터이기 때문에, 핵심 키워드 위주로 정리하려고 합니다.</p>
<h4 id="11-1-프로젝트-환경설정"><a href="#11-1-프로젝트-환경설정" class="headerlink" title="11.1 프로젝트 환경설정"></a>11.1 프로젝트 환경설정</h4><h4 id="11-2-도메인-모델과-테이블-설계"><a href="#11-2-도메인-모델과-테이블-설계" class="headerlink" title="11.2 도메인 모델과 테이블 설계"></a>11.2 도메인 모델과 테이블 설계</h4><h5 id="11-2-1-요구사항-분석"><a href="#11-2-1-요구사항-분석" class="headerlink" title="11.2.1 요구사항 분석"></a>11.2.1 요구사항 분석</h5><ul>
<li><p>회원 기능</p>
<ul>
<li>등록</li>
<li>조회</li>
</ul>
</li>
<li><p>상품 기능</p>
<ul>
<li>등록</li>
<li>수정</li>
<li>조회</li>
</ul>
</li>
<li><p>주문</p>
<ul>
<li>주문</li>
<li>조회</li>
<li>취소</li>
</ul>
</li>
<li><p>기타</p>
<ul>
<li>상품 종류 : 도서 / 음반 / 영화</li>
<li>상품은 카테고리로 구분 가능</li>
<li>상품 주문 시 배송 정보 입력 가능</li>
</ul>
</li>
</ul>
<h5 id="11-2-2-도메인-모델-설계"><a href="#11-2-2-도메인-모델-설계" class="headerlink" title="11.2.2 도메인 모델 설계"></a>11.2.2 도메인 모델 설계</h5><ul>
<li>회원 / 주문 / 상품<ul>
<li>주문과 상품은 다대다 관계<ul>
<li>다대다 관계는 관계형 데이터베이스는 물론이고, 엔티티에서도 거의 사용하지 않음</li>
<li>주문 상품이라는 엔티티를 추가해서 다다대 관계를 일대다, 다대일 관계로 풀어냄</li>
</ul>
</li>
<li>상품 분류<ul>
<li>상품은 도서, 음반, 영화로 구분되는데, 상품이라는 공통 속성을 사용하므로 상속 구조로 표현</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="11-2-3-테이블-설계"><a href="#11-2-3-테이블-설계" class="headerlink" title="11.2.3 테이블 설계"></a>11.2.3 테이블 설계</h5><h5 id="11-2-4-연관-관계-정리"><a href="#11-2-4-연관-관계-정리" class="headerlink" title="11.2.4 연관 관계 정리"></a>11.2.4 연관 관계 정리</h5><ul>
<li>회원과 주문<ul>
<li>일대다 양방향 관계</li>
<li>연관 관계의 주인을 정해야함. 외래키가 있는 주문이 연관 관계의 주인.</li>
</ul>
</li>
<li>주문 상품과 주문<ul>
<li>다대일 양방향 관계</li>
<li>주문 상품이 연관관계의 주인</li>
</ul>
</li>
<li>주문 상품과 상품<ul>
<li>일대일 단방향 관계</li>
</ul>
</li>
<li>주문과 배송<ul>
<li>일대일 양방향 관계</li>
</ul>
</li>
<li>카테고리와 상품<ul>
<li>@ManyToMany</li>
</ul>
</li>
</ul>
<h5 id="11-2-5-엔티티-클래스"><a href="#11-2-5-엔티티-클래스" class="headerlink" title="11.2.5 엔티티 클래스"></a>11.2.5 엔티티 클래스</h5><h4 id="11-3-애플리케이션-구현"><a href="#11-3-애플리케이션-구현" class="headerlink" title="11.3 애플리케이션 구현"></a>11.3 애플리케이션 구현</h4><h5 id="11-3-1-개발-방법"><a href="#11-3-1-개발-방법" class="headerlink" title="11.3.1 개발 방법"></a>11.3.1 개발 방법</h5><ul>
<li>Controller<ul>
<li>MVC 의 컨트롤러가 모여있는 곳</li>
<li>서비스 계층을 호출하고 결과를 뷰에 전달</li>
</ul>
</li>
<li>Service<ul>
<li>비즈니스 로직이 있고 트렌젝션을 시작</li>
<li>데이터 접근 계층인 Repository를 호출</li>
</ul>
</li>
<li>Repository<ul>
<li>JPA 를 직접 사용하는 곳</li>
<li>Entity Manager 를 사용해서 Entity 를 저장하고 조회</li>
</ul>
</li>
<li>Domain<ul>
<li>엔티티가 모여 있는 계층</li>
<li>모든 계층에서 사용</li>
</ul>
</li>
</ul>
<h5 id="11-3-2-회원-기능"><a href="#11-3-2-회원-기능" class="headerlink" title="11.3.2 회원 기능"></a>11.3.2 회원 기능</h5><p>순수 자바 환경에셔는 엔티티 메니저 팩토리에서 엔티티 메니저를 직접 생성해서 사용했지만, 스프링이나 J2EE 컨테이너를 사용하면 컨테이너가 엔티티 메니저를 관리하고 제공합니다. 그래서, 엔티티 메니저 팩토리에서 엔티티 메니저를 직접 생성해서 사용하지 않고, 컨테이너가 제공하는 엔티티 메니저를 사용합니다.</p>
<p>@PersistenceContext 는 컨테이너가 관리하는 엔티티 메니저를 주입하는 Annotation 입니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PersistenceContext</span></span><br><span class="line">EntityManager em;</span><br></pre></td></tr></table></figure>

<h5 id="11-3-3-상품-기능"><a href="#11-3-3-상품-기능" class="headerlink" title="11.3.3 상품 기능"></a>11.3.3 상품 기능</h5><h5 id="11-3-4-주문-기능"><a href="#11-3-4-주문-기능" class="headerlink" title="11.3.4 주문 기능"></a>11.3.4 주문 기능</h5><p>주문 서비스의 주문과 주문 취소 메소드를 보면 비즈니스 로직 대부분이 엔티티에 있습니다. 서비스 계층은 단순히 엔티티에 필요한 요청을 위임하는 역할을 합니다. 이처럼, 엔티티가 비즈니로스 로직을 가지고 객체지향의 특성을 활용하는 것을 도메인 모델 패턴이라고 합니다.</p>
<p>반대로, 엔티티에는 비즈니스 로직이 거의 없고 서비스 계층에서 대부분의 비즈니스 로직을 처리하는 것을 트랜잭션 스크립트 패턴이라고 합니다. </p>
<h5 id="11-3-5-웹-계층-구현"><a href="#11-3-5-웹-계층-구현" class="headerlink" title="11.3.5 웹 계층 구현"></a>11.3.5 웹 계층 구현</h5><p>준영속 엔티티를 수정하는 방법은 2가지입니다.</p>
<ul>
<li>변경 감지 기능 사용</li>
<li>병합 사용</li>
</ul>
<p>변경 감지 기능을 사용하는 방법은, 영속성 컨텍스트에서 엔티티를 다시 조회한 후에 데이터를 수정하는 방법입니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="comment">//itemParam : Parameter 로 넘어온 준영속 상태의 엔티티</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(Item itemParam)</span></span>&#123;</span><br><span class="line">  <span class="comment">//같은 엔티티를 조회</span></span><br><span class="line">  Item findItem = em.find(Item.class, itemParam.getId());</span><br><span class="line">  </span><br><span class="line">  findItem.setPrice(itemParam.getPrice()); <span class="comment">//데이터 수정</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위 코드처럼, 트렌젝션 안에서 준영속 엔티티의 식별자로 엔티티를 다시 조회하면, 영속 상태의 엔티티를 얻을 수 있습니다. 이렇게 영속 상태인 엔티티의 값을 파라미터로 넘어온 준영속 사앹의 엔티티 값으로 변경하면 됩니다. 이렇게 하면, 이후 트렌젝션이 커밋될때 변경감지 기능이 동작해서 데이터베이스에 수정사항이 반영됩니다.</p>
<p>병합은 파라미터로 넘긴 준영속 엔티티의 식별자 값으로 영속 엔티티를 조회하고, 영속 엔티티의 값을 준영속 엔티티의 값으로 채워넣습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="comment">//itemParam : Parameter 로 넘어온 준영속 상태의 엔티티</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(Item itemParam)</span></span>&#123;</span><br><span class="line">  Item mergeItem = em.merge(itemParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>변경 감지 기능을 사용하면, 원하는 속성만 선택해서 변경할 수 있지만, 병합을 사용하면 모든 속성이 변경됩니다.</p>

                    
                        

                    
                    
                        <p>
                            <a href="/2019/06/05/web-application/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2019/04/21/spring-data-jpa/">
                            [자바 ORM 표준 JPA 프로그래밍] 12장_스프링 데이터 JPA
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-04-21T00:00:00+09:00">
	
		    Apr 21, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/jpa/">JPA</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>데이터 접근 계층 (Data Access Layer) 는 CRUD 로 불리는 등록, 수정, 삭제, 조회 코드를 반복해서 개발해야 합니다. JPA 를 사용해서 데이터 접근 계층을 개발할 때도 문제가 발생합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemberRepository</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@PersistenceContext</span></span><br><span class="line">  EntityManager em;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(Member member)</span> </span>&#123;...&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Member <span class="title">findOne</span><span class="params">(Long id)</span> </span>&#123;...&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Member&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Member <span class="title">findByUsername</span><span class="params">(String username)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ItemRepository</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@PersistenceContext</span></span><br><span class="line">  EntityManager em;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(Item item)</span> </span>&#123;...&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Member <span class="title">findOne</span><span class="params">(Long id)</span> </span>&#123;...&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Member&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위 코드를 보면, 회원 리포지토리와 상품 리포지토리가 하는 일이 비슷합니다. 이 문제를 해결하려면 제네릭과 상속을 적절히 사용해서 공통 부분을 처리하는 부모 클래스를 만들면 됩니다. 이것을 보통 GenericDAO 라고 합니다. 하지만 이것은, 공통 기능을 구렿낳ㄴ 부모 클래스에 종속되고 구현 클래스 상속이 가지는 단점이 있습니다. </p>
<h4 id="12-1-스프링-데이터-JPA-소개"><a href="#12-1-스프링-데이터-JPA-소개" class="headerlink" title="12.1 스프링 데이터 JPA 소개"></a>12.1 스프링 데이터 JPA 소개</h4><p>스프링 데이터 JPA 는 스프링 프레임워크에서 JPA 를 편리하게 사용할수 있도록 지원하는 프로젝트입니다. 이 프로젝트는 데이터 접근 계층을 개발할 때 지루하게 반복되는 CRUD 문제를 세련된 방법으로 해결합니다. 데이터 접근 계층을 개발할 때 구현 클래스 없이 인터페이스만 작성해도 개발을 완료할 수있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MemberRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Member</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function">Member <span class="title">findByUsername</span><span class="params">(String username)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ItemRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Item</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>회원과 상품 리포지토리 구현체는 애플리케이션 실행 시점에 스프링 데이터 JPA가 생성해서 주입해줍니다. 즉, 개발자가 직접 구현체를 개발하지 않아도 됩니다.</p>
<p>일반적인 CRUD 메소드는 JpaRepository 인터페이스가 공통으로 제공하지만, MemberRepository.findByUsername(…) 처럼 직접 작성한 공통으로 처리할 수 없는 메소드는 스프링 데이터 JPA 가 메소드 이름을 분석해서 JPQL 을 실행합니다.</p>
<h5 id="12-1-1-스프링-데이터-프로젝트"><a href="#12-1-1-스프링-데이터-프로젝트" class="headerlink" title="12.1.1 스프링 데이터 프로젝트"></a>12.1.1 스프링 데이터 프로젝트</h5><p><img src="/image/spring-data-jpa.png" alt></p>
<p>스프링 데이터 JPA 프로젝트는 JPA에 특화된 기능을 제공합니다. 스프링 프레임워크 + JPA 를 사용한다면, 스프링 데이터 JPA 를 추천합니다.</p>
<h4 id="12-2-스프링-데이터-JPA-설정"><a href="#12-2-스프링-데이터-JPA-설정" class="headerlink" title="12.2 스프링 데이터 JPA 설정"></a>12.2 스프링 데이터 JPA 설정</h4><ul>
<li>필요 라이브러리</li>
<li>환경 설정</li>
</ul>
<h4 id="12-3-공통-인터페이스-기능"><a href="#12-3-공통-인터페이스-기능" class="headerlink" title="12.3 공통 인터페이스 기능"></a>12.3 공통 인터페이스 기능</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JpaRepository 공통 기능 인터페이스</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">JpaRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span> <span class="keyword">extends</span> <span class="title">Serializable</span>&gt; <span class="keyword">extends</span> <span class="title">PagingAndSortingRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JpaRepository 를 사용하는 인터페이스</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MemberRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Member</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JpaRepsitory 인터페이스의 계층 구조는 다음과 같습니다.</p>
<p><img src="/image/spring-data-jpa-inheritance.png" alt></p>
<h4 id="12-4-쿼레-메소드-기능"><a href="#12-4-쿼레-메소드-기능" class="headerlink" title="12.4 쿼레 메소드 기능"></a>12.4 쿼레 메소드 기능</h4><p>스프링 데이터 JPA 가 제공하는 쿼리 메소드 기능은 크게 3가지입니다.</p>
<ul>
<li>메소드 이름으로 쿼리 생성</li>
<li>메소드 이름으로 JPA NamedQuery 호출</li>
<li>@Query 어노테이션을 사용해서 리포지토리 인터페이스에 쿼리 직접 정의</li>
</ul>
<h5 id="12-4-1-메소드-이름으로-쿼리-생성"><a href="#12-4-1-메소드-이름으로-쿼리-생성" class="headerlink" title="12.4.1 메소드 이름으로 쿼리 생성"></a>12.4.1 메소드 이름으로 쿼리 생성</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MemberRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">Member</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function">List&lt;Member&gt; <span class="title">findByEmailAndName</span> <span class="params">(String email, String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>findByEmailAndName(…) 를 실행하면 스프링 데이터 JPA 는 메소드 이름을 분석해서 다음 JPQL을 생성하고 실행합니다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> m <span class="keyword">from</span> <span class="keyword">Member</span> m <span class="keyword">where</span> m.email = ?<span class="number">1</span> <span class="keyword">and</span> m.name =?<span class="number">2</span></span><br></pre></td></tr></table></figure>

<h5 id="12-4-2-JPA-NamedQuery"><a href="#12-4-2-JPA-NamedQuery" class="headerlink" title="12.4.2 JPA NamedQuery"></a>12.4.2 JPA NamedQuery</h5><p>스프링 데이터 JPA 는 메소드 이름으로 JPA Named 쿼리를 호출하는 기능을 제공합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@NamedQuery</span>&#123;</span><br><span class="line">  name = <span class="string">"Member.findByUsername"</span>,</span><br><span class="line">  query = <span class="string">"select m from Member m where m.username = :username"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이렇게 정의한 Named 쿼리를 다음과 같이 호출합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JPA를 직접 사용해서 Named Query 호출</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemberRepository</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Member&gt; <span class="title">findByUserName</span><span class="params">(String username)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    List&lt;Member&gt; resultList =</span><br><span class="line">      	em.createNaemdQuery(<span class="string">"Member.findByUsername"</span>, Member.class)</span><br><span class="line">      	  .setParameter(<span class="string">"username"</span>, <span class="string">"회원1"</span>)</span><br><span class="line">          .getResultList();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 스프링 데이터 JPA 로 호출</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MemberRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span> &lt;<span class="title">Member</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">  List &lt;Member&gt; findByUserName(<span class="meta">@Param</span>(<span class="string">"username"</span>) String username);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>스프링 데이터 JPA 로 호출하는 경우, “도메인 클래스.메소드이름” 으로 Named Query 를 찾아서 실행합니다. 위 예제는, Member.findByUsername 이라는 Named Query 를 실행합니다. 만약, Named Query 가 없으면 메소드 이름으로 쿼리 생성 전략을 사용합니다.</p>
<h5 id="12-4-3-Query-리포지토리-메소드에-쿼리-정의"><a href="#12-4-3-Query-리포지토리-메소드에-쿼리-정의" class="headerlink" title="12.4.3 @Query, 리포지토리 메소드에 쿼리 정의"></a>12.4.3 @Query, 리포지토리 메소드에 쿼리 정의</h5><p>실행할 메소드에 직접 정적 쿼리를 작성하므로, 이름 없는 Named Query 라고 할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MemberRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Member</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@Query</span>(<span class="string">"select m from Member m where m.username = ?1"</span>)</span><br><span class="line">  <span class="function">Member <span class="title">findByUserName</span><span class="params">(String username)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="12-4-4-파라미터-바인딩"><a href="#12-4-4-파라미터-바인딩" class="headerlink" title="12.4.4 파라미터 바인딩"></a>12.4.4 파라미터 바인딩</h5><p>스프링 데이터 JPA 는 위치 기반 파라미터 바인딩과 이름 기반 파라미터 바인딩을 모두 지원합니다. 다음은 이름 기반 파라미터 바인딩 예제입니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MemberRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Member</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@Query</span>(<span class="string">"select m from Member m where m.username = :name"</span>)</span><br><span class="line">  <span class="function">Member <span class="title">findByUserName</span><span class="params">(@Param(<span class="string">"name"</span>)</span> String username)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="12-4-5-벌크성-수정-쿼리"><a href="#12-4-5-벌크성-수정-쿼리" class="headerlink" title="12.4.5 벌크성 수정 쿼리"></a>12.4.5 벌크성 수정 쿼리</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JPA 를 사용한 벌크성 수정 쿼리</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bulkPriceUp</span><span class="params">(String stockAmout)</span></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  String qlString = <span class="string">"update Product p set p.price = p.price * 1.1 where </span></span><br><span class="line"><span class="string">    p.stockAmout &lt; :stockAmout"</span>;</span><br><span class="line">      </span><br><span class="line">  <span class="keyword">int</span> resultCount = em.createQuery(qlString)</span><br><span class="line">      						    .setParameter(<span class="string">"stockAmout"</span>, stockAmout)</span><br><span class="line">                      .executeUpdate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 스프링 데이터 JPA 를 사용한 벌크성 수정 쿼리</span></span><br><span class="line"><span class="meta">@Modifying</span></span><br><span class="line"><span class="meta">@Query</span>(<span class="string">"update Product p set p.price = p.price * 1.1 where </span></span><br><span class="line"><span class="string">    p.stockAmout &lt; :stockAmout"</span>)</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bulkPriceUp</span><span class="params">(@Param(<span class="string">"stockAmout"</span>)</span> String stockAmout)</span>;</span><br></pre></td></tr></table></figure>

<h5 id="12-4-6-반환-타입"><a href="#12-4-6-반환-타입" class="headerlink" title="12.4.6 반환 타입"></a>12.4.6 반환 타입</h5><p>결과가 한건 이상이면 컬렉션 인터페이스, 단건이면 반환 타입을 지정합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;Member&gt; <span class="title">findByName</span> <span class="params">(String name)</span></span>; <span class="comment">//컬렉션</span></span><br><span class="line"><span class="function">Member <span class="title">findByEmail</span> <span class="params">(String email)</span></span>; <span class="comment">//단건</span></span><br></pre></td></tr></table></figure>

<h5 id="12-4-7-페이징과-정렬"><a href="#12-4-7-페이징과-정렬" class="headerlink" title="12.4.7 페이징과 정렬"></a>12.4.7 페이징과 정렬</h5><p>쿼리 메소드에 페이징과 정렬 기능을 사용할 수 있도록 2가지 파라미터를 제공합니다.</p>
<ul>
<li>org.springframework.data.domain.sort</li>
<li>org.springframework.data.domain.Pageable<ul>
<li>파라미터에 Pageable 을 사용하면, 반환타입으로 List 나 org.springframework.data.domain.Page 사용 가능</li>
<li>반환 타입으로 Page 사용하면 검색된 전체 데이터 건수 조회하는 count 쿼리 추가로 호출</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 페이징과 정렬 사용 예제</span></span><br><span class="line"><span class="function">Page&lt;Member&gt; <span class="title">findByName</span><span class="params">(String name, Pageable pageable)</span></span>;</span><br><span class="line"><span class="function">List&lt;Member&gt; <span class="title">findByName</span><span class="params">(String name, Pageable pageable)</span></span>;</span><br><span class="line"><span class="function">List&lt;Member&gt; <span class="title">findByName</span><span class="params">(String name, Sort sort)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Page 사용 예제 정의 코드</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MemberRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">Member</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="function">Page&lt;Member&gt; <span class="title">findByNameStartingWith</span><span class="params">(String name, Pageable pageable)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Page 사용 예제 실행 코드</span></span><br><span class="line">PageRequest pageRequest = <span class="keyword">new</span> PageRequest(<span class="number">0</span>, <span class="number">10</span>, <span class="keyword">new</span> Sort(Direction.DESC, <span class="string">"name"</span>));</span><br><span class="line"></span><br><span class="line">Page&lt;Member&gt; result = memberRepository.findByNameStartingWith(<span class="string">"김"</span>, pageRequest);</span><br><span class="line"></span><br><span class="line">List&lt;Member&gt; members = result.getContent();</span><br><span class="line"><span class="keyword">int</span> totalPage = result.getTotalPages();</span><br><span class="line"><span class="keyword">boolean</span> hasNextPage = result.hasNextPage();</span><br></pre></td></tr></table></figure>

<p>Pageable 은 인터페이스입니다. 실제 사용할 때는 이를 구현한 PageRequest 객체를 사용합니다.</p>
<h5 id="12-4-8-힌트"><a href="#12-4-8-힌트" class="headerlink" title="12.4.8 힌트"></a>12.4.8 힌트</h5><p>SQL 힌트가 아니라 JPA 구현체에게 제공하는 힌트입니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@QueryHints</span>(value = &#123;<span class="meta">@QueryHint</span>(name = <span class="string">"org.hibernate.readOnly"</span>,</span><br><span class="line">                                value = <span class="string">"true"</span>)&#125;, forCounting = <span class="keyword">true</span>)</span><br><span class="line"><span class="function">Page&lt;Member&gt; <span class="title">findByName</span> <span class="params">(String name, Pagable pageable)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="12-4-9-Lock"><a href="#12-4-9-Lock" class="headerlink" title="12.4.9 Lock"></a>12.4.9 Lock</h5><h4 id="12-5-명세"><a href="#12-5-명세" class="headerlink" title="12.5 명세"></a>12.5 명세</h4><p>도메인 주도 설계에서 명세라는 개념을 소개하는데, 스프링 데이터 JPA 는 JPA Criteria 로 이 개념을 사용할 수 있습니다.</p>
<p>명세를 이해하기 위한 핵심 단어는 술어입니다. 이것은 단순히 참이나 거짓으로 평가됩니다. 스프링 데이터 JPA 는 이 술어를 org.springframework.data.jpa.domain.Specification 클래스로 정의했습니다. Specification 은 컴포지트 패턴으로 구성되어 있어서 여러 Specification 으로 조합할 수 있습니다.즉, 다양한 검색 조건을 조립해서 새로운 검색 조건을 쉽게 만들 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JpaSpecificationExecutor 상속</span></span><br><span class="line">pubilc <span class="class"><span class="keyword">interface</span> <span class="title">OrderRepsitroy</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Order</span>, <span class="title">Long</span>&gt;, <span class="title">JpaSpecificationExecutor</span>&lt;<span class="title">Order</span>&gt;</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JpaSpecificationExecutor 인터페이스</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">JpaSpecificationExecutor</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function">T <span class="title">findOne</span> <span class="params">(Specification&lt;T&gt; spec)</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 명세 사용 코드</span></span><br><span class="line"><span class="comment">// Specification 은 명세들을 조립할 수 있도록 도와주는 클래스인데, </span></span><br><span class="line"><span class="comment">// where(), and(), or(), not() 메소드를 제공</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Order&gt; <span class="title">findOrders</span> <span class="params">(String name)</span> </span>&#123;</span><br><span class="line">  List&lt;Order&gt; result = orderRepository.findAll(</span><br><span class="line">  				where(memberName(name)).and(isOrderStatus())</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="12-6-사용자-정의-리포지토리-구현"><a href="#12-6-사용자-정의-리포지토리-구현" class="headerlink" title="12.6 사용자 정의 리포지토리 구현"></a>12.6 사용자 정의 리포지토리 구현</h4><p>스프링 데이터 JPA 로 리포지토리를 개발하면 인터페이스만 정의하고 구현체는 만들지 않습니다. 하지만, 다양한 이유로 메소드를 직접 구현해야 할 때도 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 사용자 정의 인터페이스</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MemberRepositoryCustom</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Member&gt; <span class="title">findMemberCustom</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 사용자 정의 구현 클래스</span></span><br><span class="line"><span class="comment">// 클래스 이름 짓는 규칙 : 리포지토리 인터페이스 이름 + Impl</span></span><br><span class="line"><span class="comment">// 이렇게 하면 스프링 데이터 JPA 가 사용자 정의 구현 클래스로 인식</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemberRepositoryImpl</span> <span class="keyword">implements</span> <span class="title">MemberRepositoryCustom</span></span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Member&gt; <span class="title">findMemberCustom</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 사용자 정의 구현</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 사용자 정의 인터페이스 상속</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MemberRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Member</span>, <span class="title">Long</span>&gt;, <span class="title">MemberRepositoryCustom</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="12-7-Web-확장"><a href="#12-7-Web-확장" class="headerlink" title="12.7 Web 확장"></a>12.7 Web 확장</h4><p>스프링 데이터 프로젝트는 스프링 MVC 에서 사용할 수 있는 기능을 제공합니다.</p>
<ul>
<li>식별자로 도메인 클래스를 바로 바인딩 해주는 도메인 클래스 컨버터 기능</li>
<li>페이징과 정렬 기능</li>
</ul>
<h5 id="12-7-1-설정"><a href="#12-7-1-설정" class="headerlink" title="12.7.1 설정"></a>12.7.1 설정</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="meta">@EnableSpringDataWebSupport</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebAppConfig</span></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>설정을 완료하면, 도메인 클래스 컨버터와 페이징과 정렬을 위한 HandlerMethodArgumentResolver 가 스프링 빈으로 등록됩니다.</p>
<h5 id="12-7-2-도메인-클래스-컨버터-기능"><a href="#12-7-2-도메인-클래스-컨버터-기능" class="headerlink" title="12.7.2 도메인 클래스 컨버터 기능"></a>12.7.2 도메인 클래스 컨버터 기능</h5><p>도메인 클래스 컨버터는 HTTP 파라미터로 넘어온 엔티티의 아이디로 엔티티 객체를 찾아서 바인딩해줍니다.</p>
<h5 id="12-7-3-페이징과-정렬-기능"><a href="#12-7-3-페이징과-정렬-기능" class="headerlink" title="12.7.3 페이징과 정렬 기능"></a>12.7.3 페이징과 정렬 기능</h5><p>스프링 데이터가 제공하는 페이징과 정렬 기능을 스프링 MVC 에서 편리하게 사용할 수 있도록 HandlerMethodArgumentResolver 를 제공합니다. </p>
<h4 id="12-8-스프링-데이터-JPA-가-사용하는-구현체"><a href="#12-8-스프링-데이터-JPA-가-사용하는-구현체" class="headerlink" title="12.8 스프링 데이터 JPA 가 사용하는 구현체"></a>12.8 스프링 데이터 JPA 가 사용하는 구현체</h4><p>스프링 데이터 JPA 가 제공하는 공통 인터페이스는 org.springframework.data.jpa.repository.support.SimpleJpaRepository 클래스가 구현합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="meta">@Transactional</span>(readOnly = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleJpaRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span> <span class="keyword">extends</span> <span class="title">Serializable</span>&gt; <span class="keyword">implements</span> <span class="title">JpaRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt;, <span class="title">JpaSpecificationExecutor</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
                    
                        

                    
                    
                        <p>
                            <a href="/2019/04/21/spring-data-jpa/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2019/04/17/jpql/">
                            [자바 ORM 표준 JPA 프로그래밍] 10장_객체지향 쿼리 언어
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-04-17T00:00:00+09:00">
	
		    Apr 17, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/jpa/">JPA</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>10 장에서 다루는 내용입니다.</p>
<ul>
<li>객체지향 쿼리 소개</li>
<li>Criteria</li>
<li>QueryDSL</li>
<li>Native SQL</li>
<li>객체지향 쿼리 심화</li>
</ul>
<h4 id="10-1-객체지향-쿼리-소개"><a href="#10-1-객체지향-쿼리-소개" class="headerlink" title="10.1 객체지향 쿼리 소개"></a>10.1 객체지향 쿼리 소개</h4><p>EntityMangager.find() 메서드를 사용하면 식별자로 엔티티 하나를 조회하고, 조회한 엔티티에 객체 그래프 탐색을 사용해서 연관된 엔티티를 찾을 수 있습니다.</p>
<ul>
<li>식별자로 조회 : EntityMangager.find()</li>
<li>객체 그래프 탐색 : a.getB().getC()</li>
</ul>
<p>만약 30살 이상인 회원을 모두 검색하고 싶으면 ? 모든 엔티티를 메모리에 올려두고 검색하는 것은 현실적이지 않습니다. 결국 데이터는 DB에 있으므로 SQL 로 최대한 걸러야합니다. 하지만 ORM 을 사용하면 DB table 이 아닌, 엔티티 객체를 대상으로 검색하므로 검색도 테이블이 아닌 엔티티 객체를 대상으로 하는 방법이 필요합니다. 그래서 만들어진 것이 JPQL 입니다. </p>
<p>다음은, 검색 방법으로 JPA 가 공식 지원하는 기능입니다.</p>
<ul>
<li>JPQL (Java Persistence Query Language)</li>
<li>Criteria Query</li>
<li>Native SQL</li>
</ul>
<p>다음은, JPA 가 공식 지원하는 기능은 아니지만 알아둘 가치가 있습니다.</p>
<ul>
<li>QueryDSL</li>
<li>JDBC 직접 사용 / MyBatis 같은 SQL Mapper 프레임워크 사용</li>
</ul>
<h5 id="10-1-1-JPQL-소개"><a href="#10-1-1-JPQL-소개" class="headerlink" title="10.1.1 JPQL 소개"></a>10.1.1 JPQL 소개</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String jpql = <span class="string">"select m from Member as m where m.username = 'kim'"</span>;</span><br><span class="line">List&lt;Member&gt; resultList = em.createQuery(jpql, Member.class).getResultList();</span><br></pre></td></tr></table></figure>

<h5 id="10-1-2-Criteria-Query-소개"><a href="#10-1-2-Criteria-Query-소개" class="headerlink" title="10.1.2 Criteria Query 소개"></a>10.1.2 Criteria Query 소개</h5><p>JPQL을 생성하는 빌더 클래스입니다. 문자가 아닌, query.select(m).where(…) 처럼 프로그래밍 코드로 JPQL을 작성할 수 있습니다.</p>
<p>장점은 다음과 같습니다.</p>
<ul>
<li>컴파일 시점에 오류 발견</li>
<li>IDE를 사용하면 코드 자동 완성 지원</li>
<li>동적 쿼리 작성 편이</li>
</ul>
<p>하지만, 복잡하고 장황해서 Criteria 로 작성한 코드가 한눈에 들어오지 않는 단점이 있습니다.</p>
<h5 id="10-1-3-QueryDSL-소개"><a href="#10-1-3-QueryDSL-소개" class="headerlink" title="10.1.3 QueryDSL 소개"></a>10.1.3 QueryDSL 소개</h5><p>Criteria 처럼 JPQL 빌더 역할을 합니다. Criteria 에 비해, 작성한 코드가 한눈에 들어오고 단순하고 사용하기 쉽습니다.</p>
<p>JPA 표준이 아니고 오픈 소스 프로젝트입니다. JPA 뿐만 아니라, JDO, MongoDB, Java Collection, Lucene, Hibernate Search 도 거의 같은 문법으로 지원합니다.</p>
<h5 id="10-1-4-Native-SQL"><a href="#10-1-4-Native-SQL" class="headerlink" title="10.1.4 Native SQL"></a>10.1.4 Native SQL</h5><p>SQL 을 직접 사용하는 기능입니다. 그래서, 데이터베이스를 변경하면 네이티브 SQL 로 수정해야합니다.</p>
<h5 id="10-1-5-JDBC-직접-사용-MyBatis-같은-SQL-Mapper-프레임워크-사용"><a href="#10-1-5-JDBC-직접-사용-MyBatis-같은-SQL-Mapper-프레임워크-사용" class="headerlink" title="10.1.5 JDBC 직접 사용 / MyBatis 같은 SQL Mapper 프레임워크 사용"></a>10.1.5 JDBC 직접 사용 / MyBatis 같은 SQL Mapper 프레임워크 사용</h5><p>JDBC connection 에 직접 접근하고 싶으면, JPA는 JDBC connection 을 획득하는 API 를 제공하지 않으므로, JPA 구현체가 제공하는 방법을 사용해야 합니다.</p>
<h4 id="10-2-JPQL"><a href="#10-2-JPQL" class="headerlink" title="10.2 JPQL"></a>10.2 JPQL</h4><p>1절에서 엔티티를 쿼리하는 다양한 방법을 소개했지만, 어떤 방법을 사용하든 JPQL 에서 모든 것이 시작합니다. 다음은 JPQL의 특징입니다.</p>
<ul>
<li>객체지향 쿼리 언어입니다. 엔티티 객체를 대상으로 쿼리합니다.</li>
<li>특정 데이터베이스에 SQL 에 의존하지 않습니다.</li>
<li>JPQL 도 결국 SQL 로 변환됩니다.</li>
</ul>
<h5 id="10-2-1-기본-문법과-쿼리-API"><a href="#10-2-1-기본-문법과-쿼리-API" class="headerlink" title="10.2.1 기본 문법과 쿼리 API"></a>10.2.1 기본 문법과 쿼리 API</h5><p>EntityManger.persist() 메소드를 사용하면 되기 때문에 INSERT 문은 없습니다.</p>
<h6 id="SELECT-문"><a href="#SELECT-문" class="headerlink" title="SELECT 문"></a>SELECT 문</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT m FROM Member AS m where m.username = <span class="string">'Hello'</span></span><br></pre></td></tr></table></figure>

<h6 id="TypeQuery-Query"><a href="#TypeQuery-Query" class="headerlink" title="TypeQuery, Query"></a>TypeQuery, Query</h6><p>반환할 타입을 명확히 지정할 수 있으면 <strong>TypeQuery</strong>, 반환할 타입을 명확히 지정할 수 없으면 <strong>Query</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TypeQuery&lt;Member&gt; query = em.createQuery(<span class="string">"SELECT m FROM Member AS m"</span>, Member.class);</span><br><span class="line"></span><br><span class="line">Query query = em.createQuery(<span class="string">"SELECT m.username¸ m.age FROM Member AS m"</span>);</span><br></pre></td></tr></table></figure>

<h6 id="결과-조회"><a href="#결과-조회" class="headerlink" title="결과 조회"></a>결과 조회</h6><p>다음 메소드를 호출하면 실제 쿼리를 실행해서 데이터베이스를 조회합니다.</p>
<ul>
<li>query.getResultList()</li>
<li>query.getSingleResult() </li>
</ul>
<h5 id="10-2-2-파라미터-바인딩"><a href="#10-2-2-파라미터-바인딩" class="headerlink" title="10.2.2 파라미터 바인딩"></a>10.2.2 파라미터 바인딩</h5><h6 id="이름-기준-파리미터"><a href="#이름-기준-파리미터" class="headerlink" title="이름 기준 파리미터"></a>이름 기준 파리미터</h6><p>위치 기준 파라미터 바인딩 방식보다 명확합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String usernameparam = <span class="string">"user1"</span>;</span><br><span class="line"></span><br><span class="line">TypeQuery&lt;Member&gt; query = em.createQuery(<span class="string">"SELECT m FROM Member m where m.username = :username"</span>, Member.class);</span><br><span class="line"></span><br><span class="line">query.setParameter(<span class="string">"username"</span>, usernameparam);</span><br></pre></td></tr></table></figure>

<h6 id="위치-기준-파라미터"><a href="#위치-기준-파라미터" class="headerlink" title="위치 기준 파라미터"></a>위치 기준 파라미터</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String usernameparam = <span class="string">"user1"</span>;</span><br><span class="line"></span><br><span class="line">List&lt;Member&gt; members = em</span><br><span class="line">.createQuery(<span class="string">"SELECT m FROM Member m where m.username = ?1"</span>, Member.class)</span><br><span class="line">.setParameter(<span class="number">1</span>, usernameParam)</span><br><span class="line">.getResultList();</span><br></pre></td></tr></table></figure>

<h5 id="10-2-3-프로젝션"><a href="#10-2-3-프로젝션" class="headerlink" title="10.2.3 프로젝션"></a>10.2.3 프로젝션</h5><p>SELECT 절에 조회할 대상을 지정하는 것입니다. </p>
<ul>
<li>엔티티 프로젝션<ul>
<li>조회한 엔티티는 영속성 컨텍스트에서 관리됩니다.</li>
</ul>
</li>
<li>임베디드 타입 프로젝션<ul>
<li>임베디드 타입은 값 타입입니다. 따라서, 조회한 임베디드 타입은 영속성 컨텍스트에서 관리되지 않습니다.</li>
</ul>
</li>
<li>스칼라 타입 프로젝션<ul>
<li>기본 데이터타입입니다.</li>
<li>SELECT username…. / SELECT AVG(o.orderAmout)…</li>
</ul>
</li>
<li>여러 값 조회<ul>
<li>꼭 필요한 데이터들만 조회하는 경우입니다.</li>
</ul>
</li>
<li>New 명령어<ul>
<li>반환 받을 클래스를 지정하여 이 클래스의 생성장에 JPQL 조회 결과를 넘길 수 있습니다. </li>
<li>TypeQuery 를 사용할 수 있어서 지루한 객체 변환 작업을 줄일 수 있습니다.</li>
</ul>
</li>
</ul>
<h5 id="10-2-4-페이징-API"><a href="#10-2-4-페이징-API" class="headerlink" title="10.2.4 페이징 API"></a>10.2.4 페이징 API</h5><p>페지징을 다음 두 API 로 추상화했습니다.</p>
<ul>
<li>setFirstResult(int startPosition)<ul>
<li>조회 시작 위치</li>
</ul>
</li>
<li>setMaxResults(int maxResult)<ul>
<li>조회할 데이터 수</li>
</ul>
</li>
</ul>
<h5 id="10-2-5-집합과-정렬"><a href="#10-2-5-집합과-정렬" class="headerlink" title="10.2.5 집합과 정렬"></a>10.2.5 집합과 정렬</h5><p>집합은 통계 정보를 구할 때 사용합니다.</p>
<h5 id="10-2-6-JPQL-조인"><a href="#10-2-6-JPQL-조인" class="headerlink" title="10.2.6 JPQL 조인"></a>10.2.6 JPQL 조인</h5><p>SQL 조인과 기능은 같고 문법만 약간 다릅니다.</p>
<h6 id="내부-조인"><a href="#내부-조인" class="headerlink" title="내부 조인"></a>내부 조인</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> m <span class="keyword">FROM</span> <span class="keyword">Member</span> m <span class="keyword">INNER</span> <span class="keyword">JOIN</span> m.team t <span class="keyword">WHERE</span> t.name = :teamName</span><br></pre></td></tr></table></figure>

<h6 id="외부-조인"><a href="#외부-조인" class="headerlink" title="외부 조인"></a>외부 조인</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> m <span class="keyword">FROM</span> <span class="keyword">Member</span> m LEF [<span class="keyword">OUTER</span>] <span class="keyword">JOIN</span> m.team t</span><br></pre></td></tr></table></figure>

<h6 id="컬렉션-조인"><a href="#컬렉션-조인" class="headerlink" title="컬렉션 조인"></a>컬렉션 조인</h6><p>일대다 관계나 다대다 관계처럼 컬렉션을 사용하는 곳에 조인하는 것입니다.</p>
<h6 id="세타-조인"><a href="#세타-조인" class="headerlink" title="세타 조인"></a>세타 조인</h6><p>전혀 관계 없는 엔티티도 조회 할 수 있습니다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(m) </span><br><span class="line"><span class="keyword">from</span> <span class="keyword">Member</span> m, Team t</span><br><span class="line"><span class="keyword">where</span> m.username = t.name</span><br></pre></td></tr></table></figure>

<h6 id="JOIN-ON-절-JPA-2-1"><a href="#JOIN-ON-절-JPA-2-1" class="headerlink" title="JOIN ON  절 (JPA 2.1)"></a>JOIN ON  절 (JPA 2.1)</h6><p>조인 대상을 필터링하고 조인할 수  있습니다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> m, t </span><br><span class="line"><span class="keyword">from</span> <span class="keyword">Member</span> m</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> m.team t <span class="keyword">on</span> t.name = <span class="string">'A'</span></span><br></pre></td></tr></table></figure>

<h5 id="10-2-7-페치-조인"><a href="#10-2-7-페치-조인" class="headerlink" title="10.2.7 페치 조인"></a>10.2.7 페치 조인</h5><p>연관된 엔티티나 컬렉션을 한 번에 같이 조회합니다.</p>
<h6 id="엔티티-페치-조인"><a href="#엔티티-페치-조인" class="headerlink" title="엔티티 페치 조인"></a>엔티티 페치 조인</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> m</span><br><span class="line"><span class="keyword">from</span> <span class="keyword">Member</span> m <span class="keyword">join</span> <span class="keyword">fetch</span> m.team</span><br></pre></td></tr></table></figure>

<h6 id="컬렉션-페치-조인"><a href="#컬렉션-페치-조인" class="headerlink" title="컬렉션 페치 조인"></a>컬렉션 페치 조인</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t</span><br><span class="line"><span class="keyword">from</span> Team t <span class="keyword">join</span> <span class="keyword">fetch</span> t.members</span><br><span class="line"><span class="keyword">where</span> t.name = <span class="string">'팀A'</span></span><br></pre></td></tr></table></figure>

<h6 id="페치-조인과-DISTINCT"><a href="#페치-조인과-DISTINCT" class="headerlink" title="페치 조인과 DISTINCT"></a>페치 조인과 DISTINCT</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> distint t</span><br><span class="line"><span class="keyword">from</span> Team t <span class="keyword">join</span> <span class="keyword">fetch</span> t.members</span><br><span class="line"><span class="keyword">where</span> t.name = <span class="string">'팀A'</span></span><br></pre></td></tr></table></figure>

<h6 id="페치-조인과-일반-조인의-차이"><a href="#페치-조인과-일반-조인의-차이" class="headerlink" title="페치 조인과 일반 조인의 차이"></a>페치 조인과 일반 조인의 차이</h6><p>다음은, 팀만 조회하고 조인했던 회원은 전혀 조회하지 않습니다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t</span><br><span class="line"><span class="keyword">from</span> Team t <span class="keyword">join</span> t.members m</span><br><span class="line"><span class="keyword">where</span> t.name = <span class="string">'팀A'</span></span><br></pre></td></tr></table></figure>

<p>JPQL은 결과를 반환할 때 연관관계까지 고려하지 않습니다. 단지 SELECT 절에 지정한 엔티티만 조회합니다.</p>
<h6 id="페치-조인의-특징과-한계"><a href="#페치-조인의-특징과-한계" class="headerlink" title="페치 조인의 특징과 한계"></a>페치 조인의 특징과 한계</h6><ul>
<li>페치 조인 대상에는 별칠을 줄 수 없습니다.</li>
<li>둘 이상의 컬렉션을 페치할 수 없습니다.</li>
<li>컬렉션을 페치 조인하면 페이징 API를 사용할 수 없습니다.</li>
</ul>
<h5 id="10-2-8-경로-표현식"><a href="#10-2-8-경로-표현식" class="headerlink" title="10.2.8 경로 표현식"></a>10.2.8 경로 표현식</h5><p>. 을 찍어서 객체 그래프를 탐색하는 것입니다.</p>
<ul>
<li>상태 필드<ul>
<li>단순히 값을 저장하기 위한 필드</li>
</ul>
</li>
<li>연관 필드<ul>
<li>객체 사이의 연관 관계를 위한 필드, 임베디드 타입 포함</li>
</ul>
</li>
</ul>
<h6 id="경로-표현식과-특징"><a href="#경로-표현식과-특징" class="headerlink" title="경로 표현식과 특징"></a>경로 표현식과 특징</h6><ul>
<li>상태 필드 경로<ul>
<li>경로 탐색의 끝</li>
</ul>
</li>
<li>단일 값 연관 경로<ul>
<li>묵시적으로 내부조인</li>
<li>계속 탐색 가능</li>
</ul>
</li>
<li>컬렉션 값 연관 경로<ul>
<li>묵시적으로 내부조인</li>
<li>더는 탐색 불가능 (단, FROM 절에서 조인 통해 별칭 얻으면 별칭으로 탐색 가능)</li>
</ul>
</li>
</ul>
<h5 id="10-2-9-서브-쿼리"><a href="#10-2-9-서브-쿼리" class="headerlink" title="10.2.9 서브 쿼리"></a>10.2.9 서브 쿼리</h5><p>WHERE, HAVING 절에서만 사용 가능합니다.</p>
<h6 id="서브-쿼리-함수"><a href="#서브-쿼리-함수" class="headerlink" title="서브 쿼리 함수"></a>서브 쿼리 함수</h6><ul>
<li>EXISTS</li>
<li>ALL|ANY|SOME</li>
<li>IN</li>
</ul>
<h5 id="10-2-10-조건식"><a href="#10-2-10-조건식" class="headerlink" title="10.2.10 조건식"></a>10.2.10 조건식</h5><h5 id="10-2-11-다형성-쿼리"><a href="#10-2-11-다형성-쿼리" class="headerlink" title="10.2.11 다형성 쿼리"></a>10.2.11 다형성 쿼리</h5><p>부모 엔티티를 조회하면 그 자식 엔티티도 함께 조회합니다.</p>
<h5 id="10-2-12-사용자-정의-함수-호출-JPA-2-1"><a href="#10-2-12-사용자-정의-함수-호출-JPA-2-1" class="headerlink" title="10.2.12 사용자 정의 함수 호출 (JPA 2.1)"></a>10.2.12 사용자 정의 함수 호출 (JPA 2.1)</h5><h5 id="10-2-13-기타-정리"><a href="#10-2-13-기타-정리" class="headerlink" title="10.2.13 기타 정리"></a>10.2.13 기타 정리</h5><h5 id="10-2-14-엔티티-직접-사용"><a href="#10-2-14-엔티티-직접-사용" class="headerlink" title="10.2.14 엔티티 직접 사용"></a>10.2.14 엔티티 직접 사용</h5><p>#####10.2.15 Named Query : 정적 쿼리</p>
<p>미리 정의한 쿼리에 이름을 부여해서 필요할 때마다 사용하는 정적인 쿼리입니다.</p>
<h4 id="10-3-Criteria"><a href="#10-3-Criteria" class="headerlink" title="10.3 Criteria"></a>10.3 Criteria</h4><p>Criteria Query 는 JPQL 을 자바 코드로 작성하도록 도와주는 빌더 클래스 API 입니다.</p>
<h4 id="10-4-QueryDSL"><a href="#10-4-QueryDSL" class="headerlink" title="10.4 QueryDSL"></a>10.4 QueryDSL</h4><p>쿼리를 문자가 아닌 코드로 작성해도 쉽고 간결하며 그 모양도 쿼리와 비슷하게 개발할 수 있는 프로젝트입니다. JPA Criteria 를 대체할 수 있습니다. </p>
<h5 id="10-4-1-설정"><a href="#10-4-1-설정" class="headerlink" title="10.4.1 설정"></a>10.4.1 설정</h5><h5 id="10-4-2-시작"><a href="#10-4-2-시작" class="headerlink" title="10.4.2 시작"></a>10.4.2 시작</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queryDSL</span><span class="params">()</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  EntityManager em = emf.createEntityManager();</span><br><span class="line">  </span><br><span class="line">  JPAQuery query = <span class="keyword">new</span> JPAQuery(em);</span><br><span class="line">  QMember qMember = <span class="keyword">new</span> QMember(<span class="string">"m"</span>); <span class="comment">//생성되는 JPQL의 별칭이 m</span></span><br><span class="line">  List&lt;Member&gt; members = </span><br><span class="line">    query.from(qMember)</span><br><span class="line">    		 .where(qMember.name.eq(<span class="string">"회원1"</span>))</span><br><span class="line">    		 .orderBy(qMember.name.desc())</span><br><span class="line">    	   .list(qMember);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="기본-Q-생성"><a href="#기본-Q-생성" class="headerlink" title="기본 Q 생성"></a>기본 Q 생성</h6><p>쿼리 타입(Q) 은 사용하기 편리하도록 기본 인스턴스를 보관하고 있습니다. 하지만, 같은 엔티티를 조인하거나 같은 엔티티를 서브쿼리에 사용하면 같은 별칭이 사용되므로, 별칭을 직접 지정해야합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QMember</span> <span class="keyword">extends</span> <span class="title">EntityPathBase</span>&lt;<span class="title">Member</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> QMember member = <span class="keyword">new</span> QMember(<span class="string">"member1"</span>);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>쿼리 타입은 다음과 같이 사용합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QMember qMember = <span class="keyword">new</span> QMember(<span class="string">"m"</span>); <span class="comment">//직접 지정</span></span><br><span class="line">QMember qMember = QMember.member; 	<span class="comment">//기본 인스턴스 사용</span></span><br></pre></td></tr></table></figure>

<h5 id="10-4-3-검색-조건-쿼리"><a href="#10-4-3-검색-조건-쿼리" class="headerlink" title="10.4.3 검색 조건 쿼리"></a>10.4.3 검색 조건 쿼리</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JPAQuery query = <span class="keyword">new</span> JPAQuery(em);</span><br><span class="line">QItem item = QItem.item;</span><br><span class="line">List&lt;Item&gt; list = query.from(item)</span><br><span class="line">  								     .where(item.name.eq(<span class="string">"goodProduct"</span>).and(item.price.gt(<span class="number">20000</span>)))</span><br><span class="line">  										 .list(item); <span class="comment">//조회할 프로젝션 지정</span></span><br></pre></td></tr></table></figure>

<p>#####10.4.4 결과 조회</p>
<p>쿼리 작성 후에, 결과 조회 메소드를 호출하면 실제 데이터베이스를 조회합니다. 대표적인 결과 조회 메소드는 다음과 같습니다.</p>
<ul>
<li>uniqueResult()<ul>
<li>조회 결과가 한건일 때 사용</li>
</ul>
</li>
<li>singleResult()<ul>
<li>uniqueResult() 와 결과가 같지만, 결과가 하나 이상이면 처음 데이터를 반환</li>
</ul>
</li>
<li>list()<ul>
<li>조회 결과가 하나 이상일 때 사용</li>
</ul>
</li>
</ul>
<p>#####10.4.5 페이징과 정렬</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QItem item = QItem.item;</span><br><span class="line"></span><br><span class="line">query.from(item)</span><br><span class="line">  	 .where(item.price.gt(<span class="number">20000</span>))</span><br><span class="line">     .orderBy(item.price.desc(), item.stockQuantity.asc())</span><br><span class="line">     .offset(<span class="number">10</span>).limit(<span class="number">20</span>)</span><br><span class="line">  	 .list(item)</span><br></pre></td></tr></table></figure>

<p>#####10.4.6 그룹</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">query.from(item)</span><br><span class="line">     .groupBy(item.price)</span><br><span class="line">     .having(item.price.gt(1000))</span><br><span class="line">     .list(item)</span><br></pre></td></tr></table></figure>

<p>#####10.4.7 조인</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">QOrder order = QOrder.order;</span><br><span class="line">QMember member = QMember.member;</span><br><span class="line">QOrderItem orderItem = QOrderItem.orderItem;</span><br><span class="line"></span><br><span class="line">query.from(order)</span><br><span class="line">  .join(order.member, member)</span><br><span class="line">  .leftJoin(order.orderItems, orderItem)</span><br><span class="line">  .list(order);</span><br></pre></td></tr></table></figure>

<p>#####10.4.8 서브 쿼리</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">QItem item = QItem.item;</span><br><span class="line">QItem itemSub = <span class="keyword">new</span> QItem(<span class="string">"itemSub"</span>);</span><br><span class="line"></span><br><span class="line">query.from(item)</span><br><span class="line">     .where(item.price.eq(</span><br><span class="line">     <span class="keyword">new</span> JPASubQuery().from(itemSub).unique(itemSub.price.max())</span><br><span class="line">     ))</span><br><span class="line">     .list(item)</span><br></pre></td></tr></table></figure>

<p>#####10.4.9 프로젝션과 결과 반환</p>
<h6 id="프로젝션-대상이-하나"><a href="#프로젝션-대상이-하나" class="headerlink" title="프로젝션 대상이 하나"></a>프로젝션 대상이 하나</h6><p>프로젝션 대상이 하나면 해당 타입으로 반환합니다.</p>
<h6 id="여러-칼럼-반환과-튜플"><a href="#여러-칼럼-반환과-튜플" class="headerlink" title="여러 칼럼 반환과 튜플"></a>여러 칼럼 반환과 튜플</h6><p>프로젝션 대상으로 여러 필드를 선택하면 QueryDSL 은 기본으로 com.mysema.query.Tuple 이라는 Map 과 비슷한 내부 타입을 사용합니다. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">QItem item = QItem.item;</span><br><span class="line"></span><br><span class="line">List&lt;Tuple&gt; result = query.from(item).list(item.name, item.price);</span><br><span class="line"><span class="comment">// List&lt;Tuple&gt; result = query.from(item).list(new QTuple(item.name, item.price)); 와 같음</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(Tuple tuple : result)&#123;</span><br><span class="line">  System.out.println(<span class="string">"name = "</span> + tuple.get(item.name));</span><br><span class="line">  System.out.println(<span class="string">"name = "</span> + tuple.get(item.price));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="빈-생성"><a href="#빈-생성" class="headerlink" title="빈 생성"></a>빈 생성</h6><p>쿼리 결과를 엔티니가 아닌 특정 객체로 받고 싶으면 빈 생성 기능을 사용합니다. 객체를 생성하는 방법은 다음과 같은 것들이 있습니다.</p>
<ul>
<li>프로퍼티 접근</li>
<li>필드 직접 접근</li>
<li>생성자 사용</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ItemDTO</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String username;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> price;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ItemDTO</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ItemDTO</span><span class="params">(String username, <span class="keyword">int</span> price)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.username = username;</span><br><span class="line">    <span class="keyword">this</span>.price = price;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//GETTER, SETTER ..</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 프로퍼티 접근</span></span><br><span class="line">QItem item = QItem.item;</span><br><span class="line">List&lt;ItemDTO&gt; result = query.from(item).list(</span><br><span class="line">Projections.bean(ItemDTO.class, item.name.as(<span class="string">"username"</span>), item.price));</span><br><span class="line"></span><br><span class="line"><span class="comment">//필드 직접 접근</span></span><br><span class="line">List&lt;ItemDTO&gt; result = query.from(item).list(</span><br><span class="line">Projections.fields(ItemDTO.class, item.name.as(<span class="string">"username"</span>), item.price));</span><br><span class="line"></span><br><span class="line"><span class="comment">//생성자 사용</span></span><br><span class="line">List&lt;ItemDTO&gt; result = query.from(item).list(</span><br><span class="line">Projections.constructor(ItemDTO.class, item.name, item.price));</span><br></pre></td></tr></table></figure>

<h6 id="DISTINCT"><a href="#DISTINCT" class="headerlink" title="DISTINCT"></a>DISTINCT</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">query.distinct().from(item)</span><br></pre></td></tr></table></figure>

<p>#####10.4.10 수정, 삭제, 배치 쿼리</p>
<h5 id="10-4-11-동적-쿼리"><a href="#10-4-11-동적-쿼리" class="headerlink" title="10.4.11 동적 쿼리"></a>10.4.11 동적 쿼리</h5><p>com.mysema.query.BooleanBuilder 를 사용하면 특정 조건에 따른 동적 쿼리를 편리하게 생성할 수 있습니다.</p>
<h5 id="10-4-12-메소드-위임"><a href="#10-4-12-메소드-위임" class="headerlink" title="10.4.12 메소드 위임"></a>10.4.12 메소드 위임</h5><p>쿼리 타입에 검색 조건을 직접 정의할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//검색 조건 정의</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ItemExpression</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@QueryDelegate</span>(Item.class) <span class="comment">// 이 기능을 적용할 엔티티 지정</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> statc BooleanExpression <span class="title">isExpensive</span><span class="params">(QItem item, Integer price)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> item.price.gt(price);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//쿼리 타입에 생성된 결과</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QItem</span> <span class="keyword">extends</span> <span class="title">EntityPathBase</span>&lt;<span class="title">Item</span>&gt; </span>&#123;</span><br><span class="line">  	...</span><br><span class="line">    <span class="keyword">public</span> com.mysema.qeury.types.expr.<span class="function">BooleanExpression <span class="title">isExpensive</span><span class="params">(Integer price)</span></span>&#123;</span><br><span class="line">    		<span class="keyword">return</span> ItemExpression.ixExpensieve(<span class="keyword">this</span>, price);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//메소드 위임 기능 사용</span></span><br><span class="line">query.from(item).where(item.isExpensive(<span class="number">30000</span>)).list(item);</span><br></pre></td></tr></table></figure>

<h4 id="10-5-Native-SQL"><a href="#10-5-Native-SQL" class="headerlink" title="10.5 Native SQL"></a>10.5 Native SQL</h4><p>다양한 이유로 JPQL 을 사용할 수 없을 때 JPA 는 SQL 을 직접 사용할 수 있는 기능을 제공하는데, 이것을 Native SQL 이라고 합니다. 네이티브 SQL 을 사용하면 엔티티를 조회할 수 있고 JPA 가 지원하는 영속성 컨텍스트의 기능을 그대로 사용할 수 있습니다. 반면에 JDBC API 를 직접 사용하면 단순히 데이터의 나열을 조회할 뿐입니다.</p>
<p>네이티브 SQL 도 JPQL 을 사용할 때와 마찬가지로 Query, TypeQuery(Named Native Query 의 경우) 를 반환합니다. 따라서 JPQL API 를 그대로 사용할 수 있습니다.</p>
<h5 id="10-5-1-Native-SQL-사용"><a href="#10-5-1-Native-SQL-사용" class="headerlink" title="10.5.1 Native SQL 사용"></a>10.5.1 Native SQL 사용</h5><p>네이티브 쿼리 API 는 세 가지 입니다.</p>
<ul>
<li>결과 타입 정의</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Query <span class="title">createNativeQuery</span><span class="params">(String sqlString, Class resultClass)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>결과 타임 정의 할 수 없을 때</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Query <span class="title">createNativeQuery</span><span class="params">(String sqlString)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>결과 매핑 사용</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Query <span class="title">createNativeQuery</span><span class="params">(String sqlString, String resultSetMapping)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="10-5-5-스토어드-프로시저"><a href="#10-5-5-스토어드-프로시저" class="headerlink" title="10.5.5 스토어드 프로시저"></a>10.5.5 스토어드 프로시저</h5><p>JPA 2.1 부터 지원합니다.</p>
<h4 id="10-6-객체-지향-쿼리-심화"><a href="#10-6-객체-지향-쿼리-심화" class="headerlink" title="10.6 객체 지향 쿼리 심화"></a>10.6 객체 지향 쿼리 심화</h4><h5 id="10-6-1-벌크-연산"><a href="#10-6-1-벌크-연산" class="headerlink" title="10.6.1 벌크 연산"></a>10.6.1 벌크 연산</h5><p>여러 건을 한번에 수정하거나 삭제할 때 벌크 연산을 사용합니다. 벌크 연산을 사용할 때는 벌크 연산이 영속성 컨텍스트를 무시하고 데이터이스에 직접 쿼리합니다.</p>
<h5 id="10-6-2-영속성-컨텍스트와-JPQL"><a href="#10-6-2-영속성-컨텍스트와-JPQL" class="headerlink" title="10.6.2 영속성 컨텍스트와 JPQL"></a>10.6.2 영속성 컨텍스트와 JPQL</h5><ul>
<li>JPQL은 항상 데이터베이스를 조회합니다.</li>
<li>JPQL로 조회한 엔티티는 영속 상태입니다.</li>
<li>영속성 컨텍스트에 이미 존재하는 엔티티가 있으면 기존 엔티티를 반환합니다.</li>
</ul>
<h5 id="10-6-3-JPQL-과-플러쉬-모드"><a href="#10-6-3-JPQL-과-플러쉬-모드" class="headerlink" title="10.6.3 JPQL 과 플러쉬 모드"></a>10.6.3 JPQL 과 플러쉬 모드</h5>
                    
                        

                    
                    
                        <p>
                            <a href="/2019/04/17/jpql/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2019/04/11/value-type/">
                            [자바 ORM 표준 JPA 프로그래밍] 9장_값 타입
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-04-11T00:00:00+09:00">
	
		    Apr 11, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/jpa/">JPA</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>JPA의 데이터 타입은 엔티티 타입과 값 타입으로 나눌 수 있습니다. 값 타입은 다음 세 가지로 나눌 수 있습니다.</p>
<ul>
<li>기본값 타입<ul>
<li>자바 기본 타입 : int, double …</li>
<li>래퍼 클래스 : Integer …</li>
<li>String</li>
</ul>
</li>
<li>임베디드 타입</li>
<li>컬렉션 값 타입</li>
</ul>
<h4 id="9-1-기본값-타입"><a href="#9-1-기본값-타입" class="headerlink" title="9.1 기본값 타입"></a>9.1 기본값 타입</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span></span>&#123;</span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@GeneratedValue</span></span><br><span class="line">  <span class="keyword">private</span> Long id; <span class="comment">// 기본값 타입</span></span><br><span class="line">  <span class="keyword">private</span> String name; <span class="comment">// 기본값 타입</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> age; <span class="comment">// 기본값 타입</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-2-임베디드-타입-복합-값-타입"><a href="#9-2-임베디드-타입-복합-값-타입" class="headerlink" title="9.2 임베디드 타입 (복합 값 타입)"></a>9.2 임베디드 타입 (복합 값 타입)</h4><p>새로운 값 타입을 직접 지정해서 사용할 수 있습니다. 이것을 JPA 에서는 임베디드 타입이라고 합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span></span>&#123; </span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@GeneratedValue</span></span><br><span class="line">  <span class="keyword">private</span> Long id;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Embedded</span>  <span class="comment">// 값 타입을 사용하는 곳에 표시</span></span><br><span class="line">  Period workPeriod;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Embedded</span> </span><br><span class="line">  Address homeAddress;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Embeddable</span> <span class="comment">// 값 타입을 정의하는 곳에 표시</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Period</span></span>&#123;</span><br><span class="line">  <span class="meta">@Temporal</span> (TemporalType.DATE) java.util.Date startDate;</span><br><span class="line">  <span class="meta">@Temporal</span> (TemporalType.DATE) java.util.Date endDate;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isWork</span><span class="params">(Date date)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Embeddable</span> <span class="comment">// 값 타입을 정의하는 곳에 표시</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="9-2-1-임베디드-타입과-테이블-매핑"><a href="#9-2-1-임베디드-타입과-테이블-매핑" class="headerlink" title="9.2.1 임베디드 타입과 테이블 매핑"></a>9.2.1 임베디드 타입과 테이블 매핑</h5><p>임베디드 타입은 엔티티의 값일 뿐입니다. 따라서, 값이 속한 엔티티의 테이블에 매핑합니다.</p>
<h5 id="9-2-2-임베디드-타입과-연관관계"><a href="#9-2-2-임베디드-타입과-연관관계" class="headerlink" title="9.2.2 임베디드 타입과 연관관계"></a>9.2.2 임베디드 타입과 연관관계</h5><p>엔티티는 공유 될수 있으므로 참조한다고 표현하고, 값 타입은 특정 주인에게 소속되고 개념상 공유되지 않으므로 포함한다고 합니다.</p>
<h5 id="9-2-3-AttributeOverride-속성-재정의"><a href="#9-2-3-AttributeOverride-속성-재정의" class="headerlink" title="9.2.3 @AttributeOverride : 속성 재정의"></a>9.2.3 @AttributeOverride : 속성 재정의</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span></span>&#123; </span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@GeneratedValue</span></span><br><span class="line">  <span class="keyword">private</span> Long id;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Embedded</span> </span><br><span class="line">  Address homeAddress;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Embedded</span> </span><br><span class="line">  Address companyAddress;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위 코드는 칼럼명이 중복된다는 문제가 있습니다. 이를 다음과 같이 해결합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span></span>&#123; </span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@GeneratedValue</span></span><br><span class="line">  <span class="keyword">private</span> Long id;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Embedded</span> </span><br><span class="line">  Address homeAddress;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Embedded</span></span><br><span class="line">  <span class="meta">@AttributeOverrides</span>(&#123;</span><br><span class="line">    <span class="meta">@AttributeOverride</span>(name = <span class="string">"city"</span>, column = <span class="meta">@Column</span>(name = <span class="string">"COMPANY_CITY"</span>)),</span><br><span class="line">    <span class="meta">@AttributeOverride</span>(name = <span class="string">"street"</span>, column = <span class="meta">@Column</span>(name = <span class="string">"COMPANY_STREET"</span>)),</span><br><span class="line">    <span class="meta">@AttributeOverride</span>(name = <span class="string">"zipcode"</span>, column = <span class="meta">@Column</span>(name = <span class="string">"COMPANY_ZIPCODE"</span>)),</span><br><span class="line">  &#125;)</span><br><span class="line">  Address companyAddress;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>보다시피 코드의 중복도가 높아집니다. 한 엔티티에 같은 임베디드 타입을 중복해서 사용하는 일은 많지 않습니다.</p>
<h5 id="9-2-4-임베디드-타입과-NULL"><a href="#9-2-4-임베디드-타입과-NULL" class="headerlink" title="9.2.4 임베디드 타입과 NULL"></a>9.2.4 임베디드 타입과 NULL</h5><p>임베디드 타입이 null 이면 매핑한 칼럼 값은 모두 null 이 됩니다.</p>
<h4 id="9-3-값-타입과-불변-객체"><a href="#9-3-값-타입과-불변-객체" class="headerlink" title="9.3 값 타입과 불변 객체"></a>9.3 값 타입과 불변 객체</h4><h5 id="9-3-1-값-타입-공유-참조"><a href="#9-3-1-값-타입-공유-참조" class="headerlink" title="9.3.1 값 타입 공유 참조"></a>9.3.1 값 타입 공유 참조</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">member1.setHomeAddress(<span class="keyword">new</span> Address(<span class="string">"city1"</span>));</span><br><span class="line">Address address = member1.getHomeAddress();</span><br><span class="line"></span><br><span class="line">address.setCity(<span class="string">"city2"</span>); <span class="comment">//공유해서 사용</span></span><br><span class="line">member2.setHomeAddress(address);</span><br></pre></td></tr></table></figure>

<p>위 코드는 회원2의 주소만 바뀌길 기대하지만, 회원1의 주소도 바뀌게 됩니다. 이렇듯, 뭔가를 수정했는데 전혀 예상하지 못한 곳에서 문제가 발생하는 것을 Side Effect 라고 합니다. 이를 막기 위해, 값을 복사 해서 사용해야합니다.</p>
<h5 id="9-3-2-값-타입-복사"><a href="#9-3-2-값-타입-복사" class="headerlink" title="9.3.2 값 타입 복사"></a>9.3.2 값 타입 복사</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">member1.setHomeAddress(<span class="keyword">new</span> Address(<span class="string">"city1"</span>));</span><br><span class="line">Address address = member1.getHomeAddress();</span><br><span class="line"></span><br><span class="line"><span class="comment">//복사</span></span><br><span class="line">Address newAddress = address.clone();</span><br><span class="line"></span><br><span class="line">newAddress.setCity(<span class="string">"city2"</span>); <span class="comment">//공유해서 사용</span></span><br><span class="line">member2.setHomeAddress(newAddress);</span><br></pre></td></tr></table></figure>

<p>위의 코드 처럼 복사해서 사용하면 Side Effect 문제는 해결하지만, 임베디드 타입 처럼 직접 정의한 값 타입은 자바의 기본 타입이 아니라 객체 타입이란 것입니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = a; <span class="comment">//기본 타입은 항상 값을 복사</span></span><br><span class="line">b = <span class="number">4</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Address a = <span class="keyword">new</span> Address(<span class="string">"old"</span>);</span><br><span class="line">Address b = a; <span class="comment">//a와 b는 같은 인스턴스를 공유 참조</span></span><br><span class="line">b.setCity(<span class="string">"New"</span>);</span><br></pre></td></tr></table></figure>

<p>복사하지 않고 원본의 참조 값을 직접 넘기는 것을 막을 방법은 없습니다. 자바는 기본 타입이면 값을 복사해서 넘기고, 객체는 참졸르 넘길 뿐이기 때문입니다. 따라서, 객체의 공유 참조는 피할 수 없습니다. 이를 위해, 객체의 값을 수정하지 못하게 막아야합니다.</p>
<h5 id="9-3-3-불변-객체"><a href="#9-3-3-불변-객체" class="headerlink" title="9.3.3 불변 객체"></a>9.3.3 불변 객체</h5><p>한 번 만들면 절대 수정할수 없는 객체를 불변 객체라고 합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Embeddable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span></span>&#123; </span><br><span class="line">  </span><br><span class="line">	<span class="keyword">private</span> String city;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="title">Address</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Address</span><span class="params">(String city)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.city = city;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getCity</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> city;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//수정자 없음</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-4-값-타입의-비교"><a href="#9-4-값-타입의-비교" class="headerlink" title="9.4 값 타입의 비교"></a>9.4 값 타입의 비교</h4><ul>
<li>동일성 비교<ul>
<li>인스턴스의 참조 값을 비교</li>
<li>== 사용</li>
</ul>
</li>
<li>동등성 비교<ul>
<li>인스턴스의 값을 비교</li>
<li>equlas() method 사용</li>
</ul>
</li>
</ul>
<p>값 타입은 그 안에 값이 같으면 같은 것으로 봐야합니다. 따라서 동등성 비교를 해아합니다. </p>
<h4 id="9-5-값-타입-컬렉션"><a href="#9-5-값-타입-컬렉션" class="headerlink" title="9.5 값 타입 컬렉션"></a>9.5 값 타입 컬렉션</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@ElementCollection</span></span><br><span class="line">  <span class="meta">@CollectionTable</span>(name = <span class="string">"ADDRESS"</span>, joinColums = <span class="meta">@JoinColumn</span>(name = <span class="string">"MEMBER_ID"</span>))</span><br><span class="line">  <span class="meta">@Column</span>(name = <span class="string">"FOOD_NAME"</span>)</span><br><span class="line">  <span class="keyword">private</span> List&lt;Address&gt; addressHistory = <span class="keyword">new</span> ArrayList&lt;Address&gt;();</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>값 타입은 식별자가 없는 단순한 값들의 모임이기 때문에, 값을 변경하면 데이터베이스에 저장된 원본 데이터를 찾기 어렵습니다. 값 타입 컬렉션에 보관된 값 타입들은 별도의 테이블에 보관됩니다. 따라서 여기에 보관된 값 타입의 값이 변경되면 데이터베이스에 있는 원본 데이터를 찾기 어렵습니다. </p>
<p>이런 문제로, JPA구현체들은 값 타입 컬레션에 변경 사항이 발생하면, 값 타입 컬렙션이 매핑된 테이블의 연관된 모든 데이터를 삭제하고 현재 값 타입 컬렉션 객체에 있는 모든 값을 데이터베이스에 다시 저장합니다. </p>

                    
                        

                    
                    
                        <p>
                            <a href="/2019/04/11/value-type/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2019/04/09/proxy-relation-mapping/">
                            [자바 ORM 표준 JPA 프로그래밍] 8장_프록시와 연관관계 정리
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-04-09T00:00:00+09:00">
	
		    Apr 09, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/jpa/">JPA</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>이번 포스팅에서 다룰 내용입니다.</p>
<ul>
<li>프록시와 즉시로딩, 지연 로딩</li>
<li>영속성 전이와 고아 객체</li>
</ul>
<h4 id="8-1-프록시"><a href="#8-1-프록시" class="headerlink" title="8.1 프록시"></a>8.1 프록시</h4><p>엔티티가 실제 사용될 때 까지 데이터베이스 조회를 지연하는 방법을 지연 로딩이라고 합니다.<br>지연 로딩 기능을 사용하려면 실제 엔티티 대신에 데이터베이스 조회를 지연할 수 있는 가짜 객체가 필요한데, 이것을 프록시 객체라고 합니다.</p>
<h5 id="8-1-1-프록시-기초"><a href="#8-1-1-프록시-기초" class="headerlink" title="8.1.1 프록시 기초"></a>8.1.1 프록시 기초</h5><p>JPA 에서 식별자로 엔티티 하나를 조회할 때는 EntityManager.find() 를 사용합니다. 이 메소드는 영속성 컨텍스트에 엔티티가 없으면 데이터베이스를 조회합니다.</p>
<p>엔티티를 실제 사용하는 시점까지 데이터베이스 조회를 미루고 싶으면 <strong>EntityManager.getReference()</strong>를 사용하면 됩니다. 이 메소드를 호출하면,  실제 엔티티 객체를 생성하지 않고 데이터베이스 접근을 위임한 프록시 객체를 반환합니다.</p>
<ul>
<li><p>프록시의 특징</p>
<ul>
<li>프록시 객체는 실제 객체에 대한 참조(target) 을 보관합니다.</li>
<li>프록시 객체의 메소드를 호출하면, 프록시 객체는 실제 객체의 메소드를 호출합니다.</li>
<li>영속성 컨텍스트에 이미 찾는 엔티티가 있으면, 데이터베이스를 조회할 필요가 없으므로 em.getReference()를 호출해도 실제 엔티티를 반환합니다.</li>
</ul>
</li>
<li><p>프록시 객체의 초기화</p>
<ul>
<li>프록시 객체의 초기화란, member.getName() 처럼 실제 사용될 때 데이터베이스를 조회해서 실제 엔티티를 생성하는 것을 말합니다.</li>
<li>과정<ul>
<li>member.getName() 호출해서 실제 데이터 조회합니다.</li>
<li>영속성 컨텍스트는 데이터베이스를 조회해서 실제 엔티티 객체를 생성합니다.</li>
<li>프록시 객체는 생성된 실제 엔티티 객체의 참조를 MemerProxy 의 멤버 변수로 보관합ㄴ디ㅏ.</li>
<li>프록시 객체는 실제 엔티티 객체의 getName() 을 호출해서 결과를 반환합니다.</li>
</ul>
</li>
</ul>
</li>
<li><p>준영속 상태의 초기화</p>
<ul>
<li>초기화는 영속성 컨텍스트의 도움을 받아야 가능합니다.</li>
<li>준영속 상태의 프록시를 초기화하면 문제가 발생합니다.</li>
<li>Hibernate : LazyInitializationException 발생</li>
</ul>
</li>
</ul>
<h5 id="8-1-2-프록시와-식별자"><a href="#8-1-2-프록시와-식별자" class="headerlink" title="8.1.2 프록시와 식별자"></a>8.1.2 프록시와 식별자</h5><p>엔티티를 프록시로 조회할 때 식별자 값을 Parameter로 전달하는데 프록시 객체는 이 식별자 값을 보관합니다.구분 칼럼을 꼭 사용해야합니다.</p>
<p>으음..</p>
<h5 id="8-1-3-프록시-확인"><a href="#8-1-3-프록시-확인" class="headerlink" title="8.1.3 프록시 확인"></a>8.1.3 프록시 확인</h5><p>JPA가 제공하는 PersistenceUnitUtil.isLoaded(Object entity) 메소드를 사용하면 프록시 인스턴스의 초기화 여부를 확인할 수 있습니다. 조회한 엔티티가 진짜 엔티티인지 프록시로 조회한 것인지 확인하려면, 클래스명을 직접 출력해보면 됩니다.</p>
<h4 id="8-2-즉시-로딩과-지연-로딩"><a href="#8-2-즉시-로딩과-지연-로딩" class="headerlink" title="8.2 즉시 로딩과 지연 로딩"></a>8.2 즉시 로딩과 지연 로딩</h4><p>프록시 객체는 주로 연관된 엔티티를 지연 로딩할 때 사용합니다.</p>
<p>연관된 엔티티의 조회 시점을 선택할 수 있는 두 가지 방법이 있습니다.</p>
<ul>
<li>즉시로딩</li>
<li>지연 로딩</li>
</ul>
<h5 id="8-2-1-즉시-로딩"><a href="#8-2-1-즉시-로딩" class="headerlink" title="8.2.1 즉시 로딩"></a>8.2.1 즉시 로딩</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">em.find(Member.class, <span class="string">"member1"</span>)</span><br></pre></td></tr></table></figure>

<p>로 회원을 조회하는 순간 팀도 함께 조회합니다. 즉시 로딩을 최적화하기 위해 가능하면 조인쿼리를 사용합니다.</p>
<h5 id="8-2-2-지연-로딩"><a href="#8-2-2-지연-로딩" class="headerlink" title="8.2.2 지연 로딩"></a>8.2.2 지연 로딩</h5><p>위의 코드를 실행하면, 회원만 조회되고 팀은 조회되지 않습니다. 대신에 조회한 회원의 team 맴버 변수에  프록시 객체를 넣어둡니다. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Team team = member.getTeam() <span class="comment">// 프록시 객체</span></span><br></pre></td></tr></table></figure>

<p>반환된 팀 객체는 프록시 객체로, 실제 사용될때 까지 데이터 로딩을 미룹니다. 실제 데이터가 필요한 순간이 되어서야 데이터베이스를 조회해서 프록시 객체를 초기화합니다. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">team.getName()</span><br></pre></td></tr></table></figure>

<p>을 호출하면, 프록시 객체가 초기화 됩니다.</p>
<h4 id="8-3-지연-로딩-활용"><a href="#8-3-지연-로딩-활용" class="headerlink" title="8.3 지연 로딩 활용"></a>8.3 지연 로딩 활용</h4><h5 id="8-3-1-프록시와-컬렉션-래퍼"><a href="#8-3-1-프록시와-컬렉션-래퍼" class="headerlink" title="8.3.1 프록시와 컬렉션 래퍼"></a>8.3.1 프록시와 컬렉션 래퍼</h5><p>Hibernate 는 엔티티를 영속 상태로 만들 때, 엔티티에 컬렉션이 있으면 컬렉션을 추적하고 관리할 목적으로, <strong>원본 컬렉션을 Hibernate가 제공하는 내장 컬렉션으로 변경</strong>합니다. 이를 컬렉션 래퍼라고 합니다.</p>
<p>엔티티를 지연 로딩하면 프록시 객체를 사용해서 지연로딩을 수행하지만, 주문 내역과 같은 컬렉션은 컬렉션 래퍼가 지연 로딩을 처리해줍니다. 즉, 컬렉션 레퍼도 프록시 역할을 합니다.</p>
<p>member.getOrder()를 호출해도 컬렉션은 초기화되지 않습니다. member.getOrders().get(0) 처럼 컬렉션에서 실제 데이터를 조회할 때 데이터베이스를 조회해서 초기화합니다.</p>
<h5 id="8-3-2-JPA-기본-Fetch-전략"><a href="#8-3-2-JPA-기본-Fetch-전략" class="headerlink" title="8.3.2 JPA 기본 Fetch 전략"></a>8.3.2 JPA 기본 Fetch 전략</h5><ul>
<li>@ManyToOne, @OneToOne<ul>
<li>FetchType.EAGER</li>
</ul>
</li>
<li>@OneToMany, @ManyToMany<ul>
<li>FetchType.LAZY</li>
</ul>
</li>
</ul>
<p>추천하는 방버은 모든 연관관계에 지연 로딩을 사용하는 것입니다. 그리고, 실제 사용하는 상황을 보고 꼭 필요한 곳에 즉시 로딩을 사용하도록 최적화 하면 됩니다.</p>
<h5 id="8-3-3-컬렉션에-FetchType-EAGER-사용시-주의점"><a href="#8-3-3-컬렉션에-FetchType-EAGER-사용시-주의점" class="headerlink" title="8.3.3 컬렉션에 FetchType.EAGER 사용시 주의점"></a>8.3.3 컬렉션에 FetchType.EAGER 사용시 주의점</h5><ul>
<li>컬렉션을 하나 이상 즉시 로딩하는 것은 권장하지 않습니다.</li>
<li>컬렉션 즉시 로딩은 항상 OUTER JOIN 을 사용합니다.</li>
</ul>
<h4 id="8-4-영속성-전이-CASCADE"><a href="#8-4-영속성-전이-CASCADE" class="headerlink" title="8.4 영속성 전이 : CASCADE"></a>8.4 영속성 전이 : CASCADE</h4><p>특정 엔티티를 영속 상태로 만들 때 연관된 엔티티도 함께 영속 상태로 만들고 싶으면 영송석 전이 기능을 사용하면 됩니다. JPA는 CASCADE 옵션으로 영속성 전이 기능을 제공합니다.</p>
<h5 id="8-4-1-저장"><a href="#8-4-1-저장" class="headerlink" title="8.4.1 저장"></a>8.4.1 저장</h5><p>부모만 영속화하면 CascadeType.PERSIST 로 설정한 자식 엔티티까지 함께 영속화해서 저장합니다.</p>
<h5 id="8-4-2-삭제"><a href="#8-4-2-삭제" class="headerlink" title="8.4.2 삭제"></a>8.4.2 삭제</h5><p>CascadeType.REMOVE 설정하고 부모 엔티티만 삭제하면 연관된 자식 엔티티까지 함께 삭제됩니다.</p>
<h4 id="8-5-고아-객체"><a href="#8-5-고아-객체" class="headerlink" title="8.5 고아 객체"></a>8.5 고아 객체</h4><p>JPA는 부모 엔티티와 연관 관계가 끊어진 자식 엔티티를 자동으로 삭제하는 기능을 제공하는데, 이를 고아 객체 제거라고 합니다. 이 기능은 참조하는 곳이 하나 일때만 사용해야합니다. 즉, 특정 엔티티가 개인 소유하는 엔티티에만 이 기능을 적용해야합니다.</p>
<p>다음 코드는, 부모 엔티티의 컬렉션에서 자식 엔티티의 참조만 제거하면 자식 엔티티가 자동으로 삭제됩니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Paren</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="meta">@OneToMany</span>(mappedBy=<span class="string">"parent"</span>, orphanRemoval = <span class="keyword">true</span>)</span><br><span class="line">  <span class="keyword">private</span> List&lt;Child&gt; children = <span class="keyword">new</span> ArrayList&lt;Child&gt;();</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>다음 코드처럼,</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Parent parent = em.find(Parent.class, id);</span><br><span class="line">parent.getChildren.remove(<span class="number">0</span>); <span class="comment">// 자식 엔티티를 컬렉션에서 제거</span></span><br></pre></td></tr></table></figure>

<p>컬렉션에서 첫 번째 자식을 제거하면, 데이터베잇의 데이터도 삭제됩니다. 주의할 점은, 고아 객체 제거 기능은 영속성 컨텍스트를 flush 할 때 적용되므로, flush 시점에 DELETE SQL 이 실행됩니다.</p>
<h5 id="8-6-영속성-전이-고아객체-생명주기"><a href="#8-6-영속성-전이-고아객체-생명주기" class="headerlink" title="8.6 영속성 전이 + 고아객체, 생명주기"></a>8.6 영속성 전이 + 고아객체, 생명주기</h5><p><strong>CascadeType.All + orphanRemove = true</strong> 를 동시에 사용하면?</p>
<p>일반적으로 엔티티를 em.persist()로 영속화되고, em.remove()로 제거됩니다. 이것은 엔티티 스스로 생명주기를 관리한다는 뜻입니다. 그런데 두 옵션을 활성화하면 부모 엔티티르 통해서 자식의 엔티티를 관리할 수 있습니다.</p>
<p>자식을 저장하려면,</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Parent parent = em.find(Parent.class, id);</span><br><span class="line">parent.addChild(child);</span><br></pre></td></tr></table></figure>

<p>자식을 삭제하려면,</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Parent parent = em.find(Parent.class, id);</span><br><span class="line">parent.getChildren().remove(child);</span><br></pre></td></tr></table></figure>


                    
                        

                    
                    
                        <p>
                            <a href="/2019/04/09/proxy-relation-mapping/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2019/04/06/advanced-mappings/">
                            [자바 ORM 표준 JPA 프로그래밍] 7장_고급 매핑
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-04-06T00:00:00+09:00">
	
		    Apr 06, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/jpa/">JPA</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>이번 포스팅에서 다룰 고급 매핑은 다음과 같습니다.</p>
<ul>
<li>상속 관계 매핑</li>
<li>@MappedSupperclass</li>
<li>복합 키와 식별 관계 매핑</li>
<li>조인 테이블</li>
<li>엔티티 하나에 여러 테이블 매핑하기</li>
</ul>
<h4 id="7-1-상속-관계-매핑"><a href="#7-1-상속-관계-매핑" class="headerlink" title="7.1 상속 관계 매핑"></a>7.1 상속 관계 매핑</h4><p>관계형 데이터베이스에는 상속이라는 개념이 없습니다. 대신에, Super-Type Sub-Type Relationship 이라는 모델링 기법이 객체의 상속 개념과 가장 유사합니다. ORM 의 상속 관계 매핑은 객체의 상속 구조와 데이터베이스의 Super-Type Sub-Type Relationship 을 매핑하는 것입니다.</p>
<p>Super-Type Sub-Type Relationship 논리 모델을 실제 물리 모델인 테이블로 구현할 때는 3가지 방법이 있습니다.</p>
<ul>
<li>각각의 테이블로 변환<ul>
<li>조인 전략</li>
</ul>
</li>
<li>통합 테이블로 변환<ul>
<li>단일 테이블 전략</li>
</ul>
</li>
<li>서브타입 테이블로 변환<ul>
<li>구현 클래스마다 테이블 전략</li>
</ul>
</li>
</ul>
<h5 id="7-1-1-조인-전략"><a href="#7-1-1-조인-전략" class="headerlink" title="7.1.1 조인 전략"></a>7.1.1 조인 전략</h5><p>엔티티 각각을 모두 테이블로 만들고 자식 테이블이 부모 테이블의 기본 키를 받아서 기본 키 + 외래 키로 사용하는 전략입니다.<br>주의할 점은, 객체는 타입으로 구분할 수 있지만 테이블은 타입의 개념이 없기 때문에 타입을 구분하는 칼럼을 추가해야합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Inheritance</span> (strategy = InheritanceType.JOINED) <span class="comment">// 상속 매핑은 부모 클래스에 @Inheritance 를 사용</span></span><br><span class="line"><span class="meta">@DiscriminatorColumn</span> (name = <span class="string">"DTYPE"</span>)	<span class="comment">// 부모 클래스에 구분 칼럼을 지정</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@GeneratedValue</span> <span class="meta">@Column</span> (name = <span class="string">"ITEM_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> Long id;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String name; </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@DiscriminatorColumn</span> (<span class="string">"A"</span>)  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Album</span> <span class="keyword">extends</span> <span class="title">Item</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String artist;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@DiscriminatorColumn</span> (<span class="string">"M"</span>) <span class="comment">// 영화 엔티티를 저장하면 구분 칼럼인 DTYPE 에 값 M이 저장</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Movie</span> <span class="keyword">extends</span> <span class="title">Item</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String director;</span><br><span class="line">  <span class="keyword">private</span> String actor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>장점<ul>
<li>테이블이 정규화 됩니다.</li>
<li>외래 키 참조 무결성 제약 조건을 활용할 수 있습니다.</li>
<li>저장공간을 효율적으로 사용할 수 있습니다.</li>
</ul>
</li>
<li>단점<ul>
<li>조회할 때 조인이 많이 사용되므로 성능이 저하될 수 있습니다.</li>
<li>조회 쿼리가 복잡합니다.</li>
<li>데이터를 등록할 INSERT SQL 을 두 번 실행합니다.</li>
</ul>
</li>
<li>특징<ul>
<li>JPA 표준 명세는 구분 칼럼을 사용하도록 하지만, 하이버네이트는 구분 칼럼 없이도 동작합니다.</li>
</ul>
</li>
</ul>
<h5 id="7-1-2-단일-테이블-전략"><a href="#7-1-2-단일-테이블-전략" class="headerlink" title="7.1.2 단일 테이블 전략"></a>7.1.2 단일 테이블 전략</h5><p>테이블을 하나만 사용하고 구분 칼럼으로 어떤 자식 데이터가 저장되었는지 구분합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Inheritance</span> (strategy = InheritanceType.SINGLE_TABLE)</span><br><span class="line"><span class="meta">@DiscriminatorColumn</span> (name = <span class="string">"DTYPE"</span>)	</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@GeneratedValue</span> <span class="meta">@Column</span> (name = <span class="string">"ITEM_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> Long id;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String name; </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@DiscriminatorColumn</span> (<span class="string">"A"</span>)  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Album</span> <span class="keyword">extends</span> <span class="title">Item</span></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@DiscriminatorColumn</span> (<span class="string">"M"</span>) </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Movie</span> <span class="keyword">extends</span> <span class="title">Item</span></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>장점<ul>
<li>조인이 필요 없으므로 일반적으로 조회 성능이 빠릅니다.</li>
<li>조회 쿼리가 단순합니다.</li>
</ul>
</li>
<li>단점<ul>
<li>자식 엔티티가 매핑한 칼럼은 모두 null을 허용해야합니다.</li>
<li>단일 테이블에 모든 것을 저장하므로 테이블이 커질 수 있습니다. 상황에 따라서는 조회 성능이 느려질 수 있습니다.</li>
</ul>
</li>
<li>특징<ul>
<li>구분 칼럼을 꼭 사용해야합니다.</li>
</ul>
</li>
</ul>
<h5 id="7-1-3-구현-클래스마다-테이블-전략"><a href="#7-1-3-구현-클래스마다-테이블-전략" class="headerlink" title="7.1.3 구현 클래스마다 테이블 전략"></a>7.1.3 구현 클래스마다 테이블 전략</h5><p>자식 엔티티마다 테이블을 만듦니다. 그리고, 자식 테이블에 각각에 필요한 칼럼이 모두 있습니다. 이 전략은 추천하지 않는 전략입니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Inheritance</span> (strategy = InheritanceType.TABLE_PER_CLASS)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@GeneratedValue</span> <span class="meta">@Column</span> (name = <span class="string">"ITEM_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> Long id;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String name; </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Album</span> <span class="keyword">extends</span> <span class="title">Item</span></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Movie</span> <span class="keyword">extends</span> <span class="title">Item</span></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>장점<ul>
<li>서브 타입을 구분해서 처리할 때 효과적입니다.</li>
<li>not null 제약조건을 사용할 수 있습니다.</li>
</ul>
</li>
<li>단점<ul>
<li>여러 자식 테이블을 함께 조회할 때 성능이 느립니다. (SQL 의 UNION 을 사용해야합니다.)</li>
<li>자식 테이블을 통합해서 쿼리하기 어렵습니다.</li>
</ul>
</li>
<li>특징<ul>
<li>구분 칼럼을 사용하지 않습니다.</li>
</ul>
</li>
</ul>
<h4 id="7-2-MappedSuperClass"><a href="#7-2-MappedSuperClass" class="headerlink" title="7.2 MappedSuperClass"></a>7.2 MappedSuperClass</h4><p>부모 클래스는 테이블과 매핑하지 않고, 부모 클래스를 상속받는 자식 클래스에게 매핑 정보만 제공하고 싶으면 @MappedSuperClass 를 사용합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//테이블과 매핑할 필요가 없고 자식 엔티티에 공통으로 사용되는 매핑 정보만 제공</span></span><br><span class="line"><span class="meta">@MappedSuperClass</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseEntity</span></span>&#123; </span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@GeneratedValue</span></span><br><span class="line">  <span class="keyword">private</span> Long id;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span> <span class="keyword">extends</span> <span class="title">BaseEntity</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//id, name 상속</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Seller</span> <span class="keyword">extends</span> <span class="title">BaseEntity</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//id, name 상속</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String shopName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>부모로부터 물련 받은 매핑 정보를 재정의 하려면,</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="comment">//부모에게 상속 받은 id 속성의 칼럼명을 MEMBER_ID 로 재정의</span></span><br><span class="line"><span class="meta">@AttributeOverride</span>(name = <span class="string">"id"</span>, column = <span class="meta">@Column</span>(name = <span class="string">"MEMBER_ID"</span>))</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span> <span class="keyword">extends</span> <span class="title">BaseEntity</span></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>둘 이상을 재정을 하려면,</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@AttributeOverrides</span>(&#123;</span><br><span class="line">  <span class="meta">@AttributeOverride</span>(name = <span class="string">"id"</span>, column = <span class="meta">@Column</span>(name = <span class="string">"MEMBER_ID"</span>)),</span><br><span class="line">  <span class="meta">@AttributeOverride</span>(name = <span class="string">"name"</span>, column = <span class="meta">@Column</span>(name = <span class="string">"MEMBER_NAME"</span>))</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span> <span class="keyword">extends</span> <span class="title">BaseEntity</span></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>@MappedSuperClass 의 특징<ul>
<li>@MappedSuperClass 로 지정한 클래스는 엔티티가 아닙니다. 따라서, em.find() 나 JPQL 을 사용할 수 없습니다.</li>
<li>이 클래스를 직접 생성해서 사용할 일은 거의 없으므로, 추상 클래스로 만드는 것을 권장합니다.</li>
</ul>
</li>
</ul>
<h4 id="7-3-복합-키와-식별-관계-매핑"><a href="#7-3-복합-키와-식별-관계-매핑" class="headerlink" title="7.3 복합 키와 식별 관계 매핑"></a>7.3 복합 키와 식별 관계 매핑</h4><h5 id="7-3-1-식별-관계-VS-비식별-관계"><a href="#7-3-1-식별-관계-VS-비식별-관계" class="headerlink" title="7.3.1 식별 관계 VS 비식별 관계"></a>7.3.1 식별 관계 VS 비식별 관계</h5><ul>
<li>식별 관계<ul>
<li>부모 테이블의 기본 키를 내려받아서, 자식 테이블의 기본 키 + 외래 키로 사용하는 관계입니다.</li>
</ul>
</li>
<li>비식별 관계<ul>
<li>부모 테이블의 기본 키를 내려받아서, 자식 테이블의 외래키로만 사용하는 관계입니다.<ul>
<li>필수적 비식별 관계<ul>
<li>외래 키에 NULL을 허용 하지 않습니다. 연관관계를 필수적으로 맺어야 합니다.</li>
</ul>
</li>
<li>선택적 비식별 관계<ul>
<li>외래 키에 NULL을 허용합니다. 연관관계를 맺을지 선택할 수 있습니다.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="7-3-2-복합키-비식별-관계-매핑"><a href="#7-3-2-복합키-비식별-관계-매핑" class="headerlink" title="7.3.2 복합키: 비식별 관계 매핑"></a>7.3.2 복합키: 비식별 관계 매핑</h5><p>둘 이상의 칼럼으로 구성된 복합 기본키를 다음과 같이 해보면, 매핑 오류가 발생합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line">publi <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Id</span></span><br><span class="line">  <span class="keyword">private</span> String id;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Id</span></span><br><span class="line">  <span class="keyword">private</span> String id2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JPA 에서 식별자를 둘 이상 사용하려면 별도의 식별자 클래스를 만들어야합니다.<br>복합키를 지원하기 위해, 관계형 데이터베이스에 가까운 방법인 @IdClass 와, 객체지향에 가까운 @EmbededId 두 가지 방법을 제공합니다. </p>
<h6 id="IdClass"><a href="#IdClass" class="headerlink" title="IdClass"></a>IdClass</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@IdClass</span> (ParentId.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@Column</span> (name = <span class="string">"PARENT_ID1"</span>)</span><br><span class="line">  <span class="keyword">private</span> String id1; <span class="comment">//ParerntId.id1 과 연결</span></span><br><span class="line">  </span><br><span class="line">	<span class="meta">@Id</span> <span class="meta">@Column</span> (name = <span class="string">"PARENT_ID2"</span>)</span><br><span class="line">  <span class="keyword">private</span> String id2; <span class="comment">//ParerntId.id2 과 연결</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParentId</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123; <span class="comment">// Serializable 를 구현해야합니다.</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 식별자 클래스의 속성명과 엔티티에서 사용하는 식별자의 속성명이 같아야합니다.</span></span><br><span class="line">  <span class="keyword">private</span> String id1; <span class="comment">//Parernt.id1 과 연결</span></span><br><span class="line">  <span class="keyword">private</span> String id2; <span class="comment">//Parernt.id2 과 연결</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ParentId</span><span class="params">()</span></span>&#123; </span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ParentId</span><span class="params">(String id1, String id2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.id1 = id1;            </span><br><span class="line">    <span class="keyword">this</span>.id2 = id2;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// equals 와 hashCode를 구현해야합니다.</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span></span>&#123;...&#125; </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>복합키를 사용하는 엔티티를 저장하면,</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Parent parent = <span class="keyword">new</span> Parent;</span><br><span class="line">parent.setId1(<span class="string">"myId1"</span>);</span><br><span class="line">parent.setId2(<span class="string">"myId2"</span>);</span><br><span class="line">parent.setName(<span class="string">"ParentName"</span>);</span><br><span class="line">em.persist(parent)</span><br></pre></td></tr></table></figure>

<p>영속성 컨텍스트에 엔티티를 등록하기 직전에, 내부에서 Parent.id1, Parent.id2 값을 사용해서 식별자 클래스인 ParentId 를 생성하고 영속성 컨텍스트의 키로 사용합니다.</p>
<p>ParentId 를 사용해서 엔티티를 조회합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ParentId parentId = <span class="keyword">new</span> ParentId(<span class="string">"myId1"</span>, <span class="string">"myId2"</span>);</span><br><span class="line">Parent parent = em.find(Parent.class, parentId);</span><br></pre></td></tr></table></figure>

<p>자식 클래스는,</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Id</span></span><br><span class="line">  <span class="keyword">private</span> String id;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 부모 테이블의 기본 키 칼럼이 복합 키이므로, 자식 테이블의 외래 키도 복합키</span></span><br><span class="line">  <span class="comment">// 외래 키 매핑 시 여러 칼럼을 매핑해야하므로 @JoinColums를 사용</span></span><br><span class="line">  <span class="meta">@ManyToOne</span></span><br><span class="line">  <span class="meta">@JoinColums</span>(&#123;</span><br><span class="line">    <span class="meta">@JoinColum</span>(name = <span class="string">"PARENT_ID1"</span>, referencedColumnName = <span class="string">"PARENT_ID1"</span>),</span><br><span class="line">    <span class="meta">@JoinColum</span>(name = <span class="string">"PARENT_ID2"</span>, referencedColumnName = <span class="string">"PARENT_ID2"</span>),</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> Parent parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="EmbeddedID"><a href="#EmbeddedID" class="headerlink" title="EmbeddedID"></a>EmbeddedID</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@EmbeddedId</span></span><br><span class="line">  <span class="keyword">private</span> ParentId id;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Embeddable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParentId</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123; <span class="comment">//Serializable 를 구현</span></span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Column</span>(name = <span class="string">"PARENT_ID1"</span>)</span><br><span class="line">  <span class="keyword">private</span> String id1;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Column</span>(name = <span class="string">"PARENT_ID2"</span>)</span><br><span class="line">  <span class="keyword">private</span> String id2;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//equals and hashCode 구현</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>엔티티를 저장하면,</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Parent parent = <span class="keyword">new</span> Parent;</span><br><span class="line">ParentId parentId = <span class="keyword">new</span> ParentId(<span class="string">"myId1"</span>, <span class="string">"myId2"</span>);</span><br><span class="line"></span><br><span class="line">parent.setId(parentId);</span><br><span class="line">parent.setName(<span class="string">"ParentName"</span>);</span><br><span class="line">em.persist(parent)</span><br></pre></td></tr></table></figure>

<p>엔티티를 조회하면,</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ParentId parentId = <span class="keyword">new</span> ParentId(<span class="string">"myId1"</span>, <span class="string">"myId2"</span>);</span><br><span class="line">Parent parent = em.find(Parent.class, parentId);</span><br></pre></td></tr></table></figure>

<h5 id="7-3-3-복합키-식별-관계-매핑"><a href="#7-3-3-복합키-식별-관계-매핑" class="headerlink" title="7.3.3 복합키: 식별 관계 매핑"></a>7.3.3 복합키: 식별 관계 매핑</h5><p>부모, 자식, 손자까지 계속 기본 키를 전달하는 식별관계를 생각해보려고 합니다.</p>
<h6 id="IdClass-1"><a href="#IdClass-1" class="headerlink" title="IdClass"></a>IdClass</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@Column</span> (name = <span class="string">"PARENT_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> String id;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@IdClass</span>(ChildId.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 식별 관계는 기본 키와 외래키를 같이 매핑해야합니다.</span></span><br><span class="line">  <span class="comment">// 따라서, 식별자 매핑인 @Id 와 연관관계 매팽인 @ManyToOne 을 같이 사용합니다.</span></span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@ManyToOne</span> <span class="meta">@JoinColumn</span> (name = <span class="string">"PARENT_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> Parent parent;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@Column</span> (name = <span class="string">"CHILD_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> Parent childId;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChildId</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">  <span class="keyword">private</span> String parent; <span class="comment">//Child.parent 매핑</span></span><br><span class="line">  <span class="keyword">private</span> String childId; <span class="comment">//Child.childId 매핑</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//equals, hashCode</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@IdClass</span>(GrandChildId.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GrandChild</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Id</span> </span><br><span class="line">  <span class="meta">@ManyToOne</span></span><br><span class="line">  <span class="meta">@JoinColumns</span>(&#123;</span><br><span class="line">    <span class="meta">@JoinColumn</span>(name = <span class="string">"PARENT_ID"</span>),</span><br><span class="line">    <span class="meta">@JoinColumn</span>(name = <span class="string">"CHILD_ID"</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">private</span> Child child;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@Column</span> (name = <span class="string">"GRANDCHILD_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> String id;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GrandChildId</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">  <span class="keyword">private</span> ChildId child; <span class="comment">//GrandChild.child 매핑</span></span><br><span class="line">  <span class="keyword">private</span> String id; <span class="comment">//GrandChild.id 매핑</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//equals, hashCode</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="EmbeddeId"><a href="#EmbeddeId" class="headerlink" title="EmbeddeId"></a>EmbeddeId</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@Column</span> (name = <span class="string">"PARENT_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> String id;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@EmbeddedId</span></span><br><span class="line">  <span class="keyword">private</span> ChildId id;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@MapsId</span>(<span class="string">"parentId"</span>) <span class="comment">//ChildId.parentId 매핑. 외래 키와 매핑한 연관관계를 기본 키에도 매핑.</span></span><br><span class="line">  <span class="meta">@ManyToOne</span></span><br><span class="line">  <span class="meta">@JoinColumn</span> (name = <span class="string">"PARENT_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> Parent parent;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Embeddable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChildId</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">  <span class="keyword">private</span> String parentId; <span class="comment">// @MapsId("parentId") 로 매핑</span></span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Column</span>(name = <span class="string">"CHILD_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> String id;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//equals, hashCode</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GrandChild</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@EmbededId</span></span><br><span class="line">  <span class="keyword">private</span> GrandChildId id;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@MapsId</span> (<span class="string">"childId"</span>) <span class="comment">// GrandChildId.childId 매핑</span></span><br><span class="line">  <span class="meta">@ManyToOne</span></span><br><span class="line">  <span class="meta">@JoinColumns</span>(&#123;</span><br><span class="line">    <span class="meta">@JoinColumn</span>(name = <span class="string">"PARENT_ID"</span>),</span><br><span class="line">    <span class="meta">@JoinColumn</span>(name = <span class="string">"CHILD_ID"</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">private</span> Child child;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Embeddable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GrandChildId</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">  <span class="keyword">private</span> ChildId child; <span class="comment">// @MapsId("childId") 로 매핑</span></span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Column</span> ( name = <span class="string">"GRANDCHILD_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> String id;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//equals, hashCode</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="7-3-4-비식별-관계로-구현"><a href="#7-3-4-비식별-관계로-구현" class="headerlink" title="7.3.4 비식별 관계로 구현"></a>7.3.4 비식별 관계로 구현</h5><p>방금 예를, 비식별 관계로 변경하려고 합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@GeneratedValue</span> <span class="meta">@Column</span> (name = <span class="string">"PARENT_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> String id;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@GeneratedValue</span> <span class="meta">@Column</span> (name = <span class="string">"CHILD_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> Long id;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@ManyToOne</span> <span class="meta">@JoinColumn</span> (name = <span class="string">"PARENT_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> Parent parent;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GrandChild</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@GeneratedValue</span> <span class="meta">@Column</span> (name = <span class="string">"GRANDCHILD_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> Long id;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@ManyToOne</span> <span class="meta">@JoinColumn</span>(name = <span class="string">"CHILD_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> Child child;</span><br><span class="line">    </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="7-3-5-일대일-식별-관계"><a href="#7-3-5-일대일-식별-관계" class="headerlink" title="7.3.5 일대일 식별 관계"></a>7.3.5 일대일 식별 관계</h5><p>자식 테이블의 기본 키 값으로 부모 테이블의 기본 키 값만 사용합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Board</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@GeneratedValue</span> <span class="meta">@Column</span> (name = <span class="string">"BOARD_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> String id;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String title;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@OneToOne</span>(mappedBy = <span class="string">"board"</span>)</span><br><span class="line">  <span class="keyword">private</span> BoardDetail boardDetail;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoardDetail</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Id</span></span><br><span class="line">  <span class="keyword">private</span> Long boardId;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@MapsId</span> <span class="comment">//BoardDetail.boardId 매핑</span></span><br><span class="line">  <span class="meta">@OneToOne</span></span><br><span class="line">  <span class="meta">@JoinColumn</span> (name = <span class="string">"BOARD_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> Board board;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String content;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-4-조인-테이블"><a href="#7-4-조인-테이블" class="headerlink" title="7.4 조인 테이블"></a>7.4 조인 테이블</h4><p>데이터베이스 테이블의 연관관계를 설계하는 방법은 두 가지 입니다.</p>
<ul>
<li>조인 칼럼 사용 ( 외래키)<ul>
<li>회원이 사물함을 사용하기 전까지는 아직 둘 사이의 관계가 없으므로, MEMBER Table 의 LOKCER_ID 외래키에 null</li>
<li>외래 키애 null 허용하는 관계를 선택적 비식별 관계라고 합니다.</li>
<li>null 허용하므로, 회원과 사물함 조인할 때는 OUTER JOIN 사용해야합니다.</li>
<li>회원과 사물함이 아주 가끔 관계를 맺으면, 외래 키 대부분 값에 null 이 저장이 됩니다.</li>
</ul>
</li>
<li>조잍 테이블 사용 (테이블)<ul>
<li>조인 테이블에서 두 테이블의 외래 키를 가지고 연관 관계를 관리합니다.</li>
</ul>
</li>
</ul>
<h5 id="7-4-1-일대일-조인-테이블"><a href="#7-4-1-일대일-조인-테이블" class="headerlink" title="7.4.1 일대일 조인 테이블"></a>7.4.1 일대일 조인 테이블</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@GeneratedValue</span> <span class="meta">@Column</span> (name = <span class="string">"PARENT_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> Long id;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@OneToOne</span></span><br><span class="line">  <span class="meta">@JoinTable</span>(name = <span class="string">"PARENT_CHILD"</span>, <span class="comment">// 매핑할 조인 테이블 이름</span></span><br><span class="line">            joinColums = <span class="meta">@JoinColumn</span>(name = <span class="string">"PARENT_ID"</span>), <span class="comment">// 현재 엔티티를 참조하는 외래 키</span></span><br><span class="line">            inverseJoinColums = <span class="meta">@JoinColum</span>(name = <span class="string">"CHILD_ID"</span>) <span class="comment">// 반대방향 엔티티를 참조하는 외래 키</span></span><br><span class="line">  )</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> Child child;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@GeneratedValue</span> <span class="meta">@Column</span> (name = <span class="string">"CHILD_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> Long id;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="7-4-2-일대다-조인-테이블"><a href="#7-4-2-일대다-조인-테이블" class="headerlink" title="7.4.2 일대다 조인 테이블"></a>7.4.2 일대다 조인 테이블</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@GeneratedValue</span> <span class="meta">@Column</span> (name = <span class="string">"PARENT_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> Long id;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@OneToMany</span></span><br><span class="line">  <span class="meta">@JoinTable</span>(name = <span class="string">"PARENT_CHILD"</span>, <span class="comment">// 매핑할 조인 테이블 이름</span></span><br><span class="line">            joinColums = <span class="meta">@JoinColumn</span>(name = <span class="string">"PARENT_ID"</span>), <span class="comment">// 현재 엔티티를 참조하는 외래 키</span></span><br><span class="line">            inverseJoinColums = <span class="meta">@JoinColum</span>(name = <span class="string">"CHILD_ID"</span>) <span class="comment">// 반대방향 엔티티를 참조하는 외래 키</span></span><br><span class="line">  )</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> List&lt;Child&gt; child = <span class="keyword">new</span> ArrayList&lt;Child&gt;();</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@GeneratedValue</span> <span class="meta">@Column</span> (name = <span class="string">"CHILD_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> Long id;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="7-4-3-다대일-조인-테이블"><a href="#7-4-3-다대일-조인-테이블" class="headerlink" title="7.4.3 다대일 조인 테이블"></a>7.4.3 다대일 조인 테이블</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@GeneratedValue</span> <span class="meta">@Column</span> (name = <span class="string">"PARENT_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> Long id;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@OneToMany</span> (mappedBy = <span class="string">"PARENT_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> List&lt;Child&gt; child = <span class="keyword">new</span> ArrayList&lt;Child&gt;();</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@GeneratedValue</span> <span class="meta">@Column</span> (name = <span class="string">"CHILD_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> Long id;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@ManyToOne</span>(optional = <span class="keyword">false</span>)</span><br><span class="line">  <span class="meta">@JoinTable</span>(name = <span class="string">"PARENT_CHILD"</span>, <span class="comment">// 매핑할 조인 테이블 이름</span></span><br><span class="line">            joinColums = <span class="meta">@JoinColumn</span>(name = <span class="string">"CHILD_ID"</span>), <span class="comment">// 현재 엔티티를 참조하는 외래 키</span></span><br><span class="line">            inverseJoinColums = <span class="meta">@JoinColum</span>(name = <span class="string">"PARENT_ID"</span>) <span class="comment">// 반대방향 엔티티를 참조하는 외래 키</span></span><br><span class="line">  )</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> Parent parent;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="7-4-4-다대다-조인-테이블"><a href="#7-4-4-다대다-조인-테이블" class="headerlink" title="7.4.4 다대다 조인 테이블"></a>7.4.4 다대다 조인 테이블</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@GeneratedValue</span> <span class="meta">@Column</span> (name = <span class="string">"PARENT_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> Long id;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@ManyToMany</span></span><br><span class="line">  <span class="meta">@JoinTable</span>(name = <span class="string">"PARENT_CHILD"</span>, <span class="comment">// 매핑할 조인 테이블 이름</span></span><br><span class="line">            joinColums = <span class="meta">@JoinColumn</span>(name = <span class="string">"PARNET_ID"</span>), <span class="comment">// 현재 엔티티를 참조하는 외래 키</span></span><br><span class="line">            inverseJoinColums = <span class="meta">@JoinColum</span>(name = <span class="string">"CHILD_ID"</span>) <span class="comment">// 반대방향 엔티티를 참조하는 외래 키</span></span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">private</span> List&lt;Child&gt; child = <span class="keyword">new</span> ArrayList&lt;Child&gt;();</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@GeneratedValue</span> <span class="meta">@Column</span> (name = <span class="string">"CHILD_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> Long id;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-4-엔티티-하나에-여러-테이블-매핑"><a href="#7-4-엔티티-하나에-여러-테이블-매핑" class="headerlink" title="7.4 엔티티 하나에 여러 테이블 매핑"></a>7.4 엔티티 하나에 여러 테이블 매핑</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span> ( name = <span class="string">"BOARD"</span>) <span class="comment">// BOARD 테이블과 매핑</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// BOARD_DETAIL 테이블을 추가로 매핑</span></span><br><span class="line"><span class="meta">@SecondaryTable</span> ( name = <span class="string">"BOARD_DETAIL"</span>, <span class="comment">//매핑할 다른 테이블 이름</span></span><br><span class="line">                 <span class="comment">//매핑할 다른 테이블의 기본 키 칼럼 속성</span></span><br><span class="line">                pkJoinColums = <span class="meta">@PrimaryJoinColumn</span>(name = <span class="string">"BOARD_DETAIL_ID"</span>))</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Board</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@GeneratedValue</span> <span class="meta">@Column</span> (name = <span class="string">"BOARD_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> Long id;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String title;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// content 필드는 BOARD_DETAIL 테이블의 칼럼에 매핑</span></span><br><span class="line">  <span class="meta">@Column</span>(table = <span class="string">"BOARD_DETAIL"</span>)</span><br><span class="line">  <span class="keyword">private</span> String content;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@SecondaryTable 를 사용해서 두 테이블을 하나의 엔티티에 매핑하는 방법 보다는, 테이블당 엔티티를 각각 만들어서 일대일 매핑하는 것을 권장합니다.</p>

                    
                        

                    
                    
                        <p>
                            <a href="/2019/04/06/advanced-mappings/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2019/03/27/relation-mappings/">
                            [자바 ORM 표준 JPA 프로그래밍] 6장_다양한 연관관계 매핑
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-03-27T00:00:00+09:00">
	
		    Mar 27, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/jpa/">JPA</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>이번 포스팅에서는 다양한 연관관계를 다룹니다. 엔티티의 연관 관계를 매핑 할 때는 다음 세 가지를 고려해야합니다.</p>
<ul>
<li>다중성<ul>
<li>다대일</li>
<li>일대다</li>
<li>일대일</li>
<li>다대다</li>
</ul>
</li>
<li>단방향, 양방향<ul>
<li>테이블에는 방향이라는 개념이 없습니다.</li>
<li>객체는 참조용 필드를 가지고 있는 객체만 연관된 객체를 조회할 수 있습니다.</li>
</ul>
</li>
<li>연관관계의 주인<ul>
<li>데이터베이스는 외래 키 하나로 두 데이블이 연관관계 맺습니다.</li>
<li>엔티티를 양방향으로 매핑하면 A-&gt;B, B-&gt;A 2곳에서 서로를 참조하기 때문에, 객체의 연관관계를 관리하는 포인트는 2곳입니다. 따라서, 두 객체 연관관계 중 하나를 정해서 데이터베이스 외래 키를 관리해야합니다.</li>
</ul>
</li>
</ul>
<h4 id="1-다대일"><a href="#1-다대일" class="headerlink" title="1. 다대일"></a>1. 다대일</h4><p>데이터베이스 테이블의 일, 다 관계에서 외래 키는 항상 다쪽에 있습니다. 따라서, 객체 양방향 관계에서 연관관계의 주인은 항상 다쪽입니다.</p>
<h5 id="1-1-다대일-단방향"><a href="#1-1-다대일-단방향" class="headerlink" title="1.1 다대일 단방향"></a>1.1 다대일 단방향</h5><p> 회원은 팀 엔티티를 참조 가능합니다. 팀은 회원 참조하는 필드가 없습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@GeneratedValue</span></span><br><span class="line">  <span class="meta">@Column</span> (name = <span class="string">"MEMBER_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> Long id;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String username;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@ManyToOne</span></span><br><span class="line">  <span class="meta">@JoinColum</span> (name = <span class="string">"TEAM_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> Team team;	</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//Getter, Setter ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Team</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@GeneratedValue</span></span><br><span class="line">  <span class="meta">@Column</span> (name = <span class="string">"TEAM_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> Long id;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//Getter, Setter ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-1-다대일-양방향"><a href="#1-1-다대일-양방향" class="headerlink" title="1.1 다대일 양방향"></a>1.1 다대일 양방향</h5><p>양방향 연관관계는 항상 서로 참조해야합니다. 서로 참조하게 하려면 연관관계 편의 메소드를 작성하는게 좋습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@GeneratedValue</span></span><br><span class="line">  <span class="meta">@Column</span> (name = <span class="string">"MEMBER_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> Long id;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String username;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@ManyToOne</span></span><br><span class="line">  <span class="meta">@JoinColum</span> (name = <span class="string">"TEAM_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> Team team;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTeam</span><span class="params">(Team team)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.team = team;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//무한 루프에 빠지지 않도록 체크</span></span><br><span class="line">    <span class="keyword">if</span>(!team.getMembers().contains(<span class="keyword">this</span>))&#123;</span><br><span class="line">      team.getMembers().add(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Team</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@GeneratedValue</span></span><br><span class="line">  <span class="meta">@Column</span> (name = <span class="string">"TEAM_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> Long id;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@OneToMany</span> (mappedBy = <span class="string">"team"</span>)</span><br><span class="line">  <span class="keyword">private</span> List&lt;Member&gt; members = <span class="keyword">new</span> ArrayList&lt;Member&gt;();</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMember</span><span class="params">(Member member)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.members.add(member);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//무한 루프에 빠지지 않도록 체크</span></span><br><span class="line">    <span class="keyword">if</span>(member.getTeam() != <span class="keyword">this</span>)&#123;</span><br><span class="line">      member.setTeam(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//Getter, Setter ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-일대다"><a href="#2-일대다" class="headerlink" title="2. 일대다"></a>2. 일대다</h4><h5 id="일대다-단방향"><a href="#일대다-단방향" class="headerlink" title="일대다 단방향"></a>일대다 단방향</h5><p>일대다 단방향은 약간 특이합니다. 일대다 관계에서, 외래 키는 항상 다쪽 테이블에 있습니다. 하지만 다 쪽인 Memebr 엔티티에는 외래 키를 매핑할 수 있는 참조 필드가 없습니다. 대신에, Team 엔티티에는 참조 필드인 members 가 있습니다. 따라서 반대편 테이블의 외래키를 관리하는 특이한 모습이 나타납니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Team</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@GeneratedValue</span></span><br><span class="line">  <span class="meta">@Column</span> (name = <span class="string">"TEAM_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> Long id;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@OneToMany</span></span><br><span class="line">  <span class="meta">@JoinColum</span> (name = <span class="string">"TEAM_ID"</span>) <span class="comment">//MEMBER 테이블의 TEAM_ID (FK)</span></span><br><span class="line">  <span class="keyword">private</span> List&lt;Member&gt; members = <span class="keyword">new</span> ArrayList&lt;Member&gt;();</span><br><span class="line">   </span><br><span class="line">  <span class="comment">//Getter, Setter ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@GeneratedValue</span></span><br><span class="line">  <span class="meta">@Column</span> (name = <span class="string">"MEMBER_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> Long id;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String username;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//Getter, Setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>일대다 단방향 매핑의 단점<ul>
<li>매핑한 객체가 관리하는 외래 키가 다른 테이블에 있다는 점입니다.</li>
<li>연관관계 처리를 위한 UPDATE SQL 을 추가로 실행해야합니다.</li>
<li>다음 코드에서, Member 엔티티는 Team 엔티티를 모릅니다. 따라서 Member 엔티티를 저장할 때는 Member 테이블의 TEAM_ID 외래키에 아무 값도 저장되지 않습니다. 대신, Team 엔티티를 저장할 때 Team.members 의 참조 값을 확인해서 회원 테이블에 있는 TEAM_ID 외래 키를 업데이트 합니다.</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSave</span><span class="params">()</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  Member member1 = <span class="keyword">new</span> Member(<span class="string">"member1"</span>);</span><br><span class="line">  Member member2 = <span class="keyword">new</span> Member(<span class="string">"member2"</span>);</span><br><span class="line">  </span><br><span class="line">  Team team1 = <span class="keyword">new</span> Team(<span class="string">"team1"</span>);</span><br><span class="line">  team1.getMembers().add(member1);</span><br><span class="line">  team1.getMembers().add(member2);</span><br><span class="line">  </span><br><span class="line">  em.persist(member1); <span class="comment">//INSERT-member1</span></span><br><span class="line">  em.persist(member2); <span class="comment">//INSERT-member2</span></span><br><span class="line">  em.persist(team1);   <span class="comment">//INSERT-team1, UPDATE-member.fk, UPDATE-member2.fk</span></span><br><span class="line">  </span><br><span class="line">  transaction.commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>따라서, 일대다 단방향 매핑보다는 다대일 양방향 매핑을 권장합니다.</p>
<h5 id="일대다-양방향"><a href="#일대다-양방향" class="headerlink" title="일대다 양방향"></a>일대다 양방향</h5><p>둘 다 같은 키를 관리하므로 문제가 발생할 수 있습니다. 따라서, 반대편인 다대일 쪽은 insertable =false, update = false 를 설정해서 읽기만 가능하게 합니다. 되록, 다대일 양방향 매핑을 사용해야합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Team</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@GeneratedValue</span></span><br><span class="line">  <span class="meta">@Column</span> (name = <span class="string">"TEAM_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> Long id;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@OneToMany</span></span><br><span class="line">  <span class="meta">@JoinColum</span> (name = <span class="string">"TEAM_ID"</span>) </span><br><span class="line">  <span class="keyword">private</span> List&lt;Member&gt; members = <span class="keyword">new</span> ArrayList&lt;Member&gt;();</span><br><span class="line">   </span><br><span class="line">  <span class="comment">//Getter, Setter ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@GeneratedValue</span></span><br><span class="line">  <span class="meta">@Column</span> (name = <span class="string">"MEMBER_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> Long id;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String username;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@ManyToOne</span></span><br><span class="line">  <span class="meta">@JoinColumn</span>( name = <span class="string">"TEAM_ID"</span>, insertable =<span class="keyword">false</span>, update = <span class="keyword">false</span>)</span><br><span class="line">  <span class="keyword">private</span> Team team;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//Getter, Setter ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-일대일"><a href="#3-일대일" class="headerlink" title="3. 일대일"></a>3. 일대일</h4><p>일대일 관계는 주 테이블이나 대상 테이블 중에 누가 외래키를 가질지 선택해야합니다.</p>
<h5 id="3-1-주-테이블에-외래-키"><a href="#3-1-주-테이블에-외래-키" class="headerlink" title="3.1 주 테이블에 외래 키"></a>3.1 주 테이블에 외래 키</h5><p>객체지향 개발자들은 주 테이블에 외래 키가 있는 것을 선호합니다. </p>
<ul>
<li>단방향</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@GeneratedValue</span></span><br><span class="line">  <span class="meta">@Column</span> (name = <span class="string">"MEMBER_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> Long id;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String username;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@OneToOne</span></span><br><span class="line">  <span class="meta">@JoinColumn</span>( name = <span class="string">"LOCKER_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> Locker locker;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Locker</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@GeneratedValue</span></span><br><span class="line">  <span class="meta">@Column</span> (name = <span class="string">"LOCKER_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> Long id;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>양방향</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@GeneratedValue</span></span><br><span class="line">  <span class="meta">@Column</span> (name = <span class="string">"MEMBER_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> Long id;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String username;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@OneToOne</span></span><br><span class="line">  <span class="meta">@JoinColumn</span>( name = <span class="string">"LOCKER_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> Locker locker;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Locker</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@GeneratedValue</span></span><br><span class="line">  <span class="meta">@Column</span> (name = <span class="string">"LOCKER_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> Long id;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@OneToOne</span> (mappedBy =<span class="string">"locker"</span>)</span><br><span class="line">  <span class="keyword">private</span> Member member;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-2-대상-테이블에-외래-키"><a href="#3-2-대상-테이블에-외래-키" class="headerlink" title="3.2 대상 테이블에 외래 키"></a>3.2 대상 테이블에 외래 키</h5><ul>
<li>단방향<ul>
<li>일대일 관계 중 대상 테이블에 외래 키가 있는 단방향 관계는 JPA 에서 지원하지 않습니다.</li>
</ul>
</li>
<li>양방향</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@GeneratedValue</span></span><br><span class="line">  <span class="meta">@Column</span> (name = <span class="string">"MEMBER_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> Long id;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String username;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@OneToOne</span> (mappedBy =<span class="string">"member"</span>)</span><br><span class="line">  <span class="keyword">private</span> Locker locker;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Locker</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@GeneratedValue</span></span><br><span class="line">  <span class="meta">@Column</span> (name = <span class="string">"LOCKER_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> Long id;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@OneToOne</span> </span><br><span class="line">  <span class="meta">@JoinColumn</span>(name =<span class="string">"MEMBER_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> Member member;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-다대다"><a href="#4-다대다" class="headerlink" title="4. 다대다"></a>4. 다대다</h4><p>관계형 데이터베이스는 정규화된 테이블 2개를 다대다 관계로 표현할 수 없습니다. 그래서 일대다, 다대일 관계로 풀어내는 연결 테이블을 사용합니다. 그런데 객체는 테이블과 다르게 객체 2개로 다대다 관계를 만들 수 있습니다.</p>
<h5 id="4-1-다대다-단방향"><a href="#4-1-다대다-단방향" class="headerlink" title="4.1 다대다 단방향"></a>4.1 다대다 단방향</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@Column</span> (name = <span class="string">"MEMBER_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> Long id;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String username;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@ManyToMany</span></span><br><span class="line">  <span class="meta">@JoinTable</span>(name = <span class="string">"MEMBER_PRODUCT"</span>, joinColums = <span class="meta">@JoinColumn</span> (name = <span class="string">"MEMBER_ID"</span>),</span><br><span class="line">            inverseJoinColums = <span class="meta">@JoinColumn</span>(name = <span class="string">"PRODUCT_ID"</span>))</span><br><span class="line">  <span class="keyword">private</span> List&lt;Product&gt; products = <span class="keyword">new</span> Arraylist&lt;List&gt;();</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@Column</span> (name = <span class="string">"PRODUCT_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> Long id;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>다음은 다대다 관계를 저장하는 예제입니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">  Product productA = <span class="keyword">new</span> Product();</span><br><span class="line">  productA.setId(<span class="string">"productA"</span>);</span><br><span class="line">  productA.setName(<span class="string">"상품A"</span>);</span><br><span class="line">  em.persist(productA);</span><br><span class="line">  </span><br><span class="line">  Member member1 = <span class="keyword">new</span> Member();</span><br><span class="line">  member1.setId(<span class="string">"member1"</span>);</span><br><span class="line">  member1.setUsername(<span class="string">"회원1"</span>);</span><br><span class="line">  member.getProducts.add(productA);	<span class="comment">//연관관계 설정</span></span><br><span class="line">  em.persist(member1);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이 코드를 실행하면 다음 SQL이 실행됩니다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> PRODUCT...</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> MEMBER...</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> MEMBER_PRODUCT...</span><br></pre></td></tr></table></figure>

<p>다음은 다대다 관계를 탐색하는 예제입니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">find</span><span class="params">()</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  Member member = em.find(Member.class, <span class="string">"member1"</span>);</span><br><span class="line"> 	List&lt;Product&gt; products = member.getProducts(); <span class="comment">//객체 그래프 탐색</span></span><br><span class="line">  <span class="keyword">for</span> (Product product : products)&#123;</span><br><span class="line">    System.out.println(<span class="string">"product.name = "</span> + product.getName());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>member.getProducts() 를 호출해서 상품 이름을 출력하면 다음 SQL이 실행됩니다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> MEMBER_PRODUCT MP</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> PRODUCT P <span class="keyword">ON</span> MP&gt;PRODUCT_ID = P.PRODUCT_ID</span><br><span class="line">WHER MP.MEMBER_ID = ?</span><br></pre></td></tr></table></figure>

<h5 id="4-2-다대다-양방향"><a href="#4-2-다대다-양방향" class="headerlink" title="4.2 다대다 양방향"></a>4.2 다대다 양방향</h5><p>양쪽 중 원하는 곳에 mappedBy 로 연관관계의 주인을 지정합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Id</span> </span><br><span class="line">  <span class="keyword">private</span> Long id;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@ManyTomany</span> (mappedBy = <span class="string">"products"</span>) <span class="comment">//역방향 추가</span></span><br><span class="line">  <span class="keyword">private</span> List&lt;Member&gt; members;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>다대다의 양방향 연관관계는 다음처럼 설정합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">member.getProducts().add(product);</span><br><span class="line">product.getMembers().add(member);</span><br></pre></td></tr></table></figure>

<p>회원 엔티티에 다음 편의 메소드를 추가합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addProduct</span><span class="params">(Product product)</span></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  products.add(product);</span><br><span class="line">  product.getMembers.add(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>역방향 탐색은 다음과 같습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findInverse</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Product product = em.find(Product.class, <span class="string">"productA"</span>);</span><br><span class="line">  List &lt;Member&gt; members = product.getMembers();</span><br><span class="line">  <span class="keyword">for</span> (Member member : members)&#123;</span><br><span class="line">    System.out.println(<span class="string">"member : "</span> + member.getUsername);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-3-다대다-매핑의-한계와-극복-연결-엔티티-사용"><a href="#4-3-다대다-매핑의-한계와-극복-연결-엔티티-사용" class="headerlink" title="4.3 다대다: 매핑의 한계와 극복, 연결 엔티티 사용"></a>4.3 다대다: 매핑의 한계와 극복, 연결 엔티티 사용</h5><p>연결테이블에 컬럼을 추가하면, 더이상 @ManyToMany를 사용할 수 없습니다. 주문 엔티티나 상품 엔티티에는 추가한 칼럼들을 매핑할 수 없기 때문입니다. 따라서, 연결 엔티티를 만들고 이곳에 추가한 칼럼들을 매핑해야합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@Column</span> (name = <span class="string">"MEMBER_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> Long id;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//역방향</span></span><br><span class="line">  <span class="meta">@OneToMany</span> (mappedBy = <span class="string">"member"</span>)</span><br><span class="line">  <span class="keyword">private</span> List&lt;MemberProduct&gt; memberProducts;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@Column</span>(name = <span class="string">"PRODUCT_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> String id;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@IdClass</span> (MemberProductId.class) <span class="comment">//복합 기본키를 매핑</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemberProduct</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 기본키 + 외래키</span></span><br><span class="line">  <span class="meta">@Id</span></span><br><span class="line">  <span class="meta">@ManyToOne</span></span><br><span class="line">  <span class="meta">@JoinColumn</span> (name = <span class="string">"MEMBER_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> Member member; <span class="comment">//MemberProductId.product 와 연결</span></span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Id</span></span><br><span class="line">  <span class="meta">@ManyToOne</span></span><br><span class="line">  <span class="meta">@JoinColumn</span> (name = <span class="string">"PRODUCT_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> Product product; <span class="comment">//MemberProductId.product 와 연결</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> orderAmout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 복합 키를 위한 식별자 클래스</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemberProductId</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String member; <span class="comment">//MemberProduct.member 와 연결</span></span><br><span class="line">  <span class="keyword">private</span> String product; <span class="comment">//MemberProduct.product 와 연결</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//hashCode cand equals ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-4-다대다-새로운-키본-키-사용"><a href="#4-4-다대다-새로운-키본-키-사용" class="headerlink" title="4.4 다대다: 새로운 키본 키 사용"></a>4.4 다대다: 새로운 키본 키 사용</h5><p>추천하는 기본 키 생성 전략은 데이터베이스에서 자동으로 생성해주는 대리 키를 Long 값으로 사용하는 것입니다. </p>
<p>다음은, 연결 테이블에 새로운 기본키를 사용합니다. MemberProduct 보다 Order 이라는 이름으로 합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@GeneratedValue</span></span><br><span class="line">  <span class="meta">@Column</span> (name = <span class="string">"ORDER_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> Long id; </span><br><span class="line">  </span><br><span class="line">  <span class="meta">@ManyToOne</span></span><br><span class="line">  <span class="meta">@JoinColumn</span> (name = <span class="string">"MEMBER_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> Member member;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@ManyToOne</span></span><br><span class="line">  <span class="meta">@JoinColumn</span> (name = <span class="string">"PRODUCT_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> Product product;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> orderAmout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-5-다대다-연관관계-정리"><a href="#4-5-다대다-연관관계-정리" class="headerlink" title="4.5 다대다 연관관계 정리"></a>4.5 다대다 연관관계 정리</h5><p>다대다 관계를 일대다, 다대일 관계로 풀어내기 위해 연결 테이블을 만들 때, 식별자 구성 방법은 다음 두 가지가 있습니다.</p>
<ul>
<li>식별관계<ul>
<li>받아온 식별자를 기본키 + 외래키로 사용</li>
<li>데이터베이스에서는 이를 식별 관계라고 합니다.</li>
</ul>
</li>
<li>비식별 관계<ul>
<li>받아온 식별자는 외래키로만 사용하고 새로운 식별자를 추가</li>
<li>데이터베이스에서는 이를 비식별 관계라고 합니다.</li>
<li>이걸 추천합니다.</li>
</ul>
</li>
</ul>

                    
                        

                    
                    
                        <p>
                            <a href="/2019/03/27/relation-mappings/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
          <li class="pagination-prev">
            <a class="btn btn--default btn--small" href="/archives/2019/">
              <i class="fa fa-angle-left text-base icon-mr"></i>
              <span>NEWER POSTS</span>
            </a>
          </li>
        
        
          <li class="pagination-next">
            <a class="btn btn--default btn--small" href="/archives/2019/page/3/">
              <span>OLDER POSTS</span>
              <i class="fa fa-angle-right text-base icon-ml"></i>
            </a>
          </li>
        
        <li class="pagination-number">page 2 of 3</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2019 junhee.ko. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/profile.jpg" alt="Author&#39;s picture"/>
        
            <h4 id="about-card-name">junhee.ko</h4>
        
            <div id="about-card-bio"><p>Always Learning</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>Engineer</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                Incheon
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/jquery.js"></script>
<script src="/assets/js/jquery.fancybox.js"></script>
<script src="/assets/js/thumbs.js"></script>
<script src="/assets/js/tranquilpeak.js"></script>
<!--SCRIPTS END-->



    </body>
</html>
