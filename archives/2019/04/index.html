
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="junhee.ko">
    <title>Archives: 2019/4 - junhee.ko</title>
    <meta name="author" content="junhee.ko">
    
    
    
    <script type="application/ld+json">{}</script>
    <meta name="description" content="always learning">
<meta property="og:type" content="blog">
<meta property="og:title" content="junhee.ko">
<meta property="og:url" content="https://kojunhee.github.io/archives/2019/04/index.html">
<meta property="og:site_name" content="junhee.ko">
<meta property="og:description" content="always learning">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="junhee.ko">
<meta name="twitter:description" content="always learning">
    
    
        
    
    
        <meta property="og:image" content="https://kojunhee.github.io/assets/images/profile.jpg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/all.css">
    <link rel="stylesheet" href="/assets/css/jquery.fancybox.css">
    <link rel="stylesheet" href="/assets/css/thumbs.css">
    <link rel="stylesheet" href="/assets/css/tranquilpeak.css">
    <!--STYLES END-->
    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="2">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a class="header-title-link" href="/ ">junhee.ko</a>
    </div>
    
        
            <a  class="header-right-picture "
                href="#about">
        
        
            <img class="header-picture" src="/assets/images/profile.jpg" alt="Author&#39;s picture"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="2">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a href="/#about">
                    <img class="sidebar-profile-picture" src="/assets/images/profile.jpg" alt="Author&#39;s picture"/>
                </a>
                <h4 class="sidebar-profile-name">junhee.ko</h4>
                
                    <h5 class="sidebar-profile-bio"><p>Always Learning</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/ "
                            
                            title="Home"
                        >
                    
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-categories"
                            
                            title="Categories"
                        >
                    
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-archives"
                            
                            title="Archives"
                        >
                    
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Archives</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://github.com/kojunhee" target="_blank" rel="noopener" title="GitHub">
                    
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://facebook.com/kojunheee" target="_blank" rel="noopener" title="Facebook">
                    
                        <i class="sidebar-button-icon fab fa-facebook" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Facebook</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://www.linkedin.com/in/junheeko" target="_blank" rel="noopener" title="LinkedIn">
                    
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="mailto:junheee.ko@gmail.com" target="_blank" rel="noopener" title="Mail">
                    
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="2"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2019/04/21/spring-data-jpa/">
                            [자바 ORM 표준 JPA 프로그래밍] 12장_스프링 데이터 JPA
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-04-21T00:00:00+09:00">
	
		    Apr 21, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/jpa/">JPA</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>데이터 접근 계층 (Data Access Layer) 는 CRUD 로 불리는 등록, 수정, 삭제, 조회 코드를 반복해서 개발해야 합니다. JPA 를 사용해서 데이터 접근 계층을 개발할 때도 문제가 발생합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemberRepository</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@PersistenceContext</span></span><br><span class="line">  EntityManager em;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(Member member)</span> </span>&#123;...&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Member <span class="title">findOne</span><span class="params">(Long id)</span> </span>&#123;...&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Member&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Member <span class="title">findByUsername</span><span class="params">(String username)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ItemRepository</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@PersistenceContext</span></span><br><span class="line">  EntityManager em;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(Item item)</span> </span>&#123;...&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Member <span class="title">findOne</span><span class="params">(Long id)</span> </span>&#123;...&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Member&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위 코드를 보면, 회원 리포지토리와 상품 리포지토리가 하는 일이 비슷합니다. 이 문제를 해결하려면 제네릭과 상속을 적절히 사용해서 공통 부분을 처리하는 부모 클래스를 만들면 됩니다. 이것을 보통 GenericDAO 라고 합니다. 하지만 이것은, 공통 기능을 구렿낳ㄴ 부모 클래스에 종속되고 구현 클래스 상속이 가지는 단점이 있습니다. </p>
<h4 id="12-1-스프링-데이터-JPA-소개"><a href="#12-1-스프링-데이터-JPA-소개" class="headerlink" title="12.1 스프링 데이터 JPA 소개"></a>12.1 스프링 데이터 JPA 소개</h4><p>스프링 데이터 JPA 는 스프링 프레임워크에서 JPA 를 편리하게 사용할수 있도록 지원하는 프로젝트입니다. 이 프로젝트는 데이터 접근 계층을 개발할 때 지루하게 반복되는 CRUD 문제를 세련된 방법으로 해결합니다. 데이터 접근 계층을 개발할 때 구현 클래스 없이 인터페이스만 작성해도 개발을 완료할 수있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MemberRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Member</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function">Member <span class="title">findByUsername</span><span class="params">(String username)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ItemRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Item</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>회원과 상품 리포지토리 구현체는 애플리케이션 실행 시점에 스프링 데이터 JPA가 생성해서 주입해줍니다. 즉, 개발자가 직접 구현체를 개발하지 않아도 됩니다.</p>
<p>일반적인 CRUD 메소드는 JpaRepository 인터페이스가 공통으로 제공하지만, MemberRepository.findByUsername(…) 처럼 직접 작성한 공통으로 처리할 수 없는 메소드는 스프링 데이터 JPA 가 메소드 이름을 분석해서 JPQL 을 실행합니다.</p>
<h5 id="12-1-1-스프링-데이터-프로젝트"><a href="#12-1-1-스프링-데이터-프로젝트" class="headerlink" title="12.1.1 스프링 데이터 프로젝트"></a>12.1.1 스프링 데이터 프로젝트</h5><p><img src="/image/spring-data-jpa.png" alt></p>
<p>스프링 데이터 JPA 프로젝트는 JPA에 특화된 기능을 제공합니다. 스프링 프레임워크 + JPA 를 사용한다면, 스프링 데이터 JPA 를 추천합니다.</p>
<h4 id="12-2-스프링-데이터-JPA-설정"><a href="#12-2-스프링-데이터-JPA-설정" class="headerlink" title="12.2 스프링 데이터 JPA 설정"></a>12.2 스프링 데이터 JPA 설정</h4><ul>
<li>필요 라이브러리</li>
<li>환경 설정</li>
</ul>
<h4 id="12-3-공통-인터페이스-기능"><a href="#12-3-공통-인터페이스-기능" class="headerlink" title="12.3 공통 인터페이스 기능"></a>12.3 공통 인터페이스 기능</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JpaRepository 공통 기능 인터페이스</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">JpaRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span> <span class="keyword">extends</span> <span class="title">Serializable</span>&gt; <span class="keyword">extends</span> <span class="title">PagingAndSortingRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JpaRepository 를 사용하는 인터페이스</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MemberRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Member</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JpaRepsitory 인터페이스의 계층 구조는 다음과 같습니다.</p>
<p><img src="/image/spring-data-jpa-inheritance.png" alt></p>
<h4 id="12-4-쿼레-메소드-기능"><a href="#12-4-쿼레-메소드-기능" class="headerlink" title="12.4 쿼레 메소드 기능"></a>12.4 쿼레 메소드 기능</h4><p>스프링 데이터 JPA 가 제공하는 쿼리 메소드 기능은 크게 3가지입니다.</p>
<ul>
<li>메소드 이름으로 쿼리 생성</li>
<li>메소드 이름으로 JPA NamedQuery 호출</li>
<li>@Query 어노테이션을 사용해서 리포지토리 인터페이스에 쿼리 직접 정의</li>
</ul>
<h5 id="12-4-1-메소드-이름으로-쿼리-생성"><a href="#12-4-1-메소드-이름으로-쿼리-생성" class="headerlink" title="12.4.1 메소드 이름으로 쿼리 생성"></a>12.4.1 메소드 이름으로 쿼리 생성</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MemberRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">Member</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function">List&lt;Member&gt; <span class="title">findByEmailAndName</span> <span class="params">(String email, String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>findByEmailAndName(…) 를 실행하면 스프링 데이터 JPA 는 메소드 이름을 분석해서 다음 JPQL을 생성하고 실행합니다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> m <span class="keyword">from</span> <span class="keyword">Member</span> m <span class="keyword">where</span> m.email = ?<span class="number">1</span> <span class="keyword">and</span> m.name =?<span class="number">2</span></span><br></pre></td></tr></table></figure>

<h5 id="12-4-2-JPA-NamedQuery"><a href="#12-4-2-JPA-NamedQuery" class="headerlink" title="12.4.2 JPA NamedQuery"></a>12.4.2 JPA NamedQuery</h5><p>스프링 데이터 JPA 는 메소드 이름으로 JPA Named 쿼리를 호출하는 기능을 제공합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@NamedQuery</span>&#123;</span><br><span class="line">  name = <span class="string">"Member.findByUsername"</span>,</span><br><span class="line">  query = <span class="string">"select m from Member m where m.username = :username"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이렇게 정의한 Named 쿼리를 다음과 같이 호출합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JPA를 직접 사용해서 Named Query 호출</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemberRepository</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Member&gt; <span class="title">findByUserName</span><span class="params">(String username)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    List&lt;Member&gt; resultList =</span><br><span class="line">      	em.createNaemdQuery(<span class="string">"Member.findByUsername"</span>, Member.class)</span><br><span class="line">      	  .setParameter(<span class="string">"username"</span>, <span class="string">"회원1"</span>)</span><br><span class="line">          .getResultList();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 스프링 데이터 JPA 로 호출</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MemberRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span> &lt;<span class="title">Member</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">  List &lt;Member&gt; findByUserName(<span class="meta">@Param</span>(<span class="string">"username"</span>) String username);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>스프링 데이터 JPA 로 호출하는 경우, “도메인 클래스.메소드이름” 으로 Named Query 를 찾아서 실행합니다. 위 예제는, Member.findByUsername 이라는 Named Query 를 실행합니다. 만약, Named Query 가 없으면 메소드 이름으로 쿼리 생성 전략을 사용합니다.</p>
<h5 id="12-4-3-Query-리포지토리-메소드에-쿼리-정의"><a href="#12-4-3-Query-리포지토리-메소드에-쿼리-정의" class="headerlink" title="12.4.3 @Query, 리포지토리 메소드에 쿼리 정의"></a>12.4.3 @Query, 리포지토리 메소드에 쿼리 정의</h5><p>실행할 메소드에 직접 정적 쿼리를 작성하므로, 이름 없는 Named Query 라고 할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MemberRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Member</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@Query</span>(<span class="string">"select m from Member m where m.username = ?1"</span>)</span><br><span class="line">  <span class="function">Member <span class="title">findByUserName</span><span class="params">(String username)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="12-4-4-파라미터-바인딩"><a href="#12-4-4-파라미터-바인딩" class="headerlink" title="12.4.4 파라미터 바인딩"></a>12.4.4 파라미터 바인딩</h5><p>스프링 데이터 JPA 는 위치 기반 파라미터 바인딩과 이름 기반 파라미터 바인딩을 모두 지원합니다. 다음은 이름 기반 파라미터 바인딩 예제입니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MemberRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Member</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@Query</span>(<span class="string">"select m from Member m where m.username = :name"</span>)</span><br><span class="line">  <span class="function">Member <span class="title">findByUserName</span><span class="params">(@Param(<span class="string">"name"</span>)</span> String username)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="12-4-5-벌크성-수정-쿼리"><a href="#12-4-5-벌크성-수정-쿼리" class="headerlink" title="12.4.5 벌크성 수정 쿼리"></a>12.4.5 벌크성 수정 쿼리</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JPA 를 사용한 벌크성 수정 쿼리</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bulkPriceUp</span><span class="params">(String stockAmout)</span></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  String qlString = <span class="string">"update Product p set p.price = p.price * 1.1 where </span></span><br><span class="line"><span class="string">    p.stockAmout &lt; :stockAmout"</span>;</span><br><span class="line">      </span><br><span class="line">  <span class="keyword">int</span> resultCount = em.createQuery(qlString)</span><br><span class="line">      						    .setParameter(<span class="string">"stockAmout"</span>, stockAmout)</span><br><span class="line">                      .executeUpdate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 스프링 데이터 JPA 를 사용한 벌크성 수정 쿼리</span></span><br><span class="line"><span class="meta">@Modifying</span></span><br><span class="line"><span class="meta">@Query</span>(<span class="string">"update Product p set p.price = p.price * 1.1 where </span></span><br><span class="line"><span class="string">    p.stockAmout &lt; :stockAmout"</span>)</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bulkPriceUp</span><span class="params">(@Param(<span class="string">"stockAmout"</span>)</span> String stockAmout)</span>;</span><br></pre></td></tr></table></figure>

<h5 id="12-4-6-반환-타입"><a href="#12-4-6-반환-타입" class="headerlink" title="12.4.6 반환 타입"></a>12.4.6 반환 타입</h5><p>결과가 한건 이상이면 컬렉션 인터페이스, 단건이면 반환 타입을 지정합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;Member&gt; <span class="title">findByName</span> <span class="params">(String name)</span></span>; <span class="comment">//컬렉션</span></span><br><span class="line"><span class="function">Member <span class="title">findByEmail</span> <span class="params">(String email)</span></span>; <span class="comment">//단건</span></span><br></pre></td></tr></table></figure>

<h5 id="12-4-7-페이징과-정렬"><a href="#12-4-7-페이징과-정렬" class="headerlink" title="12.4.7 페이징과 정렬"></a>12.4.7 페이징과 정렬</h5><p>쿼리 메소드에 페이징과 정렬 기능을 사용할 수 있도록 2가지 파라미터를 제공합니다.</p>
<ul>
<li>org.springframework.data.domain.sort</li>
<li>org.springframework.data.domain.Pageable<ul>
<li>파라미터에 Pageable 을 사용하면, 반환타입으로 List 나 org.springframework.data.domain.Page 사용 가능</li>
<li>반환 타입으로 Page 사용하면 검색된 전체 데이터 건수 조회하는 count 쿼리 추가로 호출</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 페이징과 정렬 사용 예제</span></span><br><span class="line"><span class="function">Page&lt;Member&gt; <span class="title">findByName</span><span class="params">(String name, Pageable pageable)</span></span>;</span><br><span class="line"><span class="function">List&lt;Member&gt; <span class="title">findByName</span><span class="params">(String name, Pageable pageable)</span></span>;</span><br><span class="line"><span class="function">List&lt;Member&gt; <span class="title">findByName</span><span class="params">(String name, Sort sort)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Page 사용 예제 정의 코드</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MemberRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">Member</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="function">Page&lt;Member&gt; <span class="title">findByNameStartingWith</span><span class="params">(String name, Pageable pageable)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Page 사용 예제 실행 코드</span></span><br><span class="line">PageRequest pageRequest = <span class="keyword">new</span> PageRequest(<span class="number">0</span>, <span class="number">10</span>, <span class="keyword">new</span> Sort(Direction.DESC, <span class="string">"name"</span>));</span><br><span class="line"></span><br><span class="line">Page&lt;Member&gt; result = memberRepository.findByNameStartingWith(<span class="string">"김"</span>, pageRequest);</span><br><span class="line"></span><br><span class="line">List&lt;Member&gt; members = result.getContent();</span><br><span class="line"><span class="keyword">int</span> totalPage = result.getTotalPages();</span><br><span class="line"><span class="keyword">boolean</span> hasNextPage = result.hasNextPage();</span><br></pre></td></tr></table></figure>

<p>Pageable 은 인터페이스입니다. 실제 사용할 때는 이를 구현한 PageRequest 객체를 사용합니다.</p>
<h5 id="12-4-8-힌트"><a href="#12-4-8-힌트" class="headerlink" title="12.4.8 힌트"></a>12.4.8 힌트</h5><p>SQL 힌트가 아니라 JPA 구현체에게 제공하는 힌트입니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@QueryHints</span>(value = &#123;<span class="meta">@QueryHint</span>(name = <span class="string">"org.hibernate.readOnly"</span>,</span><br><span class="line">                                value = <span class="string">"true"</span>)&#125;, forCounting = <span class="keyword">true</span>)</span><br><span class="line"><span class="function">Page&lt;Member&gt; <span class="title">findByName</span> <span class="params">(String name, Pagable pageable)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="12-4-9-Lock"><a href="#12-4-9-Lock" class="headerlink" title="12.4.9 Lock"></a>12.4.9 Lock</h5><h4 id="12-5-명세"><a href="#12-5-명세" class="headerlink" title="12.5 명세"></a>12.5 명세</h4><p>도메인 주도 설계에서 명세라는 개념을 소개하는데, 스프링 데이터 JPA 는 JPA Criteria 로 이 개념을 사용할 수 있습니다.</p>
<p>명세를 이해하기 위한 핵심 단어는 술어입니다. 이것은 단순히 참이나 거짓으로 평가됩니다. 스프링 데이터 JPA 는 이 술어를 org.springframework.data.jpa.domain.Specification 클래스로 정의했습니다. Specification 은 컴포지트 패턴으로 구성되어 있어서 여러 Specification 으로 조합할 수 있습니다.즉, 다양한 검색 조건을 조립해서 새로운 검색 조건을 쉽게 만들 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JpaSpecificationExecutor 상속</span></span><br><span class="line">pubilc <span class="class"><span class="keyword">interface</span> <span class="title">OrderRepsitroy</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Order</span>, <span class="title">Long</span>&gt;, <span class="title">JpaSpecificationExecutor</span>&lt;<span class="title">Order</span>&gt;</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JpaSpecificationExecutor 인터페이스</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">JpaSpecificationExecutor</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function">T <span class="title">findOne</span> <span class="params">(Specification&lt;T&gt; spec)</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 명세 사용 코드</span></span><br><span class="line"><span class="comment">// Specification 은 명세들을 조립할 수 있도록 도와주는 클래스인데, </span></span><br><span class="line"><span class="comment">// where(), and(), or(), not() 메소드를 제공</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Order&gt; <span class="title">findOrders</span> <span class="params">(String name)</span> </span>&#123;</span><br><span class="line">  List&lt;Order&gt; result = orderRepository.findAll(</span><br><span class="line">  				where(memberName(name)).and(isOrderStatus())</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="12-6-사용자-정의-리포지토리-구현"><a href="#12-6-사용자-정의-리포지토리-구현" class="headerlink" title="12.6 사용자 정의 리포지토리 구현"></a>12.6 사용자 정의 리포지토리 구현</h4><p>스프링 데이터 JPA 로 리포지토리를 개발하면 인터페이스만 정의하고 구현체는 만들지 않습니다. 하지만, 다양한 이유로 메소드를 직접 구현해야 할 때도 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 사용자 정의 인터페이스</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MemberRepositoryCustom</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Member&gt; <span class="title">findMemberCustom</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 사용자 정의 구현 클래스</span></span><br><span class="line"><span class="comment">// 클래스 이름 짓는 규칙 : 리포지토리 인터페이스 이름 + Impl</span></span><br><span class="line"><span class="comment">// 이렇게 하면 스프링 데이터 JPA 가 사용자 정의 구현 클래스로 인식</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemberRepositoryImpl</span> <span class="keyword">implements</span> <span class="title">MemberRepositoryCustom</span></span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Member&gt; <span class="title">findMemberCustom</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 사용자 정의 구현</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 사용자 정의 인터페이스 상속</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MemberRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Member</span>, <span class="title">Long</span>&gt;, <span class="title">MemberRepositoryCustom</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="12-7-Web-확장"><a href="#12-7-Web-확장" class="headerlink" title="12.7 Web 확장"></a>12.7 Web 확장</h4><p>스프링 데이터 프로젝트는 스프링 MVC 에서 사용할 수 있는 기능을 제공합니다.</p>
<ul>
<li>식별자로 도메인 클래스를 바로 바인딩 해주는 도메인 클래스 컨버터 기능</li>
<li>페이징과 정렬 기능</li>
</ul>
<h5 id="12-7-1-설정"><a href="#12-7-1-설정" class="headerlink" title="12.7.1 설정"></a>12.7.1 설정</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="meta">@EnableSpringDataWebSupport</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebAppConfig</span></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>설정을 완료하면, 도메인 클래스 컨버터와 페이징과 정렬을 위한 HandlerMethodArgumentResolver 가 스프링 빈으로 등록됩니다.</p>
<h5 id="12-7-2-도메인-클래스-컨버터-기능"><a href="#12-7-2-도메인-클래스-컨버터-기능" class="headerlink" title="12.7.2 도메인 클래스 컨버터 기능"></a>12.7.2 도메인 클래스 컨버터 기능</h5><p>도메인 클래스 컨버터는 HTTP 파라미터로 넘어온 엔티티의 아이디로 엔티티 객체를 찾아서 바인딩해줍니다.</p>
<h5 id="12-7-3-페이징과-정렬-기능"><a href="#12-7-3-페이징과-정렬-기능" class="headerlink" title="12.7.3 페이징과 정렬 기능"></a>12.7.3 페이징과 정렬 기능</h5><p>스프링 데이터가 제공하는 페이징과 정렬 기능을 스프링 MVC 에서 편리하게 사용할 수 있도록 HandlerMethodArgumentResolver 를 제공합니다. </p>
<h4 id="12-8-스프링-데이터-JPA-가-사용하는-구현체"><a href="#12-8-스프링-데이터-JPA-가-사용하는-구현체" class="headerlink" title="12.8 스프링 데이터 JPA 가 사용하는 구현체"></a>12.8 스프링 데이터 JPA 가 사용하는 구현체</h4><p>스프링 데이터 JPA 가 제공하는 공통 인터페이스는 org.springframework.data.jpa.repository.support.SimpleJpaRepository 클래스가 구현합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="meta">@Transactional</span>(readOnly = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleJpaRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span> <span class="keyword">extends</span> <span class="title">Serializable</span>&gt; <span class="keyword">implements</span> <span class="title">JpaRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt;, <span class="title">JpaSpecificationExecutor</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
                    
                        

                    
                    
                        <p>
                            <a href="/2019/04/21/spring-data-jpa/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2019/04/17/jpql/">
                            [자바 ORM 표준 JPA 프로그래밍] 10장_객체지향 쿼리 언어
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-04-17T00:00:00+09:00">
	
		    Apr 17, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/jpa/">JPA</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>10 장에서 다루는 내용입니다.</p>
<ul>
<li>객체지향 쿼리 소개</li>
<li>Criteria</li>
<li>QueryDSL</li>
<li>Native SQL</li>
<li>객체지향 쿼리 심화</li>
</ul>
<h4 id="10-1-객체지향-쿼리-소개"><a href="#10-1-객체지향-쿼리-소개" class="headerlink" title="10.1 객체지향 쿼리 소개"></a>10.1 객체지향 쿼리 소개</h4><p>EntityMangager.find() 메서드를 사용하면 식별자로 엔티티 하나를 조회하고, 조회한 엔티티에 객체 그래프 탐색을 사용해서 연관된 엔티티를 찾을 수 있습니다.</p>
<ul>
<li>식별자로 조회 : EntityMangager.find()</li>
<li>객체 그래프 탐색 : a.getB().getC()</li>
</ul>
<p>만약 30살 이상인 회원을 모두 검색하고 싶으면 ? 모든 엔티티를 메모리에 올려두고 검색하는 것은 현실적이지 않습니다. 결국 데이터는 DB에 있으므로 SQL 로 최대한 걸러야합니다. 하지만 ORM 을 사용하면 DB table 이 아닌, 엔티티 객체를 대상으로 검색하므로 검색도 테이블이 아닌 엔티티 객체를 대상으로 하는 방법이 필요합니다. 그래서 만들어진 것이 JPQL 입니다. </p>
<p>다음은, 검색 방법으로 JPA 가 공식 지원하는 기능입니다.</p>
<ul>
<li>JPQL (Java Persistence Query Language)</li>
<li>Criteria Query</li>
<li>Native SQL</li>
</ul>
<p>다음은, JPA 가 공식 지원하는 기능은 아니지만 알아둘 가치가 있습니다.</p>
<ul>
<li>QueryDSL</li>
<li>JDBC 직접 사용 / MyBatis 같은 SQL Mapper 프레임워크 사용</li>
</ul>
<h5 id="10-1-1-JPQL-소개"><a href="#10-1-1-JPQL-소개" class="headerlink" title="10.1.1 JPQL 소개"></a>10.1.1 JPQL 소개</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String jpql = <span class="string">"select m from Member as m where m.username = 'kim'"</span>;</span><br><span class="line">List&lt;Member&gt; resultList = em.createQuery(jpql, Member.class).getResultList();</span><br></pre></td></tr></table></figure>

<h5 id="10-1-2-Criteria-Query-소개"><a href="#10-1-2-Criteria-Query-소개" class="headerlink" title="10.1.2 Criteria Query 소개"></a>10.1.2 Criteria Query 소개</h5><p>JPQL을 생성하는 빌더 클래스입니다. 문자가 아닌, query.select(m).where(…) 처럼 프로그래밍 코드로 JPQL을 작성할 수 있습니다.</p>
<p>장점은 다음과 같습니다.</p>
<ul>
<li>컴파일 시점에 오류 발견</li>
<li>IDE를 사용하면 코드 자동 완성 지원</li>
<li>동적 쿼리 작성 편이</li>
</ul>
<p>하지만, 복잡하고 장황해서 Criteria 로 작성한 코드가 한눈에 들어오지 않는 단점이 있습니다.</p>
<h5 id="10-1-3-QueryDSL-소개"><a href="#10-1-3-QueryDSL-소개" class="headerlink" title="10.1.3 QueryDSL 소개"></a>10.1.3 QueryDSL 소개</h5><p>Criteria 처럼 JPQL 빌더 역할을 합니다. Criteria 에 비해, 작성한 코드가 한눈에 들어오고 단순하고 사용하기 쉽습니다.</p>
<p>JPA 표준이 아니고 오픈 소스 프로젝트입니다. JPA 뿐만 아니라, JDO, MongoDB, Java Collection, Lucene, Hibernate Search 도 거의 같은 문법으로 지원합니다.</p>
<h5 id="10-1-4-Native-SQL"><a href="#10-1-4-Native-SQL" class="headerlink" title="10.1.4 Native SQL"></a>10.1.4 Native SQL</h5><p>SQL 을 직접 사용하는 기능입니다. 그래서, 데이터베이스를 변경하면 네이티브 SQL 로 수정해야합니다.</p>
<h5 id="10-1-5-JDBC-직접-사용-MyBatis-같은-SQL-Mapper-프레임워크-사용"><a href="#10-1-5-JDBC-직접-사용-MyBatis-같은-SQL-Mapper-프레임워크-사용" class="headerlink" title="10.1.5 JDBC 직접 사용 / MyBatis 같은 SQL Mapper 프레임워크 사용"></a>10.1.5 JDBC 직접 사용 / MyBatis 같은 SQL Mapper 프레임워크 사용</h5><p>JDBC connection 에 직접 접근하고 싶으면, JPA는 JDBC connection 을 획득하는 API 를 제공하지 않으므로, JPA 구현체가 제공하는 방법을 사용해야 합니다.</p>
<h4 id="10-2-JPQL"><a href="#10-2-JPQL" class="headerlink" title="10.2 JPQL"></a>10.2 JPQL</h4><p>1절에서 엔티티를 쿼리하는 다양한 방법을 소개했지만, 어떤 방법을 사용하든 JPQL 에서 모든 것이 시작합니다. 다음은 JPQL의 특징입니다.</p>
<ul>
<li>객체지향 쿼리 언어입니다. 엔티티 객체를 대상으로 쿼리합니다.</li>
<li>특정 데이터베이스에 SQL 에 의존하지 않습니다.</li>
<li>JPQL 도 결국 SQL 로 변환됩니다.</li>
</ul>
<h5 id="10-2-1-기본-문법과-쿼리-API"><a href="#10-2-1-기본-문법과-쿼리-API" class="headerlink" title="10.2.1 기본 문법과 쿼리 API"></a>10.2.1 기본 문법과 쿼리 API</h5><p>EntityManger.persist() 메소드를 사용하면 되기 때문에 INSERT 문은 없습니다.</p>
<h6 id="SELECT-문"><a href="#SELECT-문" class="headerlink" title="SELECT 문"></a>SELECT 문</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT m FROM Member AS m where m.username = <span class="string">'Hello'</span></span><br></pre></td></tr></table></figure>

<h6 id="TypeQuery-Query"><a href="#TypeQuery-Query" class="headerlink" title="TypeQuery, Query"></a>TypeQuery, Query</h6><p>반환할 타입을 명확히 지정할 수 있으면 <strong>TypeQuery</strong>, 반환할 타입을 명확히 지정할 수 없으면 <strong>Query</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TypeQuery&lt;Member&gt; query = em.createQuery(<span class="string">"SELECT m FROM Member AS m"</span>, Member.class);</span><br><span class="line"></span><br><span class="line">Query query = em.createQuery(<span class="string">"SELECT m.username¸ m.age FROM Member AS m"</span>);</span><br></pre></td></tr></table></figure>

<h6 id="결과-조회"><a href="#결과-조회" class="headerlink" title="결과 조회"></a>결과 조회</h6><p>다음 메소드를 호출하면 실제 쿼리를 실행해서 데이터베이스를 조회합니다.</p>
<ul>
<li>query.getResultList()</li>
<li>query.getSingleResult() </li>
</ul>
<h5 id="10-2-2-파라미터-바인딩"><a href="#10-2-2-파라미터-바인딩" class="headerlink" title="10.2.2 파라미터 바인딩"></a>10.2.2 파라미터 바인딩</h5><h6 id="이름-기준-파리미터"><a href="#이름-기준-파리미터" class="headerlink" title="이름 기준 파리미터"></a>이름 기준 파리미터</h6><p>위치 기준 파라미터 바인딩 방식보다 명확합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String usernameparam = <span class="string">"user1"</span>;</span><br><span class="line"></span><br><span class="line">TypeQuery&lt;Member&gt; query = em.createQuery(<span class="string">"SELECT m FROM Member m where m.username = :username"</span>, Member.class);</span><br><span class="line"></span><br><span class="line">query.setParameter(<span class="string">"username"</span>, usernameparam);</span><br></pre></td></tr></table></figure>

<h6 id="위치-기준-파라미터"><a href="#위치-기준-파라미터" class="headerlink" title="위치 기준 파라미터"></a>위치 기준 파라미터</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String usernameparam = <span class="string">"user1"</span>;</span><br><span class="line"></span><br><span class="line">List&lt;Member&gt; members = em</span><br><span class="line">.createQuery(<span class="string">"SELECT m FROM Member m where m.username = ?1"</span>, Member.class)</span><br><span class="line">.setParameter(<span class="number">1</span>, usernameParam)</span><br><span class="line">.getResultList();</span><br></pre></td></tr></table></figure>

<h5 id="10-2-3-프로젝션"><a href="#10-2-3-프로젝션" class="headerlink" title="10.2.3 프로젝션"></a>10.2.3 프로젝션</h5><p>SELECT 절에 조회할 대상을 지정하는 것입니다. </p>
<ul>
<li>엔티티 프로젝션<ul>
<li>조회한 엔티티는 영속성 컨텍스트에서 관리됩니다.</li>
</ul>
</li>
<li>임베디드 타입 프로젝션<ul>
<li>임베디드 타입은 값 타입입니다. 따라서, 조회한 임베디드 타입은 영속성 컨텍스트에서 관리되지 않습니다.</li>
</ul>
</li>
<li>스칼라 타입 프로젝션<ul>
<li>기본 데이터타입입니다.</li>
<li>SELECT username…. / SELECT AVG(o.orderAmout)…</li>
</ul>
</li>
<li>여러 값 조회<ul>
<li>꼭 필요한 데이터들만 조회하는 경우입니다.</li>
</ul>
</li>
<li>New 명령어<ul>
<li>반환 받을 클래스를 지정하여 이 클래스의 생성장에 JPQL 조회 결과를 넘길 수 있습니다. </li>
<li>TypeQuery 를 사용할 수 있어서 지루한 객체 변환 작업을 줄일 수 있습니다.</li>
</ul>
</li>
</ul>
<h5 id="10-2-4-페이징-API"><a href="#10-2-4-페이징-API" class="headerlink" title="10.2.4 페이징 API"></a>10.2.4 페이징 API</h5><p>페지징을 다음 두 API 로 추상화했습니다.</p>
<ul>
<li>setFirstResult(int startPosition)<ul>
<li>조회 시작 위치</li>
</ul>
</li>
<li>setMaxResults(int maxResult)<ul>
<li>조회할 데이터 수</li>
</ul>
</li>
</ul>
<h5 id="10-2-5-집합과-정렬"><a href="#10-2-5-집합과-정렬" class="headerlink" title="10.2.5 집합과 정렬"></a>10.2.5 집합과 정렬</h5><p>집합은 통계 정보를 구할 때 사용합니다.</p>
<h5 id="10-2-6-JPQL-조인"><a href="#10-2-6-JPQL-조인" class="headerlink" title="10.2.6 JPQL 조인"></a>10.2.6 JPQL 조인</h5><p>SQL 조인과 기능은 같고 문법만 약간 다릅니다.</p>
<h6 id="내부-조인"><a href="#내부-조인" class="headerlink" title="내부 조인"></a>내부 조인</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> m <span class="keyword">FROM</span> <span class="keyword">Member</span> m <span class="keyword">INNER</span> <span class="keyword">JOIN</span> m.team t <span class="keyword">WHERE</span> t.name = :teamName</span><br></pre></td></tr></table></figure>

<h6 id="외부-조인"><a href="#외부-조인" class="headerlink" title="외부 조인"></a>외부 조인</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> m <span class="keyword">FROM</span> <span class="keyword">Member</span> m LEF [<span class="keyword">OUTER</span>] <span class="keyword">JOIN</span> m.team t</span><br></pre></td></tr></table></figure>

<h6 id="컬렉션-조인"><a href="#컬렉션-조인" class="headerlink" title="컬렉션 조인"></a>컬렉션 조인</h6><p>일대다 관계나 다대다 관계처럼 컬렉션을 사용하는 곳에 조인하는 것입니다.</p>
<h6 id="세타-조인"><a href="#세타-조인" class="headerlink" title="세타 조인"></a>세타 조인</h6><p>전혀 관계 없는 엔티티도 조회 할 수 있습니다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(m) </span><br><span class="line"><span class="keyword">from</span> <span class="keyword">Member</span> m, Team t</span><br><span class="line"><span class="keyword">where</span> m.username = t.name</span><br></pre></td></tr></table></figure>

<h6 id="JOIN-ON-절-JPA-2-1"><a href="#JOIN-ON-절-JPA-2-1" class="headerlink" title="JOIN ON  절 (JPA 2.1)"></a>JOIN ON  절 (JPA 2.1)</h6><p>조인 대상을 필터링하고 조인할 수  있습니다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> m, t </span><br><span class="line"><span class="keyword">from</span> <span class="keyword">Member</span> m</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> m.team t <span class="keyword">on</span> t.name = <span class="string">'A'</span></span><br></pre></td></tr></table></figure>

<h5 id="10-2-7-페치-조인"><a href="#10-2-7-페치-조인" class="headerlink" title="10.2.7 페치 조인"></a>10.2.7 페치 조인</h5><p>연관된 엔티티나 컬렉션을 한 번에 같이 조회합니다.</p>
<h6 id="엔티티-페치-조인"><a href="#엔티티-페치-조인" class="headerlink" title="엔티티 페치 조인"></a>엔티티 페치 조인</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> m</span><br><span class="line"><span class="keyword">from</span> <span class="keyword">Member</span> m <span class="keyword">join</span> <span class="keyword">fetch</span> m.team</span><br></pre></td></tr></table></figure>

<h6 id="컬렉션-페치-조인"><a href="#컬렉션-페치-조인" class="headerlink" title="컬렉션 페치 조인"></a>컬렉션 페치 조인</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t</span><br><span class="line"><span class="keyword">from</span> Team t <span class="keyword">join</span> <span class="keyword">fetch</span> t.members</span><br><span class="line"><span class="keyword">where</span> t.name = <span class="string">'팀A'</span></span><br></pre></td></tr></table></figure>

<h6 id="페치-조인과-DISTINCT"><a href="#페치-조인과-DISTINCT" class="headerlink" title="페치 조인과 DISTINCT"></a>페치 조인과 DISTINCT</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> distint t</span><br><span class="line"><span class="keyword">from</span> Team t <span class="keyword">join</span> <span class="keyword">fetch</span> t.members</span><br><span class="line"><span class="keyword">where</span> t.name = <span class="string">'팀A'</span></span><br></pre></td></tr></table></figure>

<h6 id="페치-조인과-일반-조인의-차이"><a href="#페치-조인과-일반-조인의-차이" class="headerlink" title="페치 조인과 일반 조인의 차이"></a>페치 조인과 일반 조인의 차이</h6><p>다음은, 팀만 조회하고 조인했던 회원은 전혀 조회하지 않습니다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t</span><br><span class="line"><span class="keyword">from</span> Team t <span class="keyword">join</span> t.members m</span><br><span class="line"><span class="keyword">where</span> t.name = <span class="string">'팀A'</span></span><br></pre></td></tr></table></figure>

<p>JPQL은 결과를 반환할 때 연관관계까지 고려하지 않습니다. 단지 SELECT 절에 지정한 엔티티만 조회합니다.</p>
<h6 id="페치-조인의-특징과-한계"><a href="#페치-조인의-특징과-한계" class="headerlink" title="페치 조인의 특징과 한계"></a>페치 조인의 특징과 한계</h6><ul>
<li>페치 조인 대상에는 별칠을 줄 수 없습니다.</li>
<li>둘 이상의 컬렉션을 페치할 수 없습니다.</li>
<li>컬렉션을 페치 조인하면 페이징 API를 사용할 수 없습니다.</li>
</ul>
<h5 id="10-2-8-경로-표현식"><a href="#10-2-8-경로-표현식" class="headerlink" title="10.2.8 경로 표현식"></a>10.2.8 경로 표현식</h5><p>. 을 찍어서 객체 그래프를 탐색하는 것입니다.</p>
<ul>
<li>상태 필드<ul>
<li>단순히 값을 저장하기 위한 필드</li>
</ul>
</li>
<li>연관 필드<ul>
<li>객체 사이의 연관 관계를 위한 필드, 임베디드 타입 포함</li>
</ul>
</li>
</ul>
<h6 id="경로-표현식과-특징"><a href="#경로-표현식과-특징" class="headerlink" title="경로 표현식과 특징"></a>경로 표현식과 특징</h6><ul>
<li>상태 필드 경로<ul>
<li>경로 탐색의 끝</li>
</ul>
</li>
<li>단일 값 연관 경로<ul>
<li>묵시적으로 내부조인</li>
<li>계속 탐색 가능</li>
</ul>
</li>
<li>컬렉션 값 연관 경로<ul>
<li>묵시적으로 내부조인</li>
<li>더는 탐색 불가능 (단, FROM 절에서 조인 통해 별칭 얻으면 별칭으로 탐색 가능)</li>
</ul>
</li>
</ul>
<h5 id="10-2-9-서브-쿼리"><a href="#10-2-9-서브-쿼리" class="headerlink" title="10.2.9 서브 쿼리"></a>10.2.9 서브 쿼리</h5><p>WHERE, HAVING 절에서만 사용 가능합니다.</p>
<h6 id="서브-쿼리-함수"><a href="#서브-쿼리-함수" class="headerlink" title="서브 쿼리 함수"></a>서브 쿼리 함수</h6><ul>
<li>EXISTS</li>
<li>ALL|ANY|SOME</li>
<li>IN</li>
</ul>
<h5 id="10-2-10-조건식"><a href="#10-2-10-조건식" class="headerlink" title="10.2.10 조건식"></a>10.2.10 조건식</h5><h5 id="10-2-11-다형성-쿼리"><a href="#10-2-11-다형성-쿼리" class="headerlink" title="10.2.11 다형성 쿼리"></a>10.2.11 다형성 쿼리</h5><p>부모 엔티티를 조회하면 그 자식 엔티티도 함께 조회합니다.</p>
<h5 id="10-2-12-사용자-정의-함수-호출-JPA-2-1"><a href="#10-2-12-사용자-정의-함수-호출-JPA-2-1" class="headerlink" title="10.2.12 사용자 정의 함수 호출 (JPA 2.1)"></a>10.2.12 사용자 정의 함수 호출 (JPA 2.1)</h5><h5 id="10-2-13-기타-정리"><a href="#10-2-13-기타-정리" class="headerlink" title="10.2.13 기타 정리"></a>10.2.13 기타 정리</h5><h5 id="10-2-14-엔티티-직접-사용"><a href="#10-2-14-엔티티-직접-사용" class="headerlink" title="10.2.14 엔티티 직접 사용"></a>10.2.14 엔티티 직접 사용</h5><p>#####10.2.15 Named Query : 정적 쿼리</p>
<p>미리 정의한 쿼리에 이름을 부여해서 필요할 때마다 사용하는 정적인 쿼리입니다.</p>
<h4 id="10-3-Criteria"><a href="#10-3-Criteria" class="headerlink" title="10.3 Criteria"></a>10.3 Criteria</h4><p>Criteria Query 는 JPQL 을 자바 코드로 작성하도록 도와주는 빌더 클래스 API 입니다.</p>
<h4 id="10-4-QueryDSL"><a href="#10-4-QueryDSL" class="headerlink" title="10.4 QueryDSL"></a>10.4 QueryDSL</h4><p>쿼리를 문자가 아닌 코드로 작성해도 쉽고 간결하며 그 모양도 쿼리와 비슷하게 개발할 수 있는 프로젝트입니다. JPA Criteria 를 대체할 수 있습니다. </p>
<h5 id="10-4-1-설정"><a href="#10-4-1-설정" class="headerlink" title="10.4.1 설정"></a>10.4.1 설정</h5><h5 id="10-4-2-시작"><a href="#10-4-2-시작" class="headerlink" title="10.4.2 시작"></a>10.4.2 시작</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queryDSL</span><span class="params">()</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  EntityManager em = emf.createEntityManager();</span><br><span class="line">  </span><br><span class="line">  JPAQuery query = <span class="keyword">new</span> JPAQuery(em);</span><br><span class="line">  QMember qMember = <span class="keyword">new</span> QMember(<span class="string">"m"</span>); <span class="comment">//생성되는 JPQL의 별칭이 m</span></span><br><span class="line">  List&lt;Member&gt; members = </span><br><span class="line">    query.from(qMember)</span><br><span class="line">    		 .where(qMember.name.eq(<span class="string">"회원1"</span>))</span><br><span class="line">    		 .orderBy(qMember.name.desc())</span><br><span class="line">    	   .list(qMember);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="기본-Q-생성"><a href="#기본-Q-생성" class="headerlink" title="기본 Q 생성"></a>기본 Q 생성</h6><p>쿼리 타입(Q) 은 사용하기 편리하도록 기본 인스턴스를 보관하고 있습니다. 하지만, 같은 엔티티를 조인하거나 같은 엔티티를 서브쿼리에 사용하면 같은 별칭이 사용되므로, 별칭을 직접 지정해야합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QMember</span> <span class="keyword">extends</span> <span class="title">EntityPathBase</span>&lt;<span class="title">Member</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> QMember member = <span class="keyword">new</span> QMember(<span class="string">"member1"</span>);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>쿼리 타입은 다음과 같이 사용합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QMember qMember = <span class="keyword">new</span> QMember(<span class="string">"m"</span>); <span class="comment">//직접 지정</span></span><br><span class="line">QMember qMember = QMember.member; 	<span class="comment">//기본 인스턴스 사용</span></span><br></pre></td></tr></table></figure>

<h5 id="10-4-3-검색-조건-쿼리"><a href="#10-4-3-검색-조건-쿼리" class="headerlink" title="10.4.3 검색 조건 쿼리"></a>10.4.3 검색 조건 쿼리</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JPAQuery query = <span class="keyword">new</span> JPAQuery(em);</span><br><span class="line">QItem item = QItem.item;</span><br><span class="line">List&lt;Item&gt; list = query.from(item)</span><br><span class="line">  								     .where(item.name.eq(<span class="string">"goodProduct"</span>).and(item.price.gt(<span class="number">20000</span>)))</span><br><span class="line">  										 .list(item); <span class="comment">//조회할 프로젝션 지정</span></span><br></pre></td></tr></table></figure>

<p>#####10.4.4 결과 조회</p>
<p>쿼리 작성 후에, 결과 조회 메소드를 호출하면 실제 데이터베이스를 조회합니다. 대표적인 결과 조회 메소드는 다음과 같습니다.</p>
<ul>
<li>uniqueResult()<ul>
<li>조회 결과가 한건일 때 사용</li>
</ul>
</li>
<li>singleResult()<ul>
<li>uniqueResult() 와 결과가 같지만, 결과가 하나 이상이면 처음 데이터를 반환</li>
</ul>
</li>
<li>list()<ul>
<li>조회 결과가 하나 이상일 때 사용</li>
</ul>
</li>
</ul>
<p>#####10.4.5 페이징과 정렬</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QItem item = QItem.item;</span><br><span class="line"></span><br><span class="line">query.from(item)</span><br><span class="line">  	 .where(item.price.gt(<span class="number">20000</span>))</span><br><span class="line">     .orderBy(item.price.desc(), item.stockQuantity.asc())</span><br><span class="line">     .offset(<span class="number">10</span>).limit(<span class="number">20</span>)</span><br><span class="line">  	 .list(item)</span><br></pre></td></tr></table></figure>

<p>#####10.4.6 그룹</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">query.from(item)</span><br><span class="line">     .groupBy(item.price)</span><br><span class="line">     .having(item.price.gt(1000))</span><br><span class="line">     .list(item)</span><br></pre></td></tr></table></figure>

<p>#####10.4.7 조인</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">QOrder order = QOrder.order;</span><br><span class="line">QMember member = QMember.member;</span><br><span class="line">QOrderItem orderItem = QOrderItem.orderItem;</span><br><span class="line"></span><br><span class="line">query.from(order)</span><br><span class="line">  .join(order.member, member)</span><br><span class="line">  .leftJoin(order.orderItems, orderItem)</span><br><span class="line">  .list(order);</span><br></pre></td></tr></table></figure>

<p>#####10.4.8 서브 쿼리</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">QItem item = QItem.item;</span><br><span class="line">QItem itemSub = <span class="keyword">new</span> QItem(<span class="string">"itemSub"</span>);</span><br><span class="line"></span><br><span class="line">query.from(item)</span><br><span class="line">     .where(item.price.eq(</span><br><span class="line">     <span class="keyword">new</span> JPASubQuery().from(itemSub).unique(itemSub.price.max())</span><br><span class="line">     ))</span><br><span class="line">     .list(item)</span><br></pre></td></tr></table></figure>

<p>#####10.4.9 프로젝션과 결과 반환</p>
<h6 id="프로젝션-대상이-하나"><a href="#프로젝션-대상이-하나" class="headerlink" title="프로젝션 대상이 하나"></a>프로젝션 대상이 하나</h6><p>프로젝션 대상이 하나면 해당 타입으로 반환합니다.</p>
<h6 id="여러-칼럼-반환과-튜플"><a href="#여러-칼럼-반환과-튜플" class="headerlink" title="여러 칼럼 반환과 튜플"></a>여러 칼럼 반환과 튜플</h6><p>프로젝션 대상으로 여러 필드를 선택하면 QueryDSL 은 기본으로 com.mysema.query.Tuple 이라는 Map 과 비슷한 내부 타입을 사용합니다. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">QItem item = QItem.item;</span><br><span class="line"></span><br><span class="line">List&lt;Tuple&gt; result = query.from(item).list(item.name, item.price);</span><br><span class="line"><span class="comment">// List&lt;Tuple&gt; result = query.from(item).list(new QTuple(item.name, item.price)); 와 같음</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(Tuple tuple : result)&#123;</span><br><span class="line">  System.out.println(<span class="string">"name = "</span> + tuple.get(item.name));</span><br><span class="line">  System.out.println(<span class="string">"name = "</span> + tuple.get(item.price));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="빈-생성"><a href="#빈-생성" class="headerlink" title="빈 생성"></a>빈 생성</h6><p>쿼리 결과를 엔티니가 아닌 특정 객체로 받고 싶으면 빈 생성 기능을 사용합니다. 객체를 생성하는 방법은 다음과 같은 것들이 있습니다.</p>
<ul>
<li>프로퍼티 접근</li>
<li>필드 직접 접근</li>
<li>생성자 사용</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ItemDTO</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String username;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> price;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ItemDTO</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ItemDTO</span><span class="params">(String username, <span class="keyword">int</span> price)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.username = username;</span><br><span class="line">    <span class="keyword">this</span>.price = price;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//GETTER, SETTER ..</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 프로퍼티 접근</span></span><br><span class="line">QItem item = QItem.item;</span><br><span class="line">List&lt;ItemDTO&gt; result = query.from(item).list(</span><br><span class="line">Projections.bean(ItemDTO.class, item.name.as(<span class="string">"username"</span>), item.price));</span><br><span class="line"></span><br><span class="line"><span class="comment">//필드 직접 접근</span></span><br><span class="line">List&lt;ItemDTO&gt; result = query.from(item).list(</span><br><span class="line">Projections.fields(ItemDTO.class, item.name.as(<span class="string">"username"</span>), item.price));</span><br><span class="line"></span><br><span class="line"><span class="comment">//생성자 사용</span></span><br><span class="line">List&lt;ItemDTO&gt; result = query.from(item).list(</span><br><span class="line">Projections.constructor(ItemDTO.class, item.name, item.price));</span><br></pre></td></tr></table></figure>

<h6 id="DISTINCT"><a href="#DISTINCT" class="headerlink" title="DISTINCT"></a>DISTINCT</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">query.distinct().from(item)</span><br></pre></td></tr></table></figure>

<p>#####10.4.10 수정, 삭제, 배치 쿼리</p>
<h5 id="10-4-11-동적-쿼리"><a href="#10-4-11-동적-쿼리" class="headerlink" title="10.4.11 동적 쿼리"></a>10.4.11 동적 쿼리</h5><p>com.mysema.query.BooleanBuilder 를 사용하면 특정 조건에 따른 동적 쿼리를 편리하게 생성할 수 있습니다.</p>
<h5 id="10-4-12-메소드-위임"><a href="#10-4-12-메소드-위임" class="headerlink" title="10.4.12 메소드 위임"></a>10.4.12 메소드 위임</h5><p>쿼리 타입에 검색 조건을 직접 정의할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//검색 조건 정의</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ItemExpression</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@QueryDelegate</span>(Item.class) <span class="comment">// 이 기능을 적용할 엔티티 지정</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> statc BooleanExpression <span class="title">isExpensive</span><span class="params">(QItem item, Integer price)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> item.price.gt(price);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//쿼리 타입에 생성된 결과</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QItem</span> <span class="keyword">extends</span> <span class="title">EntityPathBase</span>&lt;<span class="title">Item</span>&gt; </span>&#123;</span><br><span class="line">  	...</span><br><span class="line">    <span class="keyword">public</span> com.mysema.qeury.types.expr.<span class="function">BooleanExpression <span class="title">isExpensive</span><span class="params">(Integer price)</span></span>&#123;</span><br><span class="line">    		<span class="keyword">return</span> ItemExpression.ixExpensieve(<span class="keyword">this</span>, price);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//메소드 위임 기능 사용</span></span><br><span class="line">query.from(item).where(item.isExpensive(<span class="number">30000</span>)).list(item);</span><br></pre></td></tr></table></figure>

<h4 id="10-5-Native-SQL"><a href="#10-5-Native-SQL" class="headerlink" title="10.5 Native SQL"></a>10.5 Native SQL</h4><p>다양한 이유로 JPQL 을 사용할 수 없을 때 JPA 는 SQL 을 직접 사용할 수 있는 기능을 제공하는데, 이것을 Native SQL 이라고 합니다. 네이티브 SQL 을 사용하면 엔티티를 조회할 수 있고 JPA 가 지원하는 영속성 컨텍스트의 기능을 그대로 사용할 수 있습니다. 반면에 JDBC API 를 직접 사용하면 단순히 데이터의 나열을 조회할 뿐입니다.</p>
<p>네이티브 SQL 도 JPQL 을 사용할 때와 마찬가지로 Query, TypeQuery(Named Native Query 의 경우) 를 반환합니다. 따라서 JPQL API 를 그대로 사용할 수 있습니다.</p>
<h5 id="10-5-1-Native-SQL-사용"><a href="#10-5-1-Native-SQL-사용" class="headerlink" title="10.5.1 Native SQL 사용"></a>10.5.1 Native SQL 사용</h5><p>네이티브 쿼리 API 는 세 가지 입니다.</p>
<ul>
<li>결과 타입 정의</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Query <span class="title">createNativeQuery</span><span class="params">(String sqlString, Class resultClass)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>결과 타임 정의 할 수 없을 때</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Query <span class="title">createNativeQuery</span><span class="params">(String sqlString)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>결과 매핑 사용</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Query <span class="title">createNativeQuery</span><span class="params">(String sqlString, String resultSetMapping)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="10-5-5-스토어드-프로시저"><a href="#10-5-5-스토어드-프로시저" class="headerlink" title="10.5.5 스토어드 프로시저"></a>10.5.5 스토어드 프로시저</h5><p>JPA 2.1 부터 지원합니다.</p>
<h4 id="10-6-객체-지향-쿼리-심화"><a href="#10-6-객체-지향-쿼리-심화" class="headerlink" title="10.6 객체 지향 쿼리 심화"></a>10.6 객체 지향 쿼리 심화</h4><h5 id="10-6-1-벌크-연산"><a href="#10-6-1-벌크-연산" class="headerlink" title="10.6.1 벌크 연산"></a>10.6.1 벌크 연산</h5><p>여러 건을 한번에 수정하거나 삭제할 때 벌크 연산을 사용합니다. 벌크 연산을 사용할 때는 벌크 연산이 영속성 컨텍스트를 무시하고 데이터이스에 직접 쿼리합니다.</p>
<h5 id="10-6-2-영속성-컨텍스트와-JPQL"><a href="#10-6-2-영속성-컨텍스트와-JPQL" class="headerlink" title="10.6.2 영속성 컨텍스트와 JPQL"></a>10.6.2 영속성 컨텍스트와 JPQL</h5><ul>
<li>JPQL은 항상 데이터베이스를 조회합니다.</li>
<li>JPQL로 조회한 엔티티는 영속 상태입니다.</li>
<li>영속성 컨텍스트에 이미 존재하는 엔티티가 있으면 기존 엔티티를 반환합니다.</li>
</ul>
<h5 id="10-6-3-JPQL-과-플러쉬-모드"><a href="#10-6-3-JPQL-과-플러쉬-모드" class="headerlink" title="10.6.3 JPQL 과 플러쉬 모드"></a>10.6.3 JPQL 과 플러쉬 모드</h5>
                    
                        

                    
                    
                        <p>
                            <a href="/2019/04/17/jpql/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2019/04/11/value-type/">
                            [자바 ORM 표준 JPA 프로그래밍] 9장_값 타입
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-04-11T00:00:00+09:00">
	
		    Apr 11, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/jpa/">JPA</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>JPA의 데이터 타입은 엔티티 타입과 값 타입으로 나눌 수 있습니다. 값 타입은 다음 세 가지로 나눌 수 있습니다.</p>
<ul>
<li>기본값 타입<ul>
<li>자바 기본 타입 : int, double …</li>
<li>래퍼 클래스 : Integer …</li>
<li>String</li>
</ul>
</li>
<li>임베디드 타입</li>
<li>컬렉션 값 타입</li>
</ul>
<h4 id="9-1-기본값-타입"><a href="#9-1-기본값-타입" class="headerlink" title="9.1 기본값 타입"></a>9.1 기본값 타입</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span></span>&#123;</span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@GeneratedValue</span></span><br><span class="line">  <span class="keyword">private</span> Long id; <span class="comment">// 기본값 타입</span></span><br><span class="line">  <span class="keyword">private</span> String name; <span class="comment">// 기본값 타입</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> age; <span class="comment">// 기본값 타입</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-2-임베디드-타입-복합-값-타입"><a href="#9-2-임베디드-타입-복합-값-타입" class="headerlink" title="9.2 임베디드 타입 (복합 값 타입)"></a>9.2 임베디드 타입 (복합 값 타입)</h4><p>새로운 값 타입을 직접 지정해서 사용할 수 있습니다. 이것을 JPA 에서는 임베디드 타입이라고 합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span></span>&#123; </span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@GeneratedValue</span></span><br><span class="line">  <span class="keyword">private</span> Long id;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Embedded</span>  <span class="comment">// 값 타입을 사용하는 곳에 표시</span></span><br><span class="line">  Period workPeriod;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Embedded</span> </span><br><span class="line">  Address homeAddress;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Embeddable</span> <span class="comment">// 값 타입을 정의하는 곳에 표시</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Period</span></span>&#123;</span><br><span class="line">  <span class="meta">@Temporal</span> (TemporalType.DATE) java.util.Date startDate;</span><br><span class="line">  <span class="meta">@Temporal</span> (TemporalType.DATE) java.util.Date endDate;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isWork</span><span class="params">(Date date)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Embeddable</span> <span class="comment">// 값 타입을 정의하는 곳에 표시</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="9-2-1-임베디드-타입과-테이블-매핑"><a href="#9-2-1-임베디드-타입과-테이블-매핑" class="headerlink" title="9.2.1 임베디드 타입과 테이블 매핑"></a>9.2.1 임베디드 타입과 테이블 매핑</h5><p>임베디드 타입은 엔티티의 값일 뿐입니다. 따라서, 값이 속한 엔티티의 테이블에 매핑합니다.</p>
<h5 id="9-2-2-임베디드-타입과-연관관계"><a href="#9-2-2-임베디드-타입과-연관관계" class="headerlink" title="9.2.2 임베디드 타입과 연관관계"></a>9.2.2 임베디드 타입과 연관관계</h5><p>엔티티는 공유 될수 있으므로 참조한다고 표현하고, 값 타입은 특정 주인에게 소속되고 개념상 공유되지 않으므로 포함한다고 합니다.</p>
<h5 id="9-2-3-AttributeOverride-속성-재정의"><a href="#9-2-3-AttributeOverride-속성-재정의" class="headerlink" title="9.2.3 @AttributeOverride : 속성 재정의"></a>9.2.3 @AttributeOverride : 속성 재정의</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span></span>&#123; </span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@GeneratedValue</span></span><br><span class="line">  <span class="keyword">private</span> Long id;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Embedded</span> </span><br><span class="line">  Address homeAddress;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Embedded</span> </span><br><span class="line">  Address companyAddress;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위 코드는 칼럼명이 중복된다는 문제가 있습니다. 이를 다음과 같이 해결합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span></span>&#123; </span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@GeneratedValue</span></span><br><span class="line">  <span class="keyword">private</span> Long id;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Embedded</span> </span><br><span class="line">  Address homeAddress;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Embedded</span></span><br><span class="line">  <span class="meta">@AttributeOverrides</span>(&#123;</span><br><span class="line">    <span class="meta">@AttributeOverride</span>(name = <span class="string">"city"</span>, column = <span class="meta">@Column</span>(name = <span class="string">"COMPANY_CITY"</span>)),</span><br><span class="line">    <span class="meta">@AttributeOverride</span>(name = <span class="string">"street"</span>, column = <span class="meta">@Column</span>(name = <span class="string">"COMPANY_STREET"</span>)),</span><br><span class="line">    <span class="meta">@AttributeOverride</span>(name = <span class="string">"zipcode"</span>, column = <span class="meta">@Column</span>(name = <span class="string">"COMPANY_ZIPCODE"</span>)),</span><br><span class="line">  &#125;)</span><br><span class="line">  Address companyAddress;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>보다시피 코드의 중복도가 높아집니다. 한 엔티티에 같은 임베디드 타입을 중복해서 사용하는 일은 많지 않습니다.</p>
<h5 id="9-2-4-임베디드-타입과-NULL"><a href="#9-2-4-임베디드-타입과-NULL" class="headerlink" title="9.2.4 임베디드 타입과 NULL"></a>9.2.4 임베디드 타입과 NULL</h5><p>임베디드 타입이 null 이면 매핑한 칼럼 값은 모두 null 이 됩니다.</p>
<h4 id="9-3-값-타입과-불변-객체"><a href="#9-3-값-타입과-불변-객체" class="headerlink" title="9.3 값 타입과 불변 객체"></a>9.3 값 타입과 불변 객체</h4><h5 id="9-3-1-값-타입-공유-참조"><a href="#9-3-1-값-타입-공유-참조" class="headerlink" title="9.3.1 값 타입 공유 참조"></a>9.3.1 값 타입 공유 참조</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">member1.setHomeAddress(<span class="keyword">new</span> Address(<span class="string">"city1"</span>));</span><br><span class="line">Address address = member1.getHomeAddress();</span><br><span class="line"></span><br><span class="line">address.setCity(<span class="string">"city2"</span>); <span class="comment">//공유해서 사용</span></span><br><span class="line">member2.setHomeAddress(address);</span><br></pre></td></tr></table></figure>

<p>위 코드는 회원2의 주소만 바뀌길 기대하지만, 회원1의 주소도 바뀌게 됩니다. 이렇듯, 뭔가를 수정했는데 전혀 예상하지 못한 곳에서 문제가 발생하는 것을 Side Effect 라고 합니다. 이를 막기 위해, 값을 복사 해서 사용해야합니다.</p>
<h5 id="9-3-2-값-타입-복사"><a href="#9-3-2-값-타입-복사" class="headerlink" title="9.3.2 값 타입 복사"></a>9.3.2 값 타입 복사</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">member1.setHomeAddress(<span class="keyword">new</span> Address(<span class="string">"city1"</span>));</span><br><span class="line">Address address = member1.getHomeAddress();</span><br><span class="line"></span><br><span class="line"><span class="comment">//복사</span></span><br><span class="line">Address newAddress = address.clone();</span><br><span class="line"></span><br><span class="line">newAddress.setCity(<span class="string">"city2"</span>); <span class="comment">//공유해서 사용</span></span><br><span class="line">member2.setHomeAddress(newAddress);</span><br></pre></td></tr></table></figure>

<p>위의 코드 처럼 복사해서 사용하면 Side Effect 문제는 해결하지만, 임베디드 타입 처럼 직접 정의한 값 타입은 자바의 기본 타입이 아니라 객체 타입이란 것입니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = a; <span class="comment">//기본 타입은 항상 값을 복사</span></span><br><span class="line">b = <span class="number">4</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Address a = <span class="keyword">new</span> Address(<span class="string">"old"</span>);</span><br><span class="line">Address b = a; <span class="comment">//a와 b는 같은 인스턴스를 공유 참조</span></span><br><span class="line">b.setCity(<span class="string">"New"</span>);</span><br></pre></td></tr></table></figure>

<p>복사하지 않고 원본의 참조 값을 직접 넘기는 것을 막을 방법은 없습니다. 자바는 기본 타입이면 값을 복사해서 넘기고, 객체는 참졸르 넘길 뿐이기 때문입니다. 따라서, 객체의 공유 참조는 피할 수 없습니다. 이를 위해, 객체의 값을 수정하지 못하게 막아야합니다.</p>
<h5 id="9-3-3-불변-객체"><a href="#9-3-3-불변-객체" class="headerlink" title="9.3.3 불변 객체"></a>9.3.3 불변 객체</h5><p>한 번 만들면 절대 수정할수 없는 객체를 불변 객체라고 합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Embeddable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span></span>&#123; </span><br><span class="line">  </span><br><span class="line">	<span class="keyword">private</span> String city;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="title">Address</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Address</span><span class="params">(String city)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.city = city;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getCity</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> city;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//수정자 없음</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-4-값-타입의-비교"><a href="#9-4-값-타입의-비교" class="headerlink" title="9.4 값 타입의 비교"></a>9.4 값 타입의 비교</h4><ul>
<li>동일성 비교<ul>
<li>인스턴스의 참조 값을 비교</li>
<li>== 사용</li>
</ul>
</li>
<li>동등성 비교<ul>
<li>인스턴스의 값을 비교</li>
<li>equlas() method 사용</li>
</ul>
</li>
</ul>
<p>값 타입은 그 안에 값이 같으면 같은 것으로 봐야합니다. 따라서 동등성 비교를 해아합니다. </p>
<h4 id="9-5-값-타입-컬렉션"><a href="#9-5-값-타입-컬렉션" class="headerlink" title="9.5 값 타입 컬렉션"></a>9.5 값 타입 컬렉션</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@ElementCollection</span></span><br><span class="line">  <span class="meta">@CollectionTable</span>(name = <span class="string">"ADDRESS"</span>, joinColums = <span class="meta">@JoinColumn</span>(name = <span class="string">"MEMBER_ID"</span>))</span><br><span class="line">  <span class="meta">@Column</span>(name = <span class="string">"FOOD_NAME"</span>)</span><br><span class="line">  <span class="keyword">private</span> List&lt;Address&gt; addressHistory = <span class="keyword">new</span> ArrayList&lt;Address&gt;();</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>값 타입은 식별자가 없는 단순한 값들의 모임이기 때문에, 값을 변경하면 데이터베이스에 저장된 원본 데이터를 찾기 어렵습니다. 값 타입 컬렉션에 보관된 값 타입들은 별도의 테이블에 보관됩니다. 따라서 여기에 보관된 값 타입의 값이 변경되면 데이터베이스에 있는 원본 데이터를 찾기 어렵습니다. </p>
<p>이런 문제로, JPA구현체들은 값 타입 컬레션에 변경 사항이 발생하면, 값 타입 컬렙션이 매핑된 테이블의 연관된 모든 데이터를 삭제하고 현재 값 타입 컬렉션 객체에 있는 모든 값을 데이터베이스에 다시 저장합니다. </p>

                    
                        

                    
                    
                        <p>
                            <a href="/2019/04/11/value-type/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2019/04/09/proxy-relation-mapping/">
                            [자바 ORM 표준 JPA 프로그래밍] 8장_프록시와 연관관계 정리
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-04-09T00:00:00+09:00">
	
		    Apr 09, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/jpa/">JPA</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>이번 포스팅에서 다룰 내용입니다.</p>
<ul>
<li>프록시와 즉시로딩, 지연 로딩</li>
<li>영속성 전이와 고아 객체</li>
</ul>
<h4 id="8-1-프록시"><a href="#8-1-프록시" class="headerlink" title="8.1 프록시"></a>8.1 프록시</h4><p>엔티티가 실제 사용될 때 까지 데이터베이스 조회를 지연하는 방법을 지연 로딩이라고 합니다.<br>지연 로딩 기능을 사용하려면 실제 엔티티 대신에 데이터베이스 조회를 지연할 수 있는 가짜 객체가 필요한데, 이것을 프록시 객체라고 합니다.</p>
<h5 id="8-1-1-프록시-기초"><a href="#8-1-1-프록시-기초" class="headerlink" title="8.1.1 프록시 기초"></a>8.1.1 프록시 기초</h5><p>JPA 에서 식별자로 엔티티 하나를 조회할 때는 EntityManager.find() 를 사용합니다. 이 메소드는 영속성 컨텍스트에 엔티티가 없으면 데이터베이스를 조회합니다.</p>
<p>엔티티를 실제 사용하는 시점까지 데이터베이스 조회를 미루고 싶으면 <strong>EntityManager.getReference()</strong>를 사용하면 됩니다. 이 메소드를 호출하면,  실제 엔티티 객체를 생성하지 않고 데이터베이스 접근을 위임한 프록시 객체를 반환합니다.</p>
<ul>
<li><p>프록시의 특징</p>
<ul>
<li>프록시 객체는 실제 객체에 대한 참조(target) 을 보관합니다.</li>
<li>프록시 객체의 메소드를 호출하면, 프록시 객체는 실제 객체의 메소드를 호출합니다.</li>
<li>영속성 컨텍스트에 이미 찾는 엔티티가 있으면, 데이터베이스를 조회할 필요가 없으므로 em.getReference()를 호출해도 실제 엔티티를 반환합니다.</li>
</ul>
</li>
<li><p>프록시 객체의 초기화</p>
<ul>
<li>프록시 객체의 초기화란, member.getName() 처럼 실제 사용될 때 데이터베이스를 조회해서 실제 엔티티를 생성하는 것을 말합니다.</li>
<li>과정<ul>
<li>member.getName() 호출해서 실제 데이터 조회합니다.</li>
<li>영속성 컨텍스트는 데이터베이스를 조회해서 실제 엔티티 객체를 생성합니다.</li>
<li>프록시 객체는 생성된 실제 엔티티 객체의 참조를 MemerProxy 의 멤버 변수로 보관합ㄴ디ㅏ.</li>
<li>프록시 객체는 실제 엔티티 객체의 getName() 을 호출해서 결과를 반환합니다.</li>
</ul>
</li>
</ul>
</li>
<li><p>준영속 상태의 초기화</p>
<ul>
<li>초기화는 영속성 컨텍스트의 도움을 받아야 가능합니다.</li>
<li>준영속 상태의 프록시를 초기화하면 문제가 발생합니다.</li>
<li>Hibernate : LazyInitializationException 발생</li>
</ul>
</li>
</ul>
<h5 id="8-1-2-프록시와-식별자"><a href="#8-1-2-프록시와-식별자" class="headerlink" title="8.1.2 프록시와 식별자"></a>8.1.2 프록시와 식별자</h5><p>엔티티를 프록시로 조회할 때 식별자 값을 Parameter로 전달하는데 프록시 객체는 이 식별자 값을 보관합니다.구분 칼럼을 꼭 사용해야합니다.</p>
<p>으음..</p>
<h5 id="8-1-3-프록시-확인"><a href="#8-1-3-프록시-확인" class="headerlink" title="8.1.3 프록시 확인"></a>8.1.3 프록시 확인</h5><p>JPA가 제공하는 PersistenceUnitUtil.isLoaded(Object entity) 메소드를 사용하면 프록시 인스턴스의 초기화 여부를 확인할 수 있습니다. 조회한 엔티티가 진짜 엔티티인지 프록시로 조회한 것인지 확인하려면, 클래스명을 직접 출력해보면 됩니다.</p>
<h4 id="8-2-즉시-로딩과-지연-로딩"><a href="#8-2-즉시-로딩과-지연-로딩" class="headerlink" title="8.2 즉시 로딩과 지연 로딩"></a>8.2 즉시 로딩과 지연 로딩</h4><p>프록시 객체는 주로 연관된 엔티티를 지연 로딩할 때 사용합니다.</p>
<p>연관된 엔티티의 조회 시점을 선택할 수 있는 두 가지 방법이 있습니다.</p>
<ul>
<li>즉시로딩</li>
<li>지연 로딩</li>
</ul>
<h5 id="8-2-1-즉시-로딩"><a href="#8-2-1-즉시-로딩" class="headerlink" title="8.2.1 즉시 로딩"></a>8.2.1 즉시 로딩</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">em.find(Member.class, <span class="string">"member1"</span>)</span><br></pre></td></tr></table></figure>

<p>로 회원을 조회하는 순간 팀도 함께 조회합니다. 즉시 로딩을 최적화하기 위해 가능하면 조인쿼리를 사용합니다.</p>
<h5 id="8-2-2-지연-로딩"><a href="#8-2-2-지연-로딩" class="headerlink" title="8.2.2 지연 로딩"></a>8.2.2 지연 로딩</h5><p>위의 코드를 실행하면, 회원만 조회되고 팀은 조회되지 않습니다. 대신에 조회한 회원의 team 맴버 변수에  프록시 객체를 넣어둡니다. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Team team = member.getTeam() <span class="comment">// 프록시 객체</span></span><br></pre></td></tr></table></figure>

<p>반환된 팀 객체는 프록시 객체로, 실제 사용될때 까지 데이터 로딩을 미룹니다. 실제 데이터가 필요한 순간이 되어서야 데이터베이스를 조회해서 프록시 객체를 초기화합니다. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">team.getName()</span><br></pre></td></tr></table></figure>

<p>을 호출하면, 프록시 객체가 초기화 됩니다.</p>
<h4 id="8-3-지연-로딩-활용"><a href="#8-3-지연-로딩-활용" class="headerlink" title="8.3 지연 로딩 활용"></a>8.3 지연 로딩 활용</h4><h5 id="8-3-1-프록시와-컬렉션-래퍼"><a href="#8-3-1-프록시와-컬렉션-래퍼" class="headerlink" title="8.3.1 프록시와 컬렉션 래퍼"></a>8.3.1 프록시와 컬렉션 래퍼</h5><p>Hibernate 는 엔티티를 영속 상태로 만들 때, 엔티티에 컬렉션이 있으면 컬렉션을 추적하고 관리할 목적으로, <strong>원본 컬렉션을 Hibernate가 제공하는 내장 컬렉션으로 변경</strong>합니다. 이를 컬렉션 래퍼라고 합니다.</p>
<p>엔티티를 지연 로딩하면 프록시 객체를 사용해서 지연로딩을 수행하지만, 주문 내역과 같은 컬렉션은 컬렉션 래퍼가 지연 로딩을 처리해줍니다. 즉, 컬렉션 레퍼도 프록시 역할을 합니다.</p>
<p>member.getOrder()를 호출해도 컬렉션은 초기화되지 않습니다. member.getOrders().get(0) 처럼 컬렉션에서 실제 데이터를 조회할 때 데이터베이스를 조회해서 초기화합니다.</p>
<h5 id="8-3-2-JPA-기본-Fetch-전략"><a href="#8-3-2-JPA-기본-Fetch-전략" class="headerlink" title="8.3.2 JPA 기본 Fetch 전략"></a>8.3.2 JPA 기본 Fetch 전략</h5><ul>
<li>@ManyToOne, @OneToOne<ul>
<li>FetchType.EAGER</li>
</ul>
</li>
<li>@OneToMany, @ManyToMany<ul>
<li>FetchType.LAZY</li>
</ul>
</li>
</ul>
<p>추천하는 방버은 모든 연관관계에 지연 로딩을 사용하는 것입니다. 그리고, 실제 사용하는 상황을 보고 꼭 필요한 곳에 즉시 로딩을 사용하도록 최적화 하면 됩니다.</p>
<h5 id="8-3-3-컬렉션에-FetchType-EAGER-사용시-주의점"><a href="#8-3-3-컬렉션에-FetchType-EAGER-사용시-주의점" class="headerlink" title="8.3.3 컬렉션에 FetchType.EAGER 사용시 주의점"></a>8.3.3 컬렉션에 FetchType.EAGER 사용시 주의점</h5><ul>
<li>컬렉션을 하나 이상 즉시 로딩하는 것은 권장하지 않습니다.</li>
<li>컬렉션 즉시 로딩은 항상 OUTER JOIN 을 사용합니다.</li>
</ul>
<h4 id="8-4-영속성-전이-CASCADE"><a href="#8-4-영속성-전이-CASCADE" class="headerlink" title="8.4 영속성 전이 : CASCADE"></a>8.4 영속성 전이 : CASCADE</h4><p>특정 엔티티를 영속 상태로 만들 때 연관된 엔티티도 함께 영속 상태로 만들고 싶으면 영송석 전이 기능을 사용하면 됩니다. JPA는 CASCADE 옵션으로 영속성 전이 기능을 제공합니다.</p>
<h5 id="8-4-1-저장"><a href="#8-4-1-저장" class="headerlink" title="8.4.1 저장"></a>8.4.1 저장</h5><p>부모만 영속화하면 CascadeType.PERSIST 로 설정한 자식 엔티티까지 함께 영속화해서 저장합니다.</p>
<h5 id="8-4-2-삭제"><a href="#8-4-2-삭제" class="headerlink" title="8.4.2 삭제"></a>8.4.2 삭제</h5><p>CascadeType.REMOVE 설정하고 부모 엔티티만 삭제하면 연관된 자식 엔티티까지 함께 삭제됩니다.</p>
<h4 id="8-5-고아-객체"><a href="#8-5-고아-객체" class="headerlink" title="8.5 고아 객체"></a>8.5 고아 객체</h4><p>JPA는 부모 엔티티와 연관 관계가 끊어진 자식 엔티티를 자동으로 삭제하는 기능을 제공하는데, 이를 고아 객체 제거라고 합니다. 이 기능은 참조하는 곳이 하나 일때만 사용해야합니다. 즉, 특정 엔티티가 개인 소유하는 엔티티에만 이 기능을 적용해야합니다.</p>
<p>다음 코드는, 부모 엔티티의 컬렉션에서 자식 엔티티의 참조만 제거하면 자식 엔티티가 자동으로 삭제됩니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Paren</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="meta">@OneToMany</span>(mappedBy=<span class="string">"parent"</span>, orphanRemoval = <span class="keyword">true</span>)</span><br><span class="line">  <span class="keyword">private</span> List&lt;Child&gt; children = <span class="keyword">new</span> ArrayList&lt;Child&gt;();</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>다음 코드처럼,</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Parent parent = em.find(Parent.class, id);</span><br><span class="line">parent.getChildren.remove(<span class="number">0</span>); <span class="comment">// 자식 엔티티를 컬렉션에서 제거</span></span><br></pre></td></tr></table></figure>

<p>컬렉션에서 첫 번째 자식을 제거하면, 데이터베잇의 데이터도 삭제됩니다. 주의할 점은, 고아 객체 제거 기능은 영속성 컨텍스트를 flush 할 때 적용되므로, flush 시점에 DELETE SQL 이 실행됩니다.</p>
<h5 id="8-6-영속성-전이-고아객체-생명주기"><a href="#8-6-영속성-전이-고아객체-생명주기" class="headerlink" title="8.6 영속성 전이 + 고아객체, 생명주기"></a>8.6 영속성 전이 + 고아객체, 생명주기</h5><p><strong>CascadeType.All + orphanRemove = true</strong> 를 동시에 사용하면?</p>
<p>일반적으로 엔티티를 em.persist()로 영속화되고, em.remove()로 제거됩니다. 이것은 엔티티 스스로 생명주기를 관리한다는 뜻입니다. 그런데 두 옵션을 활성화하면 부모 엔티티르 통해서 자식의 엔티티를 관리할 수 있습니다.</p>
<p>자식을 저장하려면,</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Parent parent = em.find(Parent.class, id);</span><br><span class="line">parent.addChild(child);</span><br></pre></td></tr></table></figure>

<p>자식을 삭제하려면,</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Parent parent = em.find(Parent.class, id);</span><br><span class="line">parent.getChildren().remove(child);</span><br></pre></td></tr></table></figure>


                    
                        

                    
                    
                        <p>
                            <a href="/2019/04/09/proxy-relation-mapping/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2019/04/06/advanced-mappings/">
                            [자바 ORM 표준 JPA 프로그래밍] 7장_고급 매핑
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-04-06T00:00:00+09:00">
	
		    Apr 06, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/jpa/">JPA</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>이번 포스팅에서 다룰 고급 매핑은 다음과 같습니다.</p>
<ul>
<li>상속 관계 매핑</li>
<li>@MappedSupperclass</li>
<li>복합 키와 식별 관계 매핑</li>
<li>조인 테이블</li>
<li>엔티티 하나에 여러 테이블 매핑하기</li>
</ul>
<h4 id="7-1-상속-관계-매핑"><a href="#7-1-상속-관계-매핑" class="headerlink" title="7.1 상속 관계 매핑"></a>7.1 상속 관계 매핑</h4><p>관계형 데이터베이스에는 상속이라는 개념이 없습니다. 대신에, Super-Type Sub-Type Relationship 이라는 모델링 기법이 객체의 상속 개념과 가장 유사합니다. ORM 의 상속 관계 매핑은 객체의 상속 구조와 데이터베이스의 Super-Type Sub-Type Relationship 을 매핑하는 것입니다.</p>
<p>Super-Type Sub-Type Relationship 논리 모델을 실제 물리 모델인 테이블로 구현할 때는 3가지 방법이 있습니다.</p>
<ul>
<li>각각의 테이블로 변환<ul>
<li>조인 전략</li>
</ul>
</li>
<li>통합 테이블로 변환<ul>
<li>단일 테이블 전략</li>
</ul>
</li>
<li>서브타입 테이블로 변환<ul>
<li>구현 클래스마다 테이블 전략</li>
</ul>
</li>
</ul>
<h5 id="7-1-1-조인-전략"><a href="#7-1-1-조인-전략" class="headerlink" title="7.1.1 조인 전략"></a>7.1.1 조인 전략</h5><p>엔티티 각각을 모두 테이블로 만들고 자식 테이블이 부모 테이블의 기본 키를 받아서 기본 키 + 외래 키로 사용하는 전략입니다.<br>주의할 점은, 객체는 타입으로 구분할 수 있지만 테이블은 타입의 개념이 없기 때문에 타입을 구분하는 칼럼을 추가해야합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Inheritance</span> (strategy = InheritanceType.JOINED) <span class="comment">// 상속 매핑은 부모 클래스에 @Inheritance 를 사용</span></span><br><span class="line"><span class="meta">@DiscriminatorColumn</span> (name = <span class="string">"DTYPE"</span>)	<span class="comment">// 부모 클래스에 구분 칼럼을 지정</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@GeneratedValue</span> <span class="meta">@Column</span> (name = <span class="string">"ITEM_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> Long id;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String name; </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@DiscriminatorColumn</span> (<span class="string">"A"</span>)  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Album</span> <span class="keyword">extends</span> <span class="title">Item</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String artist;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@DiscriminatorColumn</span> (<span class="string">"M"</span>) <span class="comment">// 영화 엔티티를 저장하면 구분 칼럼인 DTYPE 에 값 M이 저장</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Movie</span> <span class="keyword">extends</span> <span class="title">Item</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String director;</span><br><span class="line">  <span class="keyword">private</span> String actor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>장점<ul>
<li>테이블이 정규화 됩니다.</li>
<li>외래 키 참조 무결성 제약 조건을 활용할 수 있습니다.</li>
<li>저장공간을 효율적으로 사용할 수 있습니다.</li>
</ul>
</li>
<li>단점<ul>
<li>조회할 때 조인이 많이 사용되므로 성능이 저하될 수 있습니다.</li>
<li>조회 쿼리가 복잡합니다.</li>
<li>데이터를 등록할 INSERT SQL 을 두 번 실행합니다.</li>
</ul>
</li>
<li>특징<ul>
<li>JPA 표준 명세는 구분 칼럼을 사용하도록 하지만, 하이버네이트는 구분 칼럼 없이도 동작합니다.</li>
</ul>
</li>
</ul>
<h5 id="7-1-2-단일-테이블-전략"><a href="#7-1-2-단일-테이블-전략" class="headerlink" title="7.1.2 단일 테이블 전략"></a>7.1.2 단일 테이블 전략</h5><p>테이블을 하나만 사용하고 구분 칼럼으로 어떤 자식 데이터가 저장되었는지 구분합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Inheritance</span> (strategy = InheritanceType.SINGLE_TABLE)</span><br><span class="line"><span class="meta">@DiscriminatorColumn</span> (name = <span class="string">"DTYPE"</span>)	</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@GeneratedValue</span> <span class="meta">@Column</span> (name = <span class="string">"ITEM_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> Long id;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String name; </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@DiscriminatorColumn</span> (<span class="string">"A"</span>)  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Album</span> <span class="keyword">extends</span> <span class="title">Item</span></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@DiscriminatorColumn</span> (<span class="string">"M"</span>) </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Movie</span> <span class="keyword">extends</span> <span class="title">Item</span></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>장점<ul>
<li>조인이 필요 없으므로 일반적으로 조회 성능이 빠릅니다.</li>
<li>조회 쿼리가 단순합니다.</li>
</ul>
</li>
<li>단점<ul>
<li>자식 엔티티가 매핑한 칼럼은 모두 null을 허용해야합니다.</li>
<li>단일 테이블에 모든 것을 저장하므로 테이블이 커질 수 있습니다. 상황에 따라서는 조회 성능이 느려질 수 있습니다.</li>
</ul>
</li>
<li>특징<ul>
<li>구분 칼럼을 꼭 사용해야합니다.</li>
</ul>
</li>
</ul>
<h5 id="7-1-3-구현-클래스마다-테이블-전략"><a href="#7-1-3-구현-클래스마다-테이블-전략" class="headerlink" title="7.1.3 구현 클래스마다 테이블 전략"></a>7.1.3 구현 클래스마다 테이블 전략</h5><p>자식 엔티티마다 테이블을 만듦니다. 그리고, 자식 테이블에 각각에 필요한 칼럼이 모두 있습니다. 이 전략은 추천하지 않는 전략입니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Inheritance</span> (strategy = InheritanceType.TABLE_PER_CLASS)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@GeneratedValue</span> <span class="meta">@Column</span> (name = <span class="string">"ITEM_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> Long id;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String name; </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Album</span> <span class="keyword">extends</span> <span class="title">Item</span></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Movie</span> <span class="keyword">extends</span> <span class="title">Item</span></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>장점<ul>
<li>서브 타입을 구분해서 처리할 때 효과적입니다.</li>
<li>not null 제약조건을 사용할 수 있습니다.</li>
</ul>
</li>
<li>단점<ul>
<li>여러 자식 테이블을 함께 조회할 때 성능이 느립니다. (SQL 의 UNION 을 사용해야합니다.)</li>
<li>자식 테이블을 통합해서 쿼리하기 어렵습니다.</li>
</ul>
</li>
<li>특징<ul>
<li>구분 칼럼을 사용하지 않습니다.</li>
</ul>
</li>
</ul>
<h4 id="7-2-MappedSuperClass"><a href="#7-2-MappedSuperClass" class="headerlink" title="7.2 MappedSuperClass"></a>7.2 MappedSuperClass</h4><p>부모 클래스는 테이블과 매핑하지 않고, 부모 클래스를 상속받는 자식 클래스에게 매핑 정보만 제공하고 싶으면 @MappedSuperClass 를 사용합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//테이블과 매핑할 필요가 없고 자식 엔티티에 공통으로 사용되는 매핑 정보만 제공</span></span><br><span class="line"><span class="meta">@MappedSuperClass</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseEntity</span></span>&#123; </span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@GeneratedValue</span></span><br><span class="line">  <span class="keyword">private</span> Long id;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span> <span class="keyword">extends</span> <span class="title">BaseEntity</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//id, name 상속</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Seller</span> <span class="keyword">extends</span> <span class="title">BaseEntity</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//id, name 상속</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String shopName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>부모로부터 물련 받은 매핑 정보를 재정의 하려면,</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="comment">//부모에게 상속 받은 id 속성의 칼럼명을 MEMBER_ID 로 재정의</span></span><br><span class="line"><span class="meta">@AttributeOverride</span>(name = <span class="string">"id"</span>, column = <span class="meta">@Column</span>(name = <span class="string">"MEMBER_ID"</span>))</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span> <span class="keyword">extends</span> <span class="title">BaseEntity</span></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>둘 이상을 재정을 하려면,</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@AttributeOverrides</span>(&#123;</span><br><span class="line">  <span class="meta">@AttributeOverride</span>(name = <span class="string">"id"</span>, column = <span class="meta">@Column</span>(name = <span class="string">"MEMBER_ID"</span>)),</span><br><span class="line">  <span class="meta">@AttributeOverride</span>(name = <span class="string">"name"</span>, column = <span class="meta">@Column</span>(name = <span class="string">"MEMBER_NAME"</span>))</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span> <span class="keyword">extends</span> <span class="title">BaseEntity</span></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>@MappedSuperClass 의 특징<ul>
<li>@MappedSuperClass 로 지정한 클래스는 엔티티가 아닙니다. 따라서, em.find() 나 JPQL 을 사용할 수 없습니다.</li>
<li>이 클래스를 직접 생성해서 사용할 일은 거의 없으므로, 추상 클래스로 만드는 것을 권장합니다.</li>
</ul>
</li>
</ul>
<h4 id="7-3-복합-키와-식별-관계-매핑"><a href="#7-3-복합-키와-식별-관계-매핑" class="headerlink" title="7.3 복합 키와 식별 관계 매핑"></a>7.3 복합 키와 식별 관계 매핑</h4><h5 id="7-3-1-식별-관계-VS-비식별-관계"><a href="#7-3-1-식별-관계-VS-비식별-관계" class="headerlink" title="7.3.1 식별 관계 VS 비식별 관계"></a>7.3.1 식별 관계 VS 비식별 관계</h5><ul>
<li>식별 관계<ul>
<li>부모 테이블의 기본 키를 내려받아서, 자식 테이블의 기본 키 + 외래 키로 사용하는 관계입니다.</li>
</ul>
</li>
<li>비식별 관계<ul>
<li>부모 테이블의 기본 키를 내려받아서, 자식 테이블의 외래키로만 사용하는 관계입니다.<ul>
<li>필수적 비식별 관계<ul>
<li>외래 키에 NULL을 허용 하지 않습니다. 연관관계를 필수적으로 맺어야 합니다.</li>
</ul>
</li>
<li>선택적 비식별 관계<ul>
<li>외래 키에 NULL을 허용합니다. 연관관계를 맺을지 선택할 수 있습니다.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="7-3-2-복합키-비식별-관계-매핑"><a href="#7-3-2-복합키-비식별-관계-매핑" class="headerlink" title="7.3.2 복합키: 비식별 관계 매핑"></a>7.3.2 복합키: 비식별 관계 매핑</h5><p>둘 이상의 칼럼으로 구성된 복합 기본키를 다음과 같이 해보면, 매핑 오류가 발생합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line">publi <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Id</span></span><br><span class="line">  <span class="keyword">private</span> String id;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Id</span></span><br><span class="line">  <span class="keyword">private</span> String id2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JPA 에서 식별자를 둘 이상 사용하려면 별도의 식별자 클래스를 만들어야합니다.<br>복합키를 지원하기 위해, 관계형 데이터베이스에 가까운 방법인 @IdClass 와, 객체지향에 가까운 @EmbededId 두 가지 방법을 제공합니다. </p>
<h6 id="IdClass"><a href="#IdClass" class="headerlink" title="IdClass"></a>IdClass</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@IdClass</span> (ParentId.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@Column</span> (name = <span class="string">"PARENT_ID1"</span>)</span><br><span class="line">  <span class="keyword">private</span> String id1; <span class="comment">//ParerntId.id1 과 연결</span></span><br><span class="line">  </span><br><span class="line">	<span class="meta">@Id</span> <span class="meta">@Column</span> (name = <span class="string">"PARENT_ID2"</span>)</span><br><span class="line">  <span class="keyword">private</span> String id2; <span class="comment">//ParerntId.id2 과 연결</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParentId</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123; <span class="comment">// Serializable 를 구현해야합니다.</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 식별자 클래스의 속성명과 엔티티에서 사용하는 식별자의 속성명이 같아야합니다.</span></span><br><span class="line">  <span class="keyword">private</span> String id1; <span class="comment">//Parernt.id1 과 연결</span></span><br><span class="line">  <span class="keyword">private</span> String id2; <span class="comment">//Parernt.id2 과 연결</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ParentId</span><span class="params">()</span></span>&#123; </span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ParentId</span><span class="params">(String id1, String id2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.id1 = id1;            </span><br><span class="line">    <span class="keyword">this</span>.id2 = id2;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// equals 와 hashCode를 구현해야합니다.</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span></span>&#123;...&#125; </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>복합키를 사용하는 엔티티를 저장하면,</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Parent parent = <span class="keyword">new</span> Parent;</span><br><span class="line">parent.setId1(<span class="string">"myId1"</span>);</span><br><span class="line">parent.setId2(<span class="string">"myId2"</span>);</span><br><span class="line">parent.setName(<span class="string">"ParentName"</span>);</span><br><span class="line">em.persist(parent)</span><br></pre></td></tr></table></figure>

<p>영속성 컨텍스트에 엔티티를 등록하기 직전에, 내부에서 Parent.id1, Parent.id2 값을 사용해서 식별자 클래스인 ParentId 를 생성하고 영속성 컨텍스트의 키로 사용합니다.</p>
<p>ParentId 를 사용해서 엔티티를 조회합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ParentId parentId = <span class="keyword">new</span> ParentId(<span class="string">"myId1"</span>, <span class="string">"myId2"</span>);</span><br><span class="line">Parent parent = em.find(Parent.class, parentId);</span><br></pre></td></tr></table></figure>

<p>자식 클래스는,</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Id</span></span><br><span class="line">  <span class="keyword">private</span> String id;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 부모 테이블의 기본 키 칼럼이 복합 키이므로, 자식 테이블의 외래 키도 복합키</span></span><br><span class="line">  <span class="comment">// 외래 키 매핑 시 여러 칼럼을 매핑해야하므로 @JoinColums를 사용</span></span><br><span class="line">  <span class="meta">@ManyToOne</span></span><br><span class="line">  <span class="meta">@JoinColums</span>(&#123;</span><br><span class="line">    <span class="meta">@JoinColum</span>(name = <span class="string">"PARENT_ID1"</span>, referencedColumnName = <span class="string">"PARENT_ID1"</span>),</span><br><span class="line">    <span class="meta">@JoinColum</span>(name = <span class="string">"PARENT_ID2"</span>, referencedColumnName = <span class="string">"PARENT_ID2"</span>),</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> Parent parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="EmbeddedID"><a href="#EmbeddedID" class="headerlink" title="EmbeddedID"></a>EmbeddedID</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@EmbeddedId</span></span><br><span class="line">  <span class="keyword">private</span> ParentId id;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Embeddable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParentId</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123; <span class="comment">//Serializable 를 구현</span></span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Column</span>(name = <span class="string">"PARENT_ID1"</span>)</span><br><span class="line">  <span class="keyword">private</span> String id1;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Column</span>(name = <span class="string">"PARENT_ID2"</span>)</span><br><span class="line">  <span class="keyword">private</span> String id2;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//equals and hashCode 구현</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>엔티티를 저장하면,</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Parent parent = <span class="keyword">new</span> Parent;</span><br><span class="line">ParentId parentId = <span class="keyword">new</span> ParentId(<span class="string">"myId1"</span>, <span class="string">"myId2"</span>);</span><br><span class="line"></span><br><span class="line">parent.setId(parentId);</span><br><span class="line">parent.setName(<span class="string">"ParentName"</span>);</span><br><span class="line">em.persist(parent)</span><br></pre></td></tr></table></figure>

<p>엔티티를 조회하면,</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ParentId parentId = <span class="keyword">new</span> ParentId(<span class="string">"myId1"</span>, <span class="string">"myId2"</span>);</span><br><span class="line">Parent parent = em.find(Parent.class, parentId);</span><br></pre></td></tr></table></figure>

<h5 id="7-3-3-복합키-식별-관계-매핑"><a href="#7-3-3-복합키-식별-관계-매핑" class="headerlink" title="7.3.3 복합키: 식별 관계 매핑"></a>7.3.3 복합키: 식별 관계 매핑</h5><p>부모, 자식, 손자까지 계속 기본 키를 전달하는 식별관계를 생각해보려고 합니다.</p>
<h6 id="IdClass-1"><a href="#IdClass-1" class="headerlink" title="IdClass"></a>IdClass</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@Column</span> (name = <span class="string">"PARENT_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> String id;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@IdClass</span>(ChildId.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 식별 관계는 기본 키와 외래키를 같이 매핑해야합니다.</span></span><br><span class="line">  <span class="comment">// 따라서, 식별자 매핑인 @Id 와 연관관계 매팽인 @ManyToOne 을 같이 사용합니다.</span></span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@ManyToOne</span> <span class="meta">@JoinColumn</span> (name = <span class="string">"PARENT_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> Parent parent;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@Column</span> (name = <span class="string">"CHILD_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> Parent childId;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChildId</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">  <span class="keyword">private</span> String parent; <span class="comment">//Child.parent 매핑</span></span><br><span class="line">  <span class="keyword">private</span> String childId; <span class="comment">//Child.childId 매핑</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//equals, hashCode</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@IdClass</span>(GrandChildId.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GrandChild</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Id</span> </span><br><span class="line">  <span class="meta">@ManyToOne</span></span><br><span class="line">  <span class="meta">@JoinColumns</span>(&#123;</span><br><span class="line">    <span class="meta">@JoinColumn</span>(name = <span class="string">"PARENT_ID"</span>),</span><br><span class="line">    <span class="meta">@JoinColumn</span>(name = <span class="string">"CHILD_ID"</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">private</span> Child child;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@Column</span> (name = <span class="string">"GRANDCHILD_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> String id;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GrandChildId</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">  <span class="keyword">private</span> ChildId child; <span class="comment">//GrandChild.child 매핑</span></span><br><span class="line">  <span class="keyword">private</span> String id; <span class="comment">//GrandChild.id 매핑</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//equals, hashCode</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="EmbeddeId"><a href="#EmbeddeId" class="headerlink" title="EmbeddeId"></a>EmbeddeId</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@Column</span> (name = <span class="string">"PARENT_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> String id;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@EmbeddedId</span></span><br><span class="line">  <span class="keyword">private</span> ChildId id;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@MapsId</span>(<span class="string">"parentId"</span>) <span class="comment">//ChildId.parentId 매핑. 외래 키와 매핑한 연관관계를 기본 키에도 매핑.</span></span><br><span class="line">  <span class="meta">@ManyToOne</span></span><br><span class="line">  <span class="meta">@JoinColumn</span> (name = <span class="string">"PARENT_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> Parent parent;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Embeddable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChildId</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">  <span class="keyword">private</span> String parentId; <span class="comment">// @MapsId("parentId") 로 매핑</span></span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Column</span>(name = <span class="string">"CHILD_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> String id;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//equals, hashCode</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GrandChild</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@EmbededId</span></span><br><span class="line">  <span class="keyword">private</span> GrandChildId id;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@MapsId</span> (<span class="string">"childId"</span>) <span class="comment">// GrandChildId.childId 매핑</span></span><br><span class="line">  <span class="meta">@ManyToOne</span></span><br><span class="line">  <span class="meta">@JoinColumns</span>(&#123;</span><br><span class="line">    <span class="meta">@JoinColumn</span>(name = <span class="string">"PARENT_ID"</span>),</span><br><span class="line">    <span class="meta">@JoinColumn</span>(name = <span class="string">"CHILD_ID"</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">private</span> Child child;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Embeddable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GrandChildId</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">  <span class="keyword">private</span> ChildId child; <span class="comment">// @MapsId("childId") 로 매핑</span></span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Column</span> ( name = <span class="string">"GRANDCHILD_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> String id;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//equals, hashCode</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="7-3-4-비식별-관계로-구현"><a href="#7-3-4-비식별-관계로-구현" class="headerlink" title="7.3.4 비식별 관계로 구현"></a>7.3.4 비식별 관계로 구현</h5><p>방금 예를, 비식별 관계로 변경하려고 합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@GeneratedValue</span> <span class="meta">@Column</span> (name = <span class="string">"PARENT_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> String id;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@GeneratedValue</span> <span class="meta">@Column</span> (name = <span class="string">"CHILD_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> Long id;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@ManyToOne</span> <span class="meta">@JoinColumn</span> (name = <span class="string">"PARENT_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> Parent parent;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GrandChild</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@GeneratedValue</span> <span class="meta">@Column</span> (name = <span class="string">"GRANDCHILD_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> Long id;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@ManyToOne</span> <span class="meta">@JoinColumn</span>(name = <span class="string">"CHILD_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> Child child;</span><br><span class="line">    </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="7-3-5-일대일-식별-관계"><a href="#7-3-5-일대일-식별-관계" class="headerlink" title="7.3.5 일대일 식별 관계"></a>7.3.5 일대일 식별 관계</h5><p>자식 테이블의 기본 키 값으로 부모 테이블의 기본 키 값만 사용합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Board</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@GeneratedValue</span> <span class="meta">@Column</span> (name = <span class="string">"BOARD_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> String id;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String title;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@OneToOne</span>(mappedBy = <span class="string">"board"</span>)</span><br><span class="line">  <span class="keyword">private</span> BoardDetail boardDetail;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoardDetail</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Id</span></span><br><span class="line">  <span class="keyword">private</span> Long boardId;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@MapsId</span> <span class="comment">//BoardDetail.boardId 매핑</span></span><br><span class="line">  <span class="meta">@OneToOne</span></span><br><span class="line">  <span class="meta">@JoinColumn</span> (name = <span class="string">"BOARD_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> Board board;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String content;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-4-조인-테이블"><a href="#7-4-조인-테이블" class="headerlink" title="7.4 조인 테이블"></a>7.4 조인 테이블</h4><p>데이터베이스 테이블의 연관관계를 설계하는 방법은 두 가지 입니다.</p>
<ul>
<li>조인 칼럼 사용 ( 외래키)<ul>
<li>회원이 사물함을 사용하기 전까지는 아직 둘 사이의 관계가 없으므로, MEMBER Table 의 LOKCER_ID 외래키에 null</li>
<li>외래 키애 null 허용하는 관계를 선택적 비식별 관계라고 합니다.</li>
<li>null 허용하므로, 회원과 사물함 조인할 때는 OUTER JOIN 사용해야합니다.</li>
<li>회원과 사물함이 아주 가끔 관계를 맺으면, 외래 키 대부분 값에 null 이 저장이 됩니다.</li>
</ul>
</li>
<li>조잍 테이블 사용 (테이블)<ul>
<li>조인 테이블에서 두 테이블의 외래 키를 가지고 연관 관계를 관리합니다.</li>
</ul>
</li>
</ul>
<h5 id="7-4-1-일대일-조인-테이블"><a href="#7-4-1-일대일-조인-테이블" class="headerlink" title="7.4.1 일대일 조인 테이블"></a>7.4.1 일대일 조인 테이블</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@GeneratedValue</span> <span class="meta">@Column</span> (name = <span class="string">"PARENT_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> Long id;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@OneToOne</span></span><br><span class="line">  <span class="meta">@JoinTable</span>(name = <span class="string">"PARENT_CHILD"</span>, <span class="comment">// 매핑할 조인 테이블 이름</span></span><br><span class="line">            joinColums = <span class="meta">@JoinColumn</span>(name = <span class="string">"PARENT_ID"</span>), <span class="comment">// 현재 엔티티를 참조하는 외래 키</span></span><br><span class="line">            inverseJoinColums = <span class="meta">@JoinColum</span>(name = <span class="string">"CHILD_ID"</span>) <span class="comment">// 반대방향 엔티티를 참조하는 외래 키</span></span><br><span class="line">  )</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> Child child;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@GeneratedValue</span> <span class="meta">@Column</span> (name = <span class="string">"CHILD_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> Long id;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="7-4-2-일대다-조인-테이블"><a href="#7-4-2-일대다-조인-테이블" class="headerlink" title="7.4.2 일대다 조인 테이블"></a>7.4.2 일대다 조인 테이블</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@GeneratedValue</span> <span class="meta">@Column</span> (name = <span class="string">"PARENT_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> Long id;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@OneToMany</span></span><br><span class="line">  <span class="meta">@JoinTable</span>(name = <span class="string">"PARENT_CHILD"</span>, <span class="comment">// 매핑할 조인 테이블 이름</span></span><br><span class="line">            joinColums = <span class="meta">@JoinColumn</span>(name = <span class="string">"PARENT_ID"</span>), <span class="comment">// 현재 엔티티를 참조하는 외래 키</span></span><br><span class="line">            inverseJoinColums = <span class="meta">@JoinColum</span>(name = <span class="string">"CHILD_ID"</span>) <span class="comment">// 반대방향 엔티티를 참조하는 외래 키</span></span><br><span class="line">  )</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> List&lt;Child&gt; child = <span class="keyword">new</span> ArrayList&lt;Child&gt;();</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@GeneratedValue</span> <span class="meta">@Column</span> (name = <span class="string">"CHILD_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> Long id;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="7-4-3-다대일-조인-테이블"><a href="#7-4-3-다대일-조인-테이블" class="headerlink" title="7.4.3 다대일 조인 테이블"></a>7.4.3 다대일 조인 테이블</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@GeneratedValue</span> <span class="meta">@Column</span> (name = <span class="string">"PARENT_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> Long id;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@OneToMany</span> (mappedBy = <span class="string">"PARENT_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> List&lt;Child&gt; child = <span class="keyword">new</span> ArrayList&lt;Child&gt;();</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@GeneratedValue</span> <span class="meta">@Column</span> (name = <span class="string">"CHILD_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> Long id;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@ManyToOne</span>(optional = <span class="keyword">false</span>)</span><br><span class="line">  <span class="meta">@JoinTable</span>(name = <span class="string">"PARENT_CHILD"</span>, <span class="comment">// 매핑할 조인 테이블 이름</span></span><br><span class="line">            joinColums = <span class="meta">@JoinColumn</span>(name = <span class="string">"CHILD_ID"</span>), <span class="comment">// 현재 엔티티를 참조하는 외래 키</span></span><br><span class="line">            inverseJoinColums = <span class="meta">@JoinColum</span>(name = <span class="string">"PARENT_ID"</span>) <span class="comment">// 반대방향 엔티티를 참조하는 외래 키</span></span><br><span class="line">  )</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> Parent parent;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="7-4-4-다대다-조인-테이블"><a href="#7-4-4-다대다-조인-테이블" class="headerlink" title="7.4.4 다대다 조인 테이블"></a>7.4.4 다대다 조인 테이블</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@GeneratedValue</span> <span class="meta">@Column</span> (name = <span class="string">"PARENT_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> Long id;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@ManyToMany</span></span><br><span class="line">  <span class="meta">@JoinTable</span>(name = <span class="string">"PARENT_CHILD"</span>, <span class="comment">// 매핑할 조인 테이블 이름</span></span><br><span class="line">            joinColums = <span class="meta">@JoinColumn</span>(name = <span class="string">"PARNET_ID"</span>), <span class="comment">// 현재 엔티티를 참조하는 외래 키</span></span><br><span class="line">            inverseJoinColums = <span class="meta">@JoinColum</span>(name = <span class="string">"CHILD_ID"</span>) <span class="comment">// 반대방향 엔티티를 참조하는 외래 키</span></span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">private</span> List&lt;Child&gt; child = <span class="keyword">new</span> ArrayList&lt;Child&gt;();</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@GeneratedValue</span> <span class="meta">@Column</span> (name = <span class="string">"CHILD_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> Long id;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-4-엔티티-하나에-여러-테이블-매핑"><a href="#7-4-엔티티-하나에-여러-테이블-매핑" class="headerlink" title="7.4 엔티티 하나에 여러 테이블 매핑"></a>7.4 엔티티 하나에 여러 테이블 매핑</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span> ( name = <span class="string">"BOARD"</span>) <span class="comment">// BOARD 테이블과 매핑</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// BOARD_DETAIL 테이블을 추가로 매핑</span></span><br><span class="line"><span class="meta">@SecondaryTable</span> ( name = <span class="string">"BOARD_DETAIL"</span>, <span class="comment">//매핑할 다른 테이블 이름</span></span><br><span class="line">                 <span class="comment">//매핑할 다른 테이블의 기본 키 칼럼 속성</span></span><br><span class="line">                pkJoinColums = <span class="meta">@PrimaryJoinColumn</span>(name = <span class="string">"BOARD_DETAIL_ID"</span>))</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Board</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@GeneratedValue</span> <span class="meta">@Column</span> (name = <span class="string">"BOARD_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> Long id;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String title;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// content 필드는 BOARD_DETAIL 테이블의 칼럼에 매핑</span></span><br><span class="line">  <span class="meta">@Column</span>(table = <span class="string">"BOARD_DETAIL"</span>)</span><br><span class="line">  <span class="keyword">private</span> String content;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@SecondaryTable 를 사용해서 두 테이블을 하나의 엔티티에 매핑하는 방법 보다는, 테이블당 엔티티를 각각 만들어서 일대일 매핑하는 것을 권장합니다.</p>

                    
                        

                    
                    
                        <p>
                            <a href="/2019/04/06/advanced-mappings/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
        
        <li class="pagination-number">page 1 of 1</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2020 junhee.ko. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/profile.jpg" alt="Author&#39;s picture"/>
        
            <h4 id="about-card-name">junhee.ko</h4>
        
            <div id="about-card-bio"><p>Always Learning</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>Engineer</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                Incheon
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/jquery.js"></script>
<script src="/assets/js/jquery.fancybox.js"></script>
<script src="/assets/js/thumbs.js"></script>
<script src="/assets/js/tranquilpeak.js"></script>
<!--SCRIPTS END-->



    </body>
</html>
