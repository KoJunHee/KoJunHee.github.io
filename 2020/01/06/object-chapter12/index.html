<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  
  <title>[오브젝트] 12장_다형성 | junhee.ko</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="상속의 진정한 목적은 코드 재사용이 아니라 다형성을 위한 서브타입 계층을 구축 하는 것이다. 상속의 관점에서 다형성이 구현되는 기술적인 메커니즘을 정리한다. 01 다형성다형성(Polymorphism) 은 다음 둘의 합성어이다. 즉, 많은 형태를 가질 수 있는 능력이다.  ploy : 많은 morph : 형태  다형성은 다음과 같이 분류될 수 있다. 이번장은">
<meta property="og:type" content="article">
<meta property="og:title" content="[오브젝트] 12장_다형성">
<meta property="og:url" content="https://kojunhee.github.io/2020/01/06/object-chapter12/index.html">
<meta property="og:site_name" content="junhee.ko">
<meta property="og:description" content="상속의 진정한 목적은 코드 재사용이 아니라 다형성을 위한 서브타입 계층을 구축 하는 것이다. 상속의 관점에서 다형성이 구현되는 기술적인 메커니즘을 정리한다. 01 다형성다형성(Polymorphism) 은 다음 둘의 합성어이다. 즉, 많은 형태를 가질 수 있는 능력이다.  ploy : 많은 morph : 형태  다형성은 다음과 같이 분류될 수 있다. 이번장은">
<meta property="og:locale" content="en">
<meta property="og:image" content="https://kojunhee.github.io/image/object_polymorphism_upcasting.png">
<meta property="og:image" content="https://kojunhee.github.io/image/object_polymorphism_self.png">
<meta property="og:image" content="https://kojunhee.github.io/image/object_polymorphism_overriding.png">
<meta property="og:image" content="https://kojunhee.github.io/image/object_polymorphism_grade_lecture.png">
<meta property="og:image" content="https://kojunhee.github.io/image/object_polymorphism_overloading.png">
<meta property="og:image" content="https://kojunhee.github.io/image/object_polymorphism_self_send.png">
<meta property="og:image" content="https://kojunhee.github.io/image/object_polymorphism_super.png">
<meta property="og:image" content="https://kojunhee.github.io/image/object_polymorphism_same_self.png">
<meta property="og:updated_time" content="2020-01-23T06:29:24.182Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="[오브젝트] 12장_다형성">
<meta name="twitter:description" content="상속의 진정한 목적은 코드 재사용이 아니라 다형성을 위한 서브타입 계층을 구축 하는 것이다. 상속의 관점에서 다형성이 구현되는 기술적인 메커니즘을 정리한다. 01 다형성다형성(Polymorphism) 은 다음 둘의 합성어이다. 즉, 많은 형태를 가질 수 있는 능력이다.  ploy : 많은 morph : 형태  다형성은 다음과 같이 분류될 수 있다. 이번장은">
<meta name="twitter:image" content="https://kojunhee.github.io/image/object_polymorphism_upcasting.png">
  
    <link rel="alternate" href="/atom.xml" title="junhee.ko" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">
  
  <link rel="stylesheet" href="/css/style.css">
  
    <link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">
  
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">junhee.ko</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">always learning</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://kojunhee.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-object-chapter12" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/01/06/object-chapter12/" class="article-date">
  <time class="dt-published" datetime="2020-01-05T15:00:00.000Z" itemprop="datePublished">2020-01-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/object/">Object</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      [오브젝트] 12장_다형성
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>상속의 진정한 목적은 코드 재사용이 아니라 <code>다형성을 위한 서브타입 계층을 구축</code> 하는 것이다.</p>
<p>상속의 관점에서 다형성이 구현되는 기술적인 메커니즘을 정리한다.</p>
<h2 id="01-다형성"><a href="#01-다형성" class="headerlink" title="01 다형성"></a>01 다형성</h2><p>다형성(Polymorphism) 은 다음 둘의 합성어이다. 즉, 많은 형태를 가질 수 있는 능력이다.</p>
<ul>
<li>ploy : 많은</li>
<li>morph : 형태</li>
</ul>
<p>다형성은 다음과 같이 분류될 수 있다. 이번장은 포함 다형성에 대해 다룬다.</p>
<ul>
<li><p>유니버셜 다형성 </p>
<ul>
<li><p>매개변수 다형성 </p>
<p>클래스의 인스턴스 변수나 메서드의 매개변수 타입을 임의의 타입으로 선언한 후 사용하는 시점에 구체적인 타입으로 지정하는 방식.</p>
<p> ex) List 인터페이스는 컬렉션에 보관할 요소의 타입을 임의의 타입 T로 지정하고 있으며 실제 인스턴스를 생성하는 시점에 T 를 구체적인 타입으로 지정</p>
</li>
<li><p>포함 다형성 (서브타입 다형성)</p>
<p>메세지가 동일해도 수신한 객체의 타입에 따라 실제로 수행되는 행동이 달라지는 능력.</p>
</li>
</ul>
</li>
<li><p>임시 다형성</p>
<ul>
<li><p>오버로딩 다형성</p>
<p>하나의 클래스 안에 동일한 이름의 메서드가 존재하는 경우.</p>
</li>
<li><p>강제 다형성</p>
<p>자동적인 타입 변환이나 사용자가 직접 구현한 타입 변환을 이용해 동일한 연산자를 다양한 타입에 사용할수 있는 방식.</p>
<p>ex) 이항 연산자인 ‘+’ 는 피연산자가 하나는 정수형이고 다른 하나는 문자열인 경우, 정수형 피연산자는 문자열 타입으로 강제 형변환</p>
</li>
</ul>
</li>
</ul>
<h2 id="02-상속의-양면성"><a href="#02-상속의-양면성" class="headerlink" title="02 상속의 양면성"></a>02 상속의 양면성</h2><ol>
<li><p>데이터 관점의 상속</p>
<p>부모 클래스에서 정의한 모든 데이터를 자식 클래스의 인스턴스에 자동으로 포함한다.</p>
</li>
<li><p>행동 관점의 상속</p>
<p>데이터뿐만 아니라 부모 클래스에서 정의한 일부 메서드 역시 자동으로 자식 클래스에 포함한다.</p>
<p>외부의 객체가 부모 클래스의 인스턴스에 전송할 수 있는 모든 메세지는 자식 클래스의 인스턴스에도 전송할 수 있다.</p>
</li>
</ol>
<h5 id="상속을-사용한-강의-평가"><a href="#상속을-사용한-강의-평가" class="headerlink" title="상속을 사용한 강의 평가"></a>상속을 사용한 강의 평가</h5><p>code : 394 p</p>
<ol>
<li><p>메서드 오버라이딩</p>
<p>자식 클래스 안에 상속 받은 메서드와 <code>동일한 시그니처의 메서드를 재정의</code>해서 부모 클래스의 구현을 새로운 구현으로 대체하는 것이다.</p>
</li>
<li><p>메서드 오버로딩</p>
<p>부모 클래스에서 정의한 <code>메서드와 이름은 동일하지만 시그니처는 다른</code> 메서드를 자식 클래스에 추가하는 것이다.</p>
</li>
</ol>
<h2 id="03-업캐스팅과-동적-바인딩"><a href="#03-업캐스팅과-동적-바인딩" class="headerlink" title="03 업캐스팅과 동적 바인딩"></a>03 업캐스팅과 동적 바인딩</h2><h5 id="같은-메세지-다른-메서드"><a href="#같은-메세지-다른-메서드" class="headerlink" title="같은 메세지, 다른 메서드"></a>같은 메세지, 다른 메서드</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Professor professor01 = <span class="keyword">new</span> Professor(<span class="string">"다익스트라"</span>, <span class="keyword">new</span> Lecture(...))</span><br><span class="line">Professor professor02 = <span class="keyword">new</span> Professor(<span class="string">"다익스트라"</span>, <span class="keyword">new</span> GradeLecture(...))</span><br><span class="line">  </span><br><span class="line">professor01.compileStatistics();</span><br><span class="line">professor02.compileStatistics();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">compileStatistics</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">	lecture.evalulate();</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>동일한 객체 참조인 lecture 에 대해 동일한 evaluate 메세지를 전송하는 동일한 코드 안에서, 서로 다른 클래스 안에 구현된 메서드를 실행할 수 있다.</p>
<p>이처럼, 코드 안에서 선언된 참조 타입과 무관하게 <code>실제로 메세지를 수신한 객체의 타입에 따라 실행되는 메서드가 달라질 수 있는 것</code>은 다음 두 메커니즘이 작용하기 때문이다.</p>
<ol>
<li><p>업캐스팅</p>
<p>부모 클래스 타입으로 선언된 변수에 자식 클래스의 인스턴스를 할당하는 것이 가능</p>
</li>
<li><p>동적 바인딩</p>
<p>메세지를 처리할 적절한 메서드를 컴파일 시점이 아니라 실행시점에 결정</p>
</li>
</ol>
<h5 id="업캐스팅"><a href="#업캐스팅" class="headerlink" title="업캐스팅"></a>업캐스팅</h5><p><img src="/image/object_polymorphism_upcasting.png" alt></p>
<p>업캐스팅의 대표적인 두 가지이다.</p>
<ol>
<li><p>대입문</p>
<p>명시적으로 타입을 변환하지 않고도 부모 클래스의 타입의 참조변수에 자식 클래스의 인스턴스를 대입할 수 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Lecture lecture = <span class="keyword">new</span> GradeLecture(...);</span><br></pre></td></tr></table></figure>
</li>
<li><p>메서드 파라미터</p>
<p>부모 클래스의 타입으로 선언된 파라미터에 자식 클래스의 인스턴스를 전달할 수 잇다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Professor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Professor</span><span class="params">(String name, Lecture lecture)</span></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Professor professor = <span class="keyword">new</span> Professor(<span class="string">"다익스트라"</span>, <span class="keyword">new</span> GradeLecture(...));</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>다운 캐스팅은, 부모 클래스의 인스턴스를 자식 클래스 타입으로 변환하기 위해 명시적인 타입 캐스팅이 필요하다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Lecture lecture = <span class="keyword">new</span> GradeLecture(...);</span><br><span class="line">GradeLecture gradeLecture = (GradeLecture) lecture;</span><br></pre></td></tr></table></figure>

<h5 id="동적-바인딩"><a href="#동적-바인딩" class="headerlink" title="동적 바인딩"></a>동적 바인딩</h5><ol>
<li><p>정적 바인딩</p>
<p>컴파일 타임에 호출할 함수를 결정하는 방식</p>
</li>
<li><p>동적 바인딩</p>
<p>실행될 메서드를 런타임에 결정하는 방식. </p>
<p>실행 시점에 어떤 클래스의 인스턴스를 생성해서 전달하는지 알아야만 실제로 실행될 메서드를 알 수 있다.</p>
</li>
</ol>
<h2 id="04-동적-메서드-탐색과-다형성"><a href="#04-동적-메서드-탐색과-다형성" class="headerlink" title="04 동적 메서드 탐색과 다형성"></a>04 동적 메서드 탐색과 다형성</h2><p>객체지향 시스템은 다음 규칙에 따라 실행할 메서드를 선택한다.</p>
<ol>
<li><p>메세지를 수신한 객체는 자신을 생성한 클래스에 적합한 메서드가 존재하는지 검사한다.</p>
<p>존재하면 메서드를 실행하고 탐색을 종료한다.</p>
</li>
<li><p>존재하지 않으면, 부모 클래스에서 메서드 탐색을 계속한다.</p>
<p>적합한 메서드를 찾을 때 까지 상속 계층을 따라 올라가며 계속된다.</p>
</li>
<li><p>상속 계층의 최상위 클르스에 올라갔지만 메서드를 발견하지 못하면 예외를 발생시키며 탐색을 종료한다.</p>
</li>
</ol>
<p>여기서 중요한 것이 sefl 참조 변수이다.</p>
<p>객체가 메세지를 수신하면, 컴파일러는 self 참조라는 임시 변수를 자동으로 생성해 메세지를 수신한 객체를 가리키도록 한다.</p>
<p><img src="/image/object_polymorphism_self.png" alt></p>
<p>위 그림에서, </p>
<ol>
<li>GradeLecture 클래스에서 적절한 메서드를 찾지 못했다면 </li>
<li>parent 참조를 따라 부모 클래스인 Lecture 클래스로 이동한후 탐색을 계속한다. </li>
<li>상속 계층을 따라 최상위 클래스인 Object 클래스에 이를 때 까지 탐색을 계속한다.  </li>
<li>최상위 클래스에서도 메서드를 찾지 못하면 에러를 발생시킨다.</li>
</ol>
<p>동적 메서드 탐색은 두 원리로 구성된다.</p>
<ol>
<li><p>자동적인 메세지 위임</p>
<p>자식 클래스는 이해할 수 없는 메세지를 전송 받으면 상속 계층을 따라 부모 클래스에 처리를 위임한다.</p>
</li>
<li><p>동적인 문맥</p>
<p>메세지를 수신했을 때, 실제로 어떤 메서드가 실행될지 결정하는 것은 컴파일 시점이 아니라 실행시점에 이뤄진다.</p>
</li>
</ol>
<h5 id="자동적인-메세지-위임"><a href="#자동적인-메세지-위임" class="headerlink" title="자동적인 메세지 위임"></a>자동적인 메세지 위임</h5><ol>
<li><p>메서드 오버라이딩 : 자식 클래스의 메서드가 부모 클래스의 메서드를 감추게 된다.</p>
<p><img src="/image/object_polymorphism_overriding.png" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Lecture lecture = <span class="keyword">new</span> Lecture(...);</span><br><span class="line">lecture.evaluate();</span><br></pre></td></tr></table></figure>

<p>위 그림과 위 코드에서, 메서드 탐색은 self 참조가 가리키는 객체의 클래스인 Lecuture 에서 시작한다.</p>
<p>Lecture 클래스 안에 evaluate 메서드가 존재하기 때문에, 메서드 실행한 후 탐색은 종료한다.</p>
<p><img src="/image/object_polymorphism_grade_lecture.png" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Lecture lecture = <span class="keyword">new</span> GradeLecture(...);</span><br><span class="line">lecture.evaluate();</span><br></pre></td></tr></table></figure>

<p>위 그림과 위 코드에서, Lecture 에 정의된 메서드가 아닌 실제 객체를 생성항 클래스인 GradeLecture 에 정의된 메서드가 실행된다. </p>
<p>self 참조가 가리키는 객체의 클래스인 GradeLecture 에서 탐색을 시작하고 GradeLecture 클래스 안에  evaluate 메서드가 구현되어 있기 때문이다.</p>
</li>
<li><p>메서드 오버로딩 :  자식 클래스의 메서드와 부모 클래스의 메서드가 공존한다.</p>
<p><img src="/image/object_polymorphism_overloading.png" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Lecture lecture = <span class="keyword">new</span> GradeLecture(...);</span><br><span class="line">lecture.average();</span><br></pre></td></tr></table></figure>

<p>위 그림과 위 코드에서, GradeLecture 클래스 안에서 메세지에 응답할 수 있는 적절한 메서드를 찾지 못한다.</p>
<p>그래서, 부모 클래스인 Lecture 클래스에서 메서드를 찾으려고 시도한다.</p>
</li>
</ol>
<h5 id="동적인-문맥"><a href="#동적인-문맥" class="headerlink" title="동적인 문맥"></a>동적인 문맥</h5><p>메세지를 수신한 객체가 무엇이냐에 따라 메서드 탐색을 위한 문맥이 동적으로 바뀐다. </p>
<p>이 동적인 문맥을 결정하는 것이 메세지를 수신한 객체를 가리키는 self 참조이다.</p>
<p>self 참조 가 동적 문맥을 결정한다는 것은, 종종 어떤 메서드가 실행될지 예상하기 어렵게 만든다. 대표적인 경우가 self 전송이다.</p>
<p>self 전송은 자식 클래스에서 부모 클래스 방향으로 진행되는 동적 메서드 탐색 경로를 <code>다시 self 참조가 가리키는 원래의 자식 클래스로 이동</code>시킨다. </p>
<p>다음을 보자.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lecture</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">stats</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getEvaluationMethod();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getEvaluationMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Pass or Fail"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GradeLecture</span> <span class="keyword">extends</span> <span class="title">Lecture</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getEvaluationMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Grade"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>GradeLecture 에 stats 메시지를 전송하면, 다음 그림과 같다.</p>
<p><img src="/image/object_polymorphism_self_send.png" alt></p>
<ol>
<li>self 참조는 GradeLecture 인스턴스를 가리키도록 설정되고 탐색은 GradeLecture 부터 시작.</li>
<li>GradeLecture 클래스에는 stats 메세지를 처리할 메서드가 없기 때문에 부모 클래스인 Lecture 에서 메서드 탐색을 계속속 하다가, Lecture 에서 stats 메서드를 발견하고 실행</li>
<li>실행 중에, self 참조가 가리키는 getEvaluationMethod 메세지를 전송하는 구문과 마주침</li>
<li>메서드 탐색은 self 참조가 가리키는 객체에서 다시 시작</li>
</ol>
<h5 id="이해할-수-없는-메세지"><a href="#이해할-수-없는-메세지" class="headerlink" title="이해할 수 없는 메세지"></a>이해할 수 없는 메세지</h5><p>이해할 수 없는 메세지 처리는 두 타입 언어에 따라 다르다.</p>
<ol>
<li><p>정적 타입 언어</p>
<p>코드를 컴파일 할 때 상속 계층 안의 클래스들이 메세지를 이해할 수 있는지 여부를 판단한다. </p>
<p>상속 계층 전체를 탐색한 후에도 메시지를 처리할 메서드를 발견하지 못하면 컴파일 에러가 발생한다. (안정적이다)</p>
</li>
<li><p>동적 타입 언어</p>
<p>실제로 코드 실행 전에는 메시지 처리 가능 여부를 판단 할 수 없다.</p>
<p>하지만, 이해할 수 없는 메세지에 대해 예외를던 는 것 외에도 doesNotUnderstand 나 method_missing 메시제에 응답 할 수 있는 메서드를 구현할 수 있다. (유연하다)</p>
</li>
</ol>
<h5 id="self-대-super"><a href="#self-대-super" class="headerlink" title="self 대 super"></a>self 대 super</h5><p><img src="/image/object_polymorphism_super.png" alt></p>
<p>super.average() 에 의해 호출되는 메서드는 부모 클래스의 메서드가 아니라, 더 상위에 위치한 조상 클래스의 메서드일 수 있다.</p>
<ol>
<li><p>self 전송</p>
<p>메세지를 수신한 객체의 클래스에 따라 메서드를 탐색할 시작 위치를 동적으로 결정</p>
</li>
<li><p>super 전송</p>
<p>항상 메세지를 전송하는 클래스의 부모 클래스에서부터 시작</p>
</li>
</ol>
<h2 id="5-상속-대-위임"><a href="#5-상속-대-위임" class="headerlink" title="5. 상속 대 위임"></a>5. 상속 대 위임</h2><p><img src="/image/object_polymorphism_same_self.png" alt></p>
<p>GradeLecture 인스턴스 입장에서 self 참조는, GradeLecture 인스턴스 자신이다.</p>
<p>GradeLecture 인스턴스에 포함된 Lecture 입장에서 self 참조는, GradeLecture 인스턴스이다. self 참조는 항상 메세지를 수신한 객체를 가리키기 때문이다.</p>
<p>즉, 상속 계층을 구성하는 객체들 사이에서는 self 참조를 공유하기 때문에 개념적으로 각 인스턴스에서 self 참조를 공유하는 self 변수를 포함하는 것처럼 표현할 수 있다.</p>
<p>상속은 동적으로 메서드를 탐샘하기 위해 현재의 실행문맥을 가지고 있는 self 참조를 전달한다. 그리고 이 객체들 사이에서는 메시지를 전달하는 과정이 자동으로 이뤄진다. 그래서, 자동적인 메세지 위임이라고 한다.</p>
<hr>
<p>오브젝트 &lt;조영호&gt;</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kojunhee.github.io/2020/01/06/object-chapter12/" data-id="ck5qcxmg500ogkl6wo43gcot2" data-title="[오브젝트] 12장_다형성" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/01/12/review-2019/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          2019년 회고
        
      </div>
    </a>
  
  
    <a href="/2020/01/05/big-data-chapter5/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">[빅데이터를 지탱하는 기술] 5장_빅데이터 파이프라인</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/algorithm/">Algorithm</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/big-data/">Big Data</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/boost-course/">Boost Course</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/dip/">DIP</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/data-structure/">Data Structure</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/database/">Database</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/design-pattern/">Design Pattern</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/git/">Git</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/jpa/">JPA</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kafka/">Kafka</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/network/">Network</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/node-js/">Node.js</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/os/">OS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/object/">Object</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/software-engineering/">Software Engineering</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/spark/">Spark</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/etc/">etc</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ios/">iOS</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/01/20/object-chapter14/">[오브젝트] 14장_일관성 있는 협력</a>
          </li>
        
          <li>
            <a href="/2020/01/13/object-chapter13/">[오브젝트] 13장_서브클래싱과 서브타이핑</a>
          </li>
        
          <li>
            <a href="/2020/01/12/review-2019/">2019년 회고</a>
          </li>
        
          <li>
            <a href="/2020/01/06/object-chapter12/">[오브젝트] 12장_다형성</a>
          </li>
        
          <li>
            <a href="/2020/01/05/big-data-chapter5/">[빅데이터를 지탱하는 기술] 5장_빅데이터 파이프라인</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 junhee.ko<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="/js/jquery-3.4.1.min.js"></script>


  <script src="/fancybox/jquery.fancybox.min.js"></script>


<script src="/js/script.js"></script>




  </div>
</body>
</html>