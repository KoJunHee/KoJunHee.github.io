<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.1"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Always Learning</title><meta property="og:type" content="blog"><meta property="og:title" content="Always Learning"><meta property="og:url" content="https://kojunhee.github.io/"><meta property="og:site_name" content="Always Learning"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://kojunhee.github.io/img/og_image.png"><meta property="article:author" content="junhee.ko"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://kojunhee.github.io"},"headline":"Always Learning","image":["https://kojunhee.github.io/img/og_image.png"],"author":{"@type":"Person","name":"junhee.ko"},"description":null}</script><link rel="icon" href="/img/favicon.ico"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/default.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><script data-ad-client="ca-pub-6880109808178384" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js" async></script></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Always Learning" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a></div><div class="navbar-end"><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-03-01T15:00:00.000Z" title="2020-03-01T15:00:00.000Z">2020-03-02</time><span class="level-item"><a class="link-muted" href="/categories/tdd/">TDD</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/03/02/tdd-chapter-06/">[테스트 주도 개발] 6장_돌아온 모두를 위한 평등</a></h1><div class="content"><p>5장에서 테스트를 빨리 통과하기 위해 코드를 복사해서 붙이는 죄를 저질렀다. 이제 청소할 시간이다.<br>Money 클래스가 공통의 equals 코드를 갖게 하면 어떨까 ? 간단한 것부터 시작하자.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Money</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>테스트는 여전히 돌아간다. Dollar 가 Money 를 상속받아도 여전히 어떤 것도 깨지지 않는다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dollar</span> <span class="keyword">extends</span> <span class="title">Money</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이제 amount 인스턴스 변수를 Money 로 옮길 수 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Money</span> </span>&#123;</span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">int</span> amount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>하위 클래스에서도 변수를 볼 수 있도록, 가시성을 private 에서 protected 로 변경했다.<br>이제, equals() 를 위로 올릴 수 있다. 우선, 임시 변수 선언하는 부분을 변경하자.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">	Money dollar = (Dollar) object;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> amount == dollar.amount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>모든 테스트가 잘 돈다. 이제 cast 부부을 변경하자.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">	Money dollar = (Money) object;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> amount == dollar.amount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>좀 더 원활한 의사소통을 위해, 임시 변수의 이름을 변경하자.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">	Money money = (Money) object;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> amount == money.amount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이제 이 메서드를 Dollar 에서 Money 로 옮길 수 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Money</span> </span>&#123;</span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">int</span> amount;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">		Money money = (Money) object;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> amount == money.amount;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이제는 Franc.equals() 를 제거해야한다. 일단 동치성 테스트가 Franc 끼리의 비교에 대해서는 아직 다루지 않았다. 우리는 코드를 변경하기 전에 그곳에 있어야 했던 테스트를 먼저 작성할 것이다. 리펙토링 전에 테스트를 먼저 하자.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testEquality</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	assertTrue(<span class="keyword">new</span> Dollar(<span class="number">5</span>).equals(<span class="keyword">new</span> Dollar(<span class="number">5</span>)));</span><br><span class="line">	assertFalse(<span class="keyword">new</span> Dollar(<span class="number">5</span>).equals(<span class="keyword">new</span> Dollar(<span class="number">6</span>)));</span><br><span class="line">	assertTrue(<span class="keyword">new</span> Franc(<span class="number">5</span>).equals(<span class="keyword">new</span> Franc(<span class="number">5</span>)));</span><br><span class="line">	assertFalse(<span class="keyword">new</span> Franc(<span class="number">5</span>).equals(<span class="keyword">new</span> Franc(<span class="number">6</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>또 중복이다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Franc</span> <span class="keyword">extends</span> <span class="title">Money</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> amount;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Money 클래스에 있는 필드를 이용하면, amount 필드를 제거할 수 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Franc</span> <span class="keyword">extends</span> <span class="title">Money</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Franc.equals() 는 Money.equals() 와 비슷해 보인다. 이 두 부분을 똑같이 만들면 프로그램의 의미를 변화시키지 않고도 Franc.equals() 를 완전히 지울 수 있다. 우선 임시 변수 선언 부분부터 고치자.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">	Money franc = (Franc) object;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> amount == franc.amount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>다음엔 cast.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">	Money franc = (Money) object;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> amount == franc.amount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>임시 변수의 임름도 상위 클래스에 맞게 고치자.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">	Money money = (Money) object;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> amount == money.amount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이제 Franc.equals() 는 Money.equals() 와 동일하므로, Franc 의 불필요한 코드를 제거하자.</p>
<hr>
<p>테스트 주도 개발 &lt;켄트 벡&gt;</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-02-24T15:00:00.000Z" title="2020-02-24T15:00:00.000Z">2020-02-25</time><span class="level-item"><a class="link-muted" href="/categories/big-data/">Big Data</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/02/25/bigdata-chapter-02/">[빅데이터] 2장_빅데이터를 위한 데이터 모델</a></h1><div class="content"><p>마스터 데이터 집합은 람다 아키텍처에서 반드시 오염으로부터 보호되어야하는 유일한 영역이다.</p>
<p><img src="/image/bigdata_c02_01.png" alt=""></p>
<h4 id="2-1-데이터의-속성"><a href="#2-1-데이터의-속성" class="headerlink" title="2.1 데이터의 속성"></a>2.1 데이터의 속성</h4><p><img src="/image/bigdata_c02_02.png" alt=""></p>
<p>대규모 소셜 네트워크 (페이스스페이스) 를 설계한다고 하자. 각각의 정보 계층은 바로 앞 단계로부터 파생되지만 단방향성이다.</p>
<p>앞으로 사용하게 될 용어들을 정리한다.</p>
<ol>
<li>정보 : 지식의 일반적인 모음</li>
<li>데이터 : 어떤 것으로부터 파싱되지 않은 정보</li>
<li>질의 : 데이터에 물어볼 수 있는 질문</li>
<li>뷰 :  특정 타입의 질의에 응답하는데 도움을 주기 위해 만들어 지는 것</li>
</ol>
<p><img src="/image/bigdata_c02_03.png" alt=""></p>
<p>어떤 사람의 데이터는 또 다른 사람의 뷰각 될 수 있다. 어떤 광고 회사가 페이스스페이스 사용자 프로필로부터 인구 통계학 정보를 긁어 가는 수집기를 만들었다. 톰의 출생월일은 생년월일로부터 도출될 수 있기 때문에 페이스스페이스에게는 뷰 이지만, 광고 회사 입장에서는 톰에 대한 제한된 정보를 가지는 것으로 시작하므로 데이터이다.</p>
<p>데이터의 핵심 속성을 살펴보자 : 원시성 / 불변성 / 영원성</p>
<h5 id="2-1-1-데이터는-원시적이다"><a href="#2-1-1-데이터는-원시적이다" class="headerlink" title="2.1.1 데이터는 원시적이다"></a>2.1.1 데이터는 원시적이다</h5><p>가공되지 않은 데이터일수록 더 많은 질문을 그 데이터에 대해 던질 수 있다.</p>
<h5 id="2-1-2-데이터는-불변이다"><a href="#2-1-2-데이터는-불변이다" class="headerlink" title="2.1.2 데이터는 불변이다."></a>2.1.2 데이터는 불변이다.</h5><p>관계형 데이터메이스 갱신은 없어서는 안 될 연산이다. 그러나 불변성을 다루기 위해서는 데이터를 갱신하거나 삭제하면 안되고 추가만 해야한다. 빅데이터 시스템에서 불변 스키마를 사용하면 다음 두 가지 이점이 있다.</p>
<ol>
<li><p>인적 내결함성 </p>
<p>실수로 인해 데이터가 손실되지 않는다. 잘못된 데이터가 쓰여도 이전에 있던 데이터는 그대로 남는다.</p>
</li>
<li><p>단순성</p>
<p>마스터 데이터 집함에 새 데이터를 추가할 수 있으면 된다. 데이터에 대한 색인이 필요하지 않아 단순하다.</p>
</li>
</ol>
<p>데이터의 불변성을 유지하는 것의 장점은 가변 스키마와 비교하면 명확하다.</p>
<p><img src="/image/bigdata_c02_04.png" alt=""></p>
<p>톰이 LA 로 이사했다. 그러면 톰의 현재 주거지를 반영하기 위해 갱신을 해야하는데, 톰이 샌프란시스코에 살았다는 지식은 완전히 손실된다.</p>
<p>불변 스키마를 사용하면 상황이 다르다. 사용자 정보가 바뀔 때마다 독립된 레코드를 생성한다. 이렇게 하려면 두 가지를 바꿔야한다.</p>
<ol>
<li>사용자 정보의 각 항목을 독립된 레코드에 저장한다.</li>
<li>각 데이터 단위에 그 정보가 알려진 시간을 붙인다.</li>
</ol>
<p><img src="/image/bigdata_c02_05.png" alt=""></p>
<p>톰이 새 주거지로 이사를 하면, 주거지 테이블에 새 래코드를 추가한다. 이제 톰의 주거지를 저장하는 레코드가 두 개가 된다. 관련된 모든 주거지 정보를 훑으면서 타임스태프가 가장 최신인 것을 골라내, 현재 주거지를 알 수 있다. </p>
<p>불변 방식을 사용하는 방법으로 감당해야하는 것은 가변 스키마보다 공간을 많이 사용한다는 것이다. 사용자 ID 는 가변 방식에서처럼 로우마다 한 번 나오는게 아니라 모든 속성에 나온다. 게다가 현재 상태 뿐만 아니라 이벤트 기록을 전부 저장한다.</p>
<p>하지만, 빅데이터 기술을 통해 막대한 데이터의 저장 능력을 이용해서 불변성의 헤택을 끌어내야한다. 마스터 데이터 집합을 구축하는 일은 정말 중요하다.</p>
<h5 id="2-1-3-데이터는-영원히-참이다"><a href="#2-1-3-데이터는-영원히-참이다" class="headerlink" title="2.1.3 데이터는 영원히 참이다."></a>2.1.3 데이터는 영원히 참이다.</h5><p>데이터의 불변성으로 인해 만들어지는 중요한 결과는, 데이터가 영원히 참이 된다는 것이다.</p>
<h4 id="2-2-데이터-표현을-위한-팩트-기반-모델"><a href="#2-2-데이터-표현을-위한-팩트-기반-모델" class="headerlink" title="2.2 데이터 표현을 위한 팩트 기반 모델"></a>2.2 데이터 표현을 위한 팩트 기반 모델</h4><p>마스터 데이터 집합 안에서 데이터를 표현하는 방법은 여러가지다. </p>
<ol>
<li>전통적인 관계형 데이터베이스의 테이블</li>
<li>구조화된 XML</li>
<li>반구조화된 JSON</li>
<li>팩트 기반 모델 (fact-based model) : 데이터를 fact 라고 불리는 기본 단위로 분해</li>
</ol>
<h5 id="2-2-1-팩트의-예와-속성"><a href="#2-2-1-팩트의-예와-속성" class="headerlink" title="2.2.1 팩트의 예와 속성"></a>2.2.1 팩트의 예와 속성</h5><p><img src="/image/bigdata_c02_06.png" alt=""></p>
<p>팩트 기반 모델은,</p>
<ol>
<li>원시 데이터를 원자적인 팩트로 저장한다.</li>
<li>타임스탬프로 인해 팩트는 불변성을 지니며 영원히 참이다.</li>
<li>질의 처리 과정 중에 중복 식별이 가능하도록 각 팩트의 식별 가능성을 보장한다.</li>
</ol>
<p>팩트는 유일하게 식별할 수 있는 데이터와 연관되어야한다. 페이스스페이스에 페이지뷰에 대한 데이터를 저장하는 경우를 생각해보자. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct PageView:</span><br><span class="line">	DateTime timestamp</span><br><span class="line">	String url</span><br><span class="line">	String ip_address</span><br></pre></td></tr></table></figure>

<p>이 구조체를 사용한 팩트는 특정한 페이지뷰 이벤트로 유일하게 식별되지 않는다. 동일한 IP 주소에서 동일한 URL 에 대한 여러개의 페이지뷰가 동시에 발생하면, 이 때 생겨난 각각의 페이지뷰는 정확히 같은 데이터 레코드이다. </p>
<p>서로 다른 페이지뷰를 구분하기 위해 스키마에 nonce (임시값), 각 페이지뷰마다 난수 생성법을 써서 만든 64 비트 숫자를 추가해보자.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct PageView:</span><br><span class="line">	DateTime timestamp</span><br><span class="line">	String url</span><br><span class="line">	String ip_address</span><br><span class="line">	Long nonce</span><br></pre></td></tr></table></figure>

<p>임시값을 추가하면 페이지뷰 이벤트를 서로 구별할 수 있고, 두 개의 페이지뷰 데이터 단위가 동일하면 이벤트도 동일하다는 것을 알 수 있다.</p>
<h5 id="2-2-2-팩트-기반-모델이-주는-혜택"><a href="#2-2-2-팩트-기반-모델이-주는-혜택" class="headerlink" title="2.2.2 팩트 기반 모델이 주는 혜택"></a>2.2.2 팩트 기반 모델이 주는 혜택</h5><ol>
<li><p>과거의 어느 시점에 대한 질의도 받을 수 있다.</p>
<p>팩트에 타임스탬프가 붙어있고 불변성을 지녀 생기는 결과이다.</p>
</li>
<li><p>사람의 실수에 대해 내성을 가진다.</p>
<p>톰이 샌프란시스코에서 로스앤잴래스로 이사한 것을 실수로 저장했다. 톰이 로스엔제렐스에 산다는 팩트를 지우면, 톰의 주거지가 자동으로 이전의 것으로 재설정된다.</p>
</li>
<li><p>부분 정보를 처리할 수 있다.</p>
<p>톰이 나이와 성별은 입력했지만 주거지나 직업은 입력하지 않으면, 데이터 집합은 알려진 정보에 대한 팩트만 보관한다. 팩트가 존재하지 않는다는 것은, 논리적으로 null 과 동일하다. </p>
</li>
<li><p>데이터 저장소의 질의 처리 계층이 분리된다.</p>
<p>batch layer 와 serving layer 모두에 정보가 저장되기 때문에 데이터가 정규화된 형태와 비정규화된 형태로 있게 되고, 양쪽의 모든 장점을 뽑을 수 있다.</p>
</li>
</ol>
<p>데이터 정규화를 다루는 관계형 테이블 예를 보자. 관계형 테이블을 사용할 때는 질의 효율성과 데이터 일관성 중 어떤 것이 중요하냐에 따라 정규화 스키마와 비정규화 스키마 중 하나를 선택한다.</p>
<p><img src="/image/bigdata_c02_07.png" alt=""></p>
<ol>
<li><p>비정규화된 스키마</p>
<p>동일한 이름이 여러 로우에 저장 될 수 있다. 이것은 각 회사의 직원수를 빨리 알아 낼 수 있도록 하지만, 회사가 이름을 바꾸면 많은 로우를 갱신해야한다. 정보를 여러 위치에 저장하는 것은 일관성이 깨질 위험이 있다.</p>
</li>
<li><p>정규화된 스키마</p>
<p>오직 하나의 위치에만 저장된다. 일관성이 깨질 위험은 없지만, 질의에 응답하려면 테이블을 조인해야하고 계산 비용이 커질 수 있다.</p>
</li>
</ol>
<p>람다 아키텍쳐에서는 질의 처리와 데이터 저장 목적이 분리되어 있다. </p>
<p><img src="/image/bigdata_c02_08.png" alt=""></p>
<ol>
<li><p>마스터 데이터 집합</p>
<p>완전히 정규화되어 있다. 어떤 데이터도 중복 되지 않는다. 현재 타임스템프를 붙여 새 팩트를 추가하면 과거 팩트는 무효화되어 갱신이 쉽다.</p>
</li>
<li><p>일괄처리 뷰</p>
<p>데이터 집합의 데이터 하나가 여러 뷰로 생성될수 있다는 점에서 비정규화된 테이블과 같다. 큰 차이는, 일괄 처리 뷰는 마스터 데이터 집합에 대한 함수로 정의된다는 것이다. 마스터 데이터 집합으로부터 계속 재생성 되므로 일괄 처리 뷰를 갱신할 필요가 없다.</p>
</li>
</ol>
<h4 id="2-3-그래프-스키마"><a href="#2-3-그래프-스키마" class="headerlink" title="2.3 그래프 스키마"></a>2.3 그래프 스키마</h4><p>팩트 그 자체만으로는, 데이터 집합에 저장된 팩트의 형식에 대한 기술도 없고, 그들 사이의 관계에 대한 설명도 없다. 그래서, 그래프 스키마가 필요하다.</p>
<h5 id="2-3-1-그래프-스키마의-요소"><a href="#2-3-1-그래프-스키마의-요소" class="headerlink" title="2.3.1 그래프 스키마의 요소"></a>2.3.1 그래프 스키마의 요소</h5><p>세 가지 핵심 요소는, </p>
<ol>
<li>노드 : 시스템 내의 개체</li>
<li>간선 : 노드 사이의 관계</li>
<li>속성 : 개체에 대한 정보</li>
</ol>
<p><img src="/image/bigdata_c02_09.png" alt=""></p>
<h5 id="2-3-2-강제-기능-스키마는-왜-필요한가"><a href="#2-3-2-강제-기능-스키마는-왜-필요한가" class="headerlink" title="2.3.2 강제 기능 스키마는 왜 필요한가"></a>2.3.2 강제 기능 스키마는 왜 필요한가</h5><p>팩트를 저장할 때 어떤 형식으로 저장해야할까.  JSON 처럼, 반구조화된 텍스트 형식을 사용한다고 하자. 실질적으로 어떤 것도 마스터 데이터 집합에 기록할 수 있어서 단순하고 유연하다. 하지만 문제가 있다.</p>
<p>톰의 나이를 JSON 으로 나타내면,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;id&quot; : 3, &quot;field&quot; : &quot;age&quot;, &quot;value&quot; : 29, &quot;timestamp&quot; : 133589484&#125;</span><br></pre></td></tr></table></figure>

<p>사람의 실수로 데이터 집합에 아래와 같은 팩트가 들어 갈 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;id&quot; : 3, &quot;field&quot; : &quot;age&quot;, &quot;value&quot; : 29&#125;</span><br></pre></td></tr></table></figure>

<p>JSON 자체는 유효하지만, 형식의 일관성을 지키지 못했고 데이터도 누락되었다. 텍스트 형식으로는 이 부분을 강제할 수 없다. </p>
<p>대안으로, 팩트의 구조를 엄격히 정의하는 강제 기능 스키마를 사용하면 된다. 처음에는 해줄게 많지만, 필요한 필드가 모두 존재하고 모든 값이 기대한 형식에 맞게 한다는 조건이 보장된다. 중요한 것은, 데이터 생성 중에 실수가 있을 때 강제 기능 스키마가 바로 그 시점에 오류를 낸다.</p>
<hr>
<p>빅데이터, 람다 아키텍처로 알아보는 실시간 빅데이터 구축의 핵심 원리와 기법 &lt;네이선 마츠, 제임스 워렌&gt;</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-02-24T15:00:00.000Z" title="2020-02-24T15:00:00.000Z">2020-02-25</time><span class="level-item"><a class="link-muted" href="/categories/big-data/">Big Data</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/02/25/bigdata-chapter-01/">[빅데이터] 1장_빅데이터를 위한 새로운 패러다임</a></h1><div class="content"><h4 id="1-1-이-책의-구성"><a href="#1-1-이-책의-구성" class="headerlink" title="1.1 이 책의 구성"></a>1.1 이 책의 구성</h4><p>이론을 다루는 장과 사례를 다루는 장으로 나뉜다. 이론을 다루는 장은 빅데이터 시스템을 구축하는 방법을 다루고, 사례를 다루는 장에서는 이론을 구체적인 도구에 연관시킨다.</p>
<h4 id="1-2-전통적인-데이터베이스를-사용해-확장하기"><a href="#1-2-전통적인-데이터베이스를-사용해-확장하기" class="headerlink" title="1.2 전통적인 데이터베이스를 사용해 확장하기"></a>1.2 전통적인 데이터베이스를 사용해 확장하기</h4><p>간단한 웹 분석 어플리케이션을 개발한다고 하자. 고객의 웹 페이지는 페이지뷰가 발생할 때마다 애플리케이션의 웹서버에 URL 정보를 보내야한다. 웹 서버는 데이터베이스에 페이지뷰에 해당하는 row 의 값을 증가시킨다. 이제 애플리케이션에 개선되며 어떤 문제가 생기는지 살펴본다.</p>
<h5 id="1-2-1-큐를-사용해-확장하기"><a href="#1-2-1-큐를-사용해-확장하기" class="headerlink" title="1.2.1 큐를 사용해 확장하기"></a>1.2.1 큐를 사용해 확장하기</h5><p>백엔드의 데이터베이스가 부하를 견디지 못해 페이지 뷰를 증가시키는 쓰기 요청을 신속히 처리하지 못해 타임 아웃이 나고 있다고 하자. </p>
<p>웹 서버가 데이터베이스에 직접 접근하도록 하는 대신, 웹 서버와 데이터베이스 사이에 큐를 넣는다. 그래서, 페이지뷰 이벤트를 받을 때마다 이벤트는 큐에 추가된다. 그리고, 큐에서 한 번에 100개씩 이벤트를 꺼내 하나의 데이터베이스 갱신 요청으로 일괄 처리하는 작업자 프로세스를 추가한다.</p>
<h5 id="1-2-2-데이터베이스를-샤딩하여-확장하기"><a href="#1-2-2-데이터베이스를-샤딩하여-확장하기" class="headerlink" title="1.2.2 데이터베이스를 샤딩하여 확장하기"></a>1.2.2 데이터베이스를 샤딩하여 확장하기</h5><p>이 웹 분석 애플리케이션이 계속 인기가 높아져, 데이터베이스에 과부하가 다시 걸렸다고 하자. 기존의 작업자 프로세스로는 쓰기 요청을 감당할 수 없어 갱신을 병렬 처리 하기 위해 작업자 프로세스의 수를 늘렸보았지만 도움이 되지 않았다.</p>
<p>그래서, 데이터베이스 서버를 여러 대 사용하고 테이블을 여러 서버에 분산시키는 수평 분할, 또는 샤딩이라고 불리는 방법을 사용한다. 즉, 각 서버는 전체 테이블의 일부를 가지는 것이다. 쓰기 부하를 여러 서버, 즉 샤드로 분산 시키게 되는 것이다.</p>
<p>이 애플리케이션의 인기가 높어져, 데이터베이스를 더 많은 샤드로 나누었다고 하자. 샤드 개수가 변경되어서 기존의 애플리케이션 코드에도 반영을 해야하고 이것을 깜빡하면 의도하지 않은 샤드에 기록된다. </p>
<h5 id="1-2-3-내결함성-문제-발생-시작"><a href="#1-2-3-내결함성-문제-발생-시작" class="headerlink" title="1.2.3 내결함성 문제 발생 시작"></a>1.2.3 내결함성 문제 발생 시작</h5><p>어쨌든 샤드를 늘렸는데, 이제 데이터베이스 장비에서 디스크 장애가 발생하는 상황이 왔다. 디스크 장애가 발생한 장비가 다운된 동안엔 그 디스크에 저장된 데이터를 사용할 수 없다. 해결책으로는,</p>
<ol>
<li><p>큐 / 작업자 시스템을 수정해서, 사용 불능 상태의 샤드로 들어오는 증가 이벤트는 별도의 대기 큐에 넣고 이를테면 5분 마다 한 번씩 큐의 쌓여 있는 이벤트를 일괄 처리한다.</p>
</li>
<li><p>데이터베이스의 자체 복제 기능을 사용해 마스터가 다운됐을 때 백업으로 사용할 수 있는 슬레이브를 각 샤드에 추가한다. 슬레이브는 쓰기가 불가능하지만, 적어도 고객이 애플리케이션 상태를 조회할 수 있도록은 한다.</p>
</li>
</ol>
<h5 id="1-2-4-데이터-오염-문제"><a href="#1-2-4-데이터-오염-문제" class="headerlink" title="1.2.4 데이터 오염 문제"></a>1.2.4 데이터 오염 문제</h5><p>큐 / 작업자 코드를 수정하는 도중, 실수로 모든 URL 에 대한 페이지 뷰를 1이 아니라 2씩 증가 시키는 버그를 만들었다고 하자. 데이터가 오염된다.</p>
<h5 id="1-2-5-어디서부터-잘못된-건가"><a href="#1-2-5-어디서부터-잘못된-건가" class="headerlink" title="1.2.5 어디서부터 잘못된 건가 ?"></a>1.2.5 어디서부터 잘못된 건가 ?</h5><p>여러분이 사용하는 데이터베이스는 스스로 데이터가 어떻게 분산되어 있는지 모른다. 이런 복잡함이 모두 데이터베이스 운영 작업과, 애플리케이션 코드 개발 작업에 더해진다. </p>
<p>시스템이 복잡해질수록 실수할 가능성은 커진다. 인적 내결함성 (human fault-tolerance) 는 필수 사항이다.</p>
<h5 id="1-2-6-빅데이터-기술이-어떻게-되움이-되는가"><a href="#1-2-6-빅데이터-기술이-어떻게-되움이-되는가" class="headerlink" title="1.2.6 빅데이터 기술이 어떻게 되움이 되는가 ?"></a>1.2.6 빅데이터 기술이 어떻게 되움이 되는가 ?</h5><p>빅데이터용 데이터베이스 및 계산 시스템은 데이터 어떤 식으로 분산되어 있는지를 자체적으로 알고 있다. 그래서, 샤딩이나 복제본 생성 작업을 알아서 처리한다.</p>
<p>또 다른 핵심 기술은, 데이터를 변경 불가 형태로 만든다는 것이다. 정상 데이터를 파괴하지 않아, 전통적인 데이터베이스보다 강력한 human fault-tolerance 을 제공한다.</p>
<h4 id="1-3-NoSQL-은-만병-통치약이-아니다"><a href="#1-3-NoSQL-은-만병-통치약이-아니다" class="headerlink" title="1.3 NoSQL 은 만병 통치약이 아니다"></a>1.3 NoSQL 은 만병 통치약이 아니다</h4><p>하둡과 같은 대용량 계산 시스템은, 대용량 일괄 처리식 계산은 병렬로 처리할 수 있지만 계산의 latency 가 오래 걸린다.</p>
<p>카산드라 같은 NoSQL 데이터베이스는 SQL 보다 훨씬 제한된 모델을 제공해서 확작성을 얻는다. 하지만, 이러한 제한된 데이터 모델에 애플리케이션을 끼워 넣는 것은 매우 복잡할 수 있다. 그리고 가변성을 전제로 하기 때문에 인적 내결함성을 갖추지 못하고 있다.</p>
<p>이 도구들을 현명하게 잘 결합하면 인적 내결함성을 갖추고 복잡성을 최소하해 확장성 있는 시스템을 만들 수 있다.</p>
<h4 id="1-4-기본-원칙"><a href="#1-4-기본-원칙" class="headerlink" title="1.4 기본 원칙"></a>1.4 기본 원칙</h4><p>데이터 시스템은 여러 조각 정보들을 조합해서 응답을 만든다. 예를 들어, 은행 계좌 잔고는 그 계좌에서 발생한 모든 거래에 대한 정보를 바탕으로 만들어진다. 더 중요한 것은, 모든 정보의 조각들이 동등한 성격이 아니라는 것이다. 어떤 정보는 다른 정보로부터 유래된다. 은행 계좌 잔고는 거래 내력을 가지고 만들어진다.</p>
<p>정보가 만들어진 재료가 되는 원래의 정보를 거꾸로 추적해가면 결국 다른 어떤 정보로부터도 파생되지 않은 정보에 다다른다. 이 정보를 데이터라고 한다. 데이터 시스템을 정의하면 다음과 같다. 데이터로 할 수 있는 모든 일은 현재 갖고 있는 모든 데이터를 입력으로 받는 함수로 표현할 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">query &#x3D; function(all data)</span><br></pre></td></tr></table></figure>

<h4 id="1-5-빅데이터-시스템에-요구되는-속성"><a href="#1-5-빅데이터-시스템에-요구되는-속성" class="headerlink" title="1.5 빅데이터 시스템에 요구되는 속성"></a>1.5 빅데이터 시스템에 요구되는 속성</h4><ol>
<li><p>견고성과 내결함성<br>복잡성을 회피해서 시스템에 대해 쉽게 생각할 수 있도록 하는 것도 빅데이터 시스템을 견고하게 만다는 작업이다. 그리고 빅데이터 시스템의 핵심에 불변성과 재계산 체계를 구축해놓으면, 복구 매커니즘이 쉽고 간결해져 사람의 실수에 대한 회복력을 지니게 된다.</p>
</li>
<li><p>짧은 읽기 / 갱신 지연 시간<br>시스템의 견고성을 해치지 않고 짧은 읽기 / 갱신 지연 시간을 얻을 수 있어야한다.</p>
</li>
<li><p>확장성<br>데이터나 부하가 늘어났을 때 시스템에 자원을 더 투입하는 것만으로 원래의 성능을 유지할수 있는 능력이다.</p>
</li>
<li><p>일반성<br>일반적인 시스템은 폭넓은 분야의 애플리케이션에 쓰일 수 있다.</p>
</li>
<li><p>유연성<br>대규모 데이터 이전을 용이하게 만다는 것은 시스템에 유연성을 부여하는 방법 중 하나이다.</p>
</li>
<li><p>ad hoc query<br>데이터에 대해 즉석 질의를 수행하는 것은 중요하다. </p>
</li>
<li><p>최소한의 유지 보수<br>유지보수를 최소화하기 위해, 가능하면 구현 복잡도를 낮게 만들어주는 구성 요소가 필요하다.</p>
</li>
<li><p>디버깅 가능성<br>빅데이터 시스템은 뭔가 잘못되었을 때 디버깅하는 데 필요한 정보를 제공해야한다. </p>
</li>
</ol>
<h4 id="1-6-완전-증분-아키턱쳐의-문제점"><a href="#1-6-완전-증분-아키턱쳐의-문제점" class="headerlink" title="1.6 완전 증분 아키턱쳐의 문제점"></a>1.6 완전 증분 아키턱쳐의 문제점</h4><p>완전 증분 아키턱쳐의 특징은, 데이터베이스를 읽고 쓴다는 것과 새로운 데이터가 들어왔을 때 데이터베이스의 상태를 증분식으로 변경한다는 것이다. 예를 들어, 페이지뷰를 셀 때 새로운 페이지뷰가 발생할 때마다 해당 URL 의 페이지 뷰 수에 1을 더한다. </p>
<p>이제 완전 증분 아키텍처로 인해 생기는 일반적인 복잡성을 살펴본다. </p>
<h5 id="1-6-1-운영-복잡성"><a href="#1-6-1-운영-복잡성" class="headerlink" title="1.6.1 운영 복잡성"></a>1.6.1 운영 복잡성</h5><p>읽기 / 쓰기를 지원하는 데이터베이는, 디스크 색인이 증분식으로 추가 및 변경되기 때문에 색인 일부가 사용되지 않은채로 남는다. 이들 미사용 영역은 공간만 차지할 뿐이고 디스크를 다 채워버리는 것을 막기 위해 회수되어야한다. 색인이 필요 없을 때 바로 회수하는 것은 너무 비용이 비싸기 때문에, 미사용 영역이 차지하는 공간은 가끔 실행되는 <strong>압밀화</strong> 과정을 통해 큰 단위로 회수된다.</p>
<p>서버는 압밀화를 수행하는 동안 CPU 와 디스크에 상당한 부담을 주게 되어 수행중에는 장비의 성능이 극적으로 떨어진다. 만약 동시에 너무 많은 장비가 압밀화를 수행하면 그들이 담당하고 있던 부하는 클러스터에 있는 다른 장비에 의해 처리되어야하고 이는 잠재적으로 클러스터의 나머지 부분에 과부하를 유발하여 전체 클러스터에 장애가 발생할 수 있다.</p>
<p>압밀화를 잘 관리하려면 한 번에 영향을 받는 노드가 너무 많아지지 않게 각 노드의 스케쥴링을 잡아줘야 한다. 운영 담당 직원이 처리할 수 있게 할 수 있지만, 어떤 성격의 복잡성이든 가장 좋은 대처 방법은 그 복잡성 자체를 아예 제거하는 것이다.</p>
<p>온라인 압밀화에 신경써야하는것은 완전 증분 아키텍쳐에 내재된 복잡성이다.</p>
<h5 id="1-6-2-최종적-일관성을-달성할-때-수반되는-극심한-복잡성"><a href="#1-6-2-최종적-일관성을-달성할-때-수반되는-극심한-복잡성" class="headerlink" title="1.6.2 최종적 일관성을 달성할 때 수반되는 극심한 복잡성"></a>1.6.2 최종적 일관성을 달성할 때 수반되는 극심한 복잡성</h5><p>고가용성 시스템은 장비에 장애가 발생하거나 네트워크에 부분적인 장애가 발생할 때도 질의와 갱신을 실행할수 있게 한다. 일관성이라는 키워드와 직접 경쟁한다. CAP 정리에 의하면, 네트워크가 분단된 상황에서는 같은 시스템 안에서 고가용성과 일관성을 동시에 달성할 수 없다고 한다. 그래서, 고가용성 시스템에서는 네트워크 분단이 발생하면 오래된 결과를 반환하는 경우도 있다.</p>
<p>네트워크 분단이 해소되면, 고가용성 시스템이 언젠가는 일관성 있는 결과를 반환하도록 하려면 (== 최종적 일관성), 애플리케이션의 도움이 필요하다. 예를 들어, 데이터베이스에 숫자를 저장하고 개수를 증가 시키는 이벤트를 받을 때마다 그 숫자의 값을 증가시키는 것이다. 이 경우, 네트워크 분단이 발생하면 대량의 데이터 손실이 발생할 수 있다.</p>
<p>그 원인은, 분산 데이터베이스는 모든 정보가 저장된 복제본을 여러 개 유지함으로써 고가용성을 얻고 있기 때문이다. 10을 저장하고 있는 두 대의 복제 서버가 있을 때 네트워크 분단이 발생했다고 해보자. 첫 번째 복제서버에서는 2가 증가했고, 두번째 서버에서는 1이 증가했다. 각각 12와 11을 저장하고 있는 이 서버들의 상태를 합쳐야할 때 어떤 값을 써야할까? 정답은 13 이지만, 12와 11을 봐서는 알 수 없다. 상태가 달라지기 전에 11을 저장하고 이있을 수도 있고 0을 저장하고 있을 수도 있다.</p>
<p>고가용성을 갖춘 상태에서 개수를 올바르게 세려면, 개수만 저장하는 것으로 부족하다. 서로 달라지는 값을 합치는데 적합한 자료구조를 사용해야하고 네트워크 분단이 해소되었을 때 올바른 값을로 수정하는 코드를 구현해야한다. 단순한 개수를 저장하는 것인데, 이렇게 복잡하다.</p>
<h5 id="1-6-3-인적-내결함성-결여"><a href="#1-6-3-인적-내결함성-결여" class="headerlink" title="1.6.3 인적 내결함성 결여"></a>1.6.3 인적 내결함성 결여</h5><p>증분 시스템에 데이터베이스에 저장된 상태를 지속적으로 변경한다는 것은 실수로 데이터베이스의 상태를 바꿀 수 있는 것을 의미한다. 실수는 불가피하기 때문에 언젠가 오염될 수 있다.</p>
<p>이를 해결하기 위해, </p>
<ol>
<li>애프리케이션이 데이터베이스를 직접 갱신하는 동기식 아키텍쳐 말고, </li>
<li>이벤트를 큐에 모아 두었다가 백그라운드로 데이터베이스를 갱신하는 비동기식 아키텍쳐를 사용하면 해결할 수 있다.</li>
</ol>
<p>모든 이벤트를 저장해 놓았기 때문에 사람이 실수로 데이터베이스를 오염시켜도 이벤트 저장소를 참조해 데이터베이스를 올바른 상태로 되돌릴 수 있다.</p>
<h4 id="1-7-람다-아키텍쳐"><a href="#1-7-람다-아키텍쳐" class="headerlink" title="1.7 람다 아키텍쳐"></a>1.7 람다 아키텍쳐</h4><p>람다 아키텍쳐의 핵심 아이디어는 빅데이터 시스템을 일련의 계층을로 구축하는 것이다 : 속도 계층 / 서빙 계층 / 일괄 처리 계층</p>
<p>모든 것은 다음 식으로부터 시작한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">query &#x3D; function(all data)</span><br></pre></td></tr></table></figure>

<p>하지만, 너무 많은 양의 자원이 소모되며 불합리하게 많은 비용이 든다. 누군가의 현재 위치를 찾을 때마다 페타바이트의 데이터 집합으 읽어야된다고 생각해보자.</p>
<p>가장 쉬운 대안은, 사전 계산하는 것이다. 질의 함수를 사전 계산한 결과를 batch view (일괄 처리 뷰) 라고 한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">batch view &#x3D; function(all data)</span><br><span class="line">query &#x3D; function(batch view)</span><br></pre></td></tr></table></figure>

<p>모든 데이터에 대해 함수를 실행해서 일괄처리 뷰를 생성해 놓는다. 그 후 어떤 질의의 결과가 필요할 때 일괄 처리 뷰에 대해 함수를 실행한다. </p>
<p>일괄처리 뷰를 생성할 때는 모든 데이터에 대해 함수를 실행해야하므로 그 시간이 오래 걸린다. 일괄처리 뷰 생성이 끝나면 일괄처리 뷰에 없는 데이터가 그동안 쌓였을 것이고, 질의는 몇 시간 전의 결과를 반환한다. 이 문제를 고치는 방법을 곧 설명한다.</p>
<h5 id="1-7-1-일괄처리-계층"><a href="#1-7-1-일괄처리-계층" class="headerlink" title="1.7.1 일괄처리 계층"></a>1.7.1 일괄처리 계층</h5><p>일과처리 계층은 마스터 복제본 ( 거대한 양의 레코드 목록 ) 을 저장하며 그 마스터 데이터 집합에 대한 일괄처리 뷰를 사전 계산한다.</p>
<p>일과처리 계층은은 두 가지를 할 수 있어야한다.</p>
<ol>
<li>불변성을 지니며 증가만 하는 마스터 데이터 집합을 저장</li>
<li>그 데이터 집합에 대해 임의의 함수를 계산</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function runBatchLayer() :</span><br><span class="line">	while(true) : </span><br><span class="line">		recomputeBatchViews()</span><br></pre></td></tr></table></figure>

<p>일괄처리 계층은 while(tue) 루프 내에서 실행되며 지속적으롤 일괄처리 뷰를 만들어낸다. </p>
<h5 id="1-7-2-서빙-계층"><a href="#1-7-2-서빙-계층" class="headerlink" title="1.7.2 서빙 계층"></a>1.7.2 서빙 계층</h5><p>서빙 계층은 일괄처리 뷰를 로딩해서 무작위 읽기를 수행할 수 있도록 하는 특수한 분산 데이터베이스이다. 새로운 일괄 처리 뷰가 생기면 서빙 계층은 자동으로 일괄처리 뷰를 교체해서 더 새로운 결과를 얻을 수 있도록 한다.</p>
<p>일괄 갱신과 무작위 읽기를 모두 지원한다. 주목할 점은, 무작위 쓰기는 지원할 필요가 없다. 데이터베이스에서 대부분의 복잡성은 무작위 쓰기에 의해 유발되므로 이 점은 아주 중요하다.</p>
<h5 id="1-7-3-속도-계층"><a href="#1-7-3-속도-계층" class="headerlink" title="1.7.3 속도 계층"></a>1.7.3 속도 계층</h5><p>속도 계층은 애플리케이션에 필요한 만큼 빠르게 새로운 데이터가 질의 함수에 반영되로록 보장한다. 일괄처리 계층은 한 번에 모든 데이터를 대상으로 하지만, 속도 계층은 최근 데이터만을 대상으로 한다. 새로운 데이터를 받을 때마다 실시간 뷰를 갱신한다. </p>
<p>즉, 람다 아키텍쳐는 다음과 같다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">batch view &#x3D; function(all data)</span><br><span class="line">realtime view &#x3D; function(realtime view, all data)</span><br><span class="line">query &#x3D; function(batch view, realtime view)</span><br></pre></td></tr></table></figure>

<p>속도 계층은 무작위 읽기와 무작위 쓰기를 지원하는 데이터베이스를 사용한다. 무작위 쓰기를 지원하기 때문에 다른 계층의 데이터베이스보다 복잡하다.</p>
<p>하지만, 람다 아키텍쳐에서는 데이터가 일괄처리 계층을 거쳐 서빙 계층에 도착하면 실시간 뷰에 있던 해당 데이터의 결과는 더 이상 필요없어진다. 즉, 실시간 뷰가 필요없어지면 버릴 수 있다. 이것이 복잡성 고립이다. 그 처리 결과가 그냥 일시적으로 쓰이고 마는 계층에만 복잡성이 가해진다는 것이다.</p>
<p>일괄 처리 계층에서는 정확한 결과를 얻는 알고리즘을 사용하고, 속도 계층에서는 근사 알고리즘 ( ex : 하이퍼로그로그 ) 을 사용하는 유연성을 얻는다. 일괄 처리 계층은 속도 계층을 무효화하므로 근사치는 정확한 값으로 고쳐지게 된다. 시스템은 최종적 정확성 이라는 속성을 지니게 된다.</p>
<hr>
<p>빅데이터, 람다 아키텍처로 알아보는 실시간 빅데이터 구축의 핵심 원리와 기법 &lt;네이선 마츠, 제임스 워렌&gt;</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-02-23T15:00:00.000Z" title="2020-02-23T15:00:00.000Z">2020-02-24</time><span class="level-item"><a class="link-muted" href="/categories/tdd/">TDD</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/02/24/tdd-chapter-02/">[테스트 주도 개발] 2장_타락한 객체</a></h1><div class="content"><p>TDD 주기는 다음과 같다.</p>
<ol>
<li>테스트를 작성한다. </li>
<li>실행가능하게 만든다.</li>
<li>올바르게 만든다. (중복 제거)</li>
</ol>
<p>“작동하는 깔끔한 코드” 를 얻어야한다는 전체 문제 중에서, “작동하는” 에 해당하는 부분을 먼저 해결해라.</p>
<p>테스트를 하나 통과했지만, Dollar 에 대한 연산을 수행한 후에 해당 Dollar 의 값이 바뀌는 것이 이상하다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testMultiplication</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Dollar product = <span class="keyword">new</span> Dollar(<span class="number">5</span>);</span><br><span class="line">	product.times(<span class="number">2</span>);</span><br><span class="line">	assertEquals(<span class="number">10</span>, product.amount);</span><br><span class="line">	product.times(<span class="number">3</span>);</span><br><span class="line">	assertEquals(<span class="number">15</span>, product.amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>times() 를 처음 호출한 이후에 product 는 더이상 5가 아니다. times() 가 새로운 객체를 반환하면 어떨까 ?</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testMultiplication</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Dollar five = <span class="keyword">new</span> Dollar(<span class="number">5</span>);</span><br><span class="line">	Dollar product = five.times(<span class="number">2</span>);</span><br><span class="line">	assertEquals(<span class="number">10</span>, product.amount);</span><br><span class="line">	product = five.times(<span class="number">3</span>);</span><br><span class="line">	assertEquals(<span class="number">15</span>, product.amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dollar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> amount;</span><br><span class="line"></span><br><span class="line">    Dollar(<span class="keyword">int</span> amount) &#123;</span><br><span class="line">        <span class="keyword">this</span>.amount = amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Dollar <span class="title">times</span><span class="params">(<span class="keyword">int</span> multiplier)</span> </span>&#123;</span><br><span class="line">        amount *= multiplier;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위 코드는 컴파일되지만 실행되지 않는다.  통과를 위해서는 올바른 금액을 갖는 새 Dollar 를 반환해야한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dollar</span> </span>&#123;</span><br><span class="line">		...</span><br><span class="line">		</span><br><span class="line">    <span class="function">Dollar <span class="title">times</span><span class="params">(<span class="keyword">int</span> multiplier)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Dollar(amount * multiplier);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>최대한 빨리 초록색을 보기 위한 방법이 있다.</p>
<ol>
<li><p>가짜로 구현하기<br>상수를 반환하게 만들고 진짜 코드를 얻을 때 까지 단계적으로 상수를 변수로 바꾸어간다.</p>
</li>
<li><p>명백한 구현 사용하기<br>실제 구현을 입력한다.</p>
</li>
</ol>
<p>보통 실무에서는 두 방법을 번갈아 사용한다. </p>
<ol>
<li>모든일이 잘 진행되고 뭘 입력할지 알 때는 병백한 구현을 더해나간다. </li>
<li>예상치 못한 빨간 막대를 만나면 가짜로 구현하는 방법을 사용하면서 올바른 코드르 리펙토링한다. </li>
<li>그리고 다시 자신감을 찾으면 명백한 구현을 사용한다.</li>
</ol>
<hr>
<p>테스트 주도 개발 &lt;켄트 벡&gt;</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-02-23T15:00:00.000Z" title="2020-02-23T15:00:00.000Z">2020-02-24</time><span class="level-item"><a class="link-muted" href="/categories/tdd/">TDD</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/02/24/tdd-chapter-01/">[테스트 주도 개발] 1장_다중 통화를 지원하는 Money 객체</a></h1><div class="content"><p>테스트 주도 개발의 리듬은 다음과 같다.</p>
<ol>
<li>재빨리 테스트 하나 추가</li>
<li>모든 테스트 실행하고 새로 추가한 것이 실패한지 확인</li>
<li>코드를 조금 변경</li>
<li>모든 테스트 실행하고 전부 성공하는지 확인</li>
<li>리팩토링으로 중복 제거</li>
</ol>
<p>어떤 테스트들이 있어야 보고서에 제대로 계산되도록 하는 코드가 완성됐다고 확신할 수 있을까 ?</p>
<ol>
<li>통화가 다른 두 금액을 더해서 주어진 환율에 맞게 변환 금액을 결과로 얻을 수 있어야한다.</li>
<li>어떤 금액을 어떤 수에 곱한 금액을 결과로 얻을 수 있어야한다.</li>
</ol>
<p>앞으로 어떤 일을 해야하는지 알려주고, 하는 일에 집중할 수 있게 하고, 언제 일이 끝나는지 알려 줄 수 있도록 할 일 목록을 만든다. 작업이 끝난 항목에는 줄을 긋는다.</p>
<p>할일 목록에서 볼 수 있듯이 곱하기를 먼저 다룬다. 작은 것부터 시작한다. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMultiplication</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Dollar five = <span class="keyword">new</span> Dollar(<span class="number">5</span>);</span><br><span class="line">	five.times(<span class="number">2</span>);</span><br><span class="line">	AssertionErrors.assertEquals(<span class="number">10</span>, five.amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위 테스트는 아직 컴파일조차 되지 않는다. 실행은 안되더라도, 컴파일만은 되도록 만들고 싶다. 네 개의 컴파일 에러가 있다.</p>
<ol>
<li>Dollar 클래스가 없음</li>
<li>생성자가 없음</li>
<li>times(int) 메서드가 없음</li>
<li>amount 필드가 없음</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dollar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> amount;</span><br><span class="line">    </span><br><span class="line">    Dollar(<span class="keyword">int</span> amount) &#123;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">times</span><span class="params">(<span class="keyword">int</span> multiplier)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위 코드에서 times(int multiplier) 는 stub 구현이다. 이 메서드를 호출하는 코드가 컴파일 될 수 있도록 껍데기만 만들어두는 것을 의미한다.</p>
<p>테스트를 다시 실행해보자. 실패한다. 테스팅 프레임워크가 결과로 10이 나와야 하는데 0이 나왔다는 것을 알려준다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dollar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> amount = <span class="number">10</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이제 다시 실행해보면, 초록 막대가 나온다. 이제 중복을 제거할 차례이다.</p>
<blockquote>
<p>“의존성과 중복”</p>
<p>의존성이 문제 그 자체라면, 중복은 문제의 징후다.</p>
<p>만약 특정 데이터베이스 벤더가 제공하는 세세한 기능들이 코드 곳곳에서 사용되고 있으면 다른 벤더 제품으로 변경할 때 해당 벤더에 의존성을 갖고 있다는 것을 알게 된다. 즉, 코드를 변경하지 않고 벤더를 바꿀 수 없다.</p>
<p>중복의 흔한 예는 로직의 중복이다. 중복된 로직을 하나로 끄집어내는 일엔 객체를 이용하는 것이 최고다.</p>
<p>다음 테스트로 진행하기 전에 중복을 제거하면, 다음 테스트도 통과되게 만들 가능성을 최대화한다.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dollar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> amount;</span><br><span class="line"></span><br><span class="line">    Dollar(<span class="keyword">int</span> amount) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">times</span><span class="params">(<span class="keyword">int</span> multiplier)</span></span>&#123;</span><br><span class="line">        amount = <span class="number">5</span> * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>테스트는 여전히 통과한다. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dollar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> amount;</span><br><span class="line"></span><br><span class="line">    Dollar(<span class="keyword">int</span> amount) &#123;</span><br><span class="line">        <span class="keyword">this</span>.amount = amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">times</span><span class="params">(<span class="keyword">int</span> multiplier)</span> </span>&#123;</span><br><span class="line">        amount *= multiplier;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이제 첫번째 테스트를 완료했다. 다음 장에서는 Dollar 부작용에 대한 작업을 한다.</p>
<hr>
<p>테스트 주도 개발 &lt;켄트 벡&gt;</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-02-23T15:00:00.000Z" title="2020-02-23T15:00:00.000Z">2020-02-24</time><span class="level-item"><a class="link-muted" href="/categories/tdd/">TDD</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/02/24/tdd-chapter-03/">[테스트 주도 개발] 3장_모두를 위한 평등</a></h1><div class="content"><p>Dollar 객체같이 객체를 값처럼 쓸 수 있는 것을 객체 Value Object Pattern 이라고 한다. 값 객체에 대한 제약사항 중 하나는 객체의 인스턴스 변수가 생성자를 통해서 일단 설정된 후에는 변하지 않는다는 것이다.</p>
<p>값 객체가 암시하는 것은,</p>
<ol>
<li>모든 연산은 새 객체를 반환해야한다.</li>
<li>값 객체는 equals() 를 구현해야한다.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testEquality</span><span class="params">()</span></span>&#123;</span><br><span class="line">	assertTrue(<span class="keyword">new</span> Dollar(<span class="number">5</span>).equals(<span class="keyword">new</span> Dollar(<span class="number">5</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>빨간 막대다. 가짜로 구현하는 방법은 단순히 true 를 반환하도록 하는 것이다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object object)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(삼각측량) 예제가 두 개 이상 있으면 코드를 일반화 할 수 있다.  다음과 같이 5!=6 을 해보자.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testEquality</span><span class="params">()</span></span>&#123;</span><br><span class="line">	assertTrue(<span class="keyword">new</span> Dollar(<span class="number">5</span>).equals(<span class="keyword">new</span> Dollar(<span class="number">5</span>)));</span><br><span class="line">  assertFalse(<span class="keyword">new</span> Dollar(<span class="number">5</span>).equals(<span class="keyword">new</span> Dollar(<span class="number">6</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이제 equlity 를 일반화하자.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object object)</span></span>&#123;</span><br><span class="line">	Dollar dollar = (Dollar) object;</span><br><span class="line">	<span class="keyword">return</span> amount == dollar.amount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이렇게 어떻게 리팩토링해야하는지 감이 안오면 삼각측량을 사용하자. 코드와 테스트 사이의 중복을 제거하고 일반적인 해법을 구할 방법이 보이면 그냥 그 방법대로 구현하면 된다.</p>
<p>자, 동일성 문제는 일시적으로 해결했다. 널 값이나 다른 객체들과 비교하는 상황은 일반적이진 않지만 당장은 필요하지 않다. 할일 목록에 적어 두기만 하자.</p>
<hr>
<p>테스트 주도 개발 &lt;켄트 벡&gt;</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-02-09T15:00:00.000Z" title="2020-02-09T15:00:00.000Z">2020-02-10</time><span class="level-item"><a class="link-muted" href="/categories/oop/">OOP</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/02/10/object-chapter-appendix-b/">[오브젝트] 부록 B 타입 계층의 구현</a></h1><div class="content"><p>타입과 타입 계층을 구현할 수 있는 방법들을 정리하자.</p>
<h5 id="클래스를-이용한-타입-계층-구현"><a href="#클래스를-이용한-타입-계층-구현" class="headerlink" title="클래스를 이용한 타입 계층 구현"></a>클래스를 이용한 타입 계층 구현</h5><p>타입은 객체의 퍼블릭 인터페이스이다. 클래스는 객체의 타입과 구현을 동시에 정의한 것이다.</p>
<p>Phone 클래스가 있다. Phone 의 인스턴스는 calculateFee 메시지를 수신할 수 있는 퍼블릭 메서드를 구현한다. 타입은 퍼블릭 인터페이스이기 때문에, Phone 클래스는 calculateFee 메세지에 응답할 수 있는 타입을 선언한 동시에 객체 구현을 정의한 것이다.</p>
<p>상속은, 퍼블릭 인터페이스는 유지하면서 새로운 구현을 가진 객체를 추가할 수 있는 간단한 방법이다. 하지만, 상속은 자식 클래스를 부모 클래스의 구현에 강하게 결합시킨다.</p>
<h5 id="인터페이스를-이용한-타입-계층-구현"><a href="#인터페이스를-이용한-타입-계층-구현" class="headerlink" title="인터페이스를 이용한 타입 계층 구현"></a>인터페이스를 이용한 타입 계층 구현</h5><p>인터페이스는, 상속으로 인한 결합도 문제를 피하고 다중 상속이라는 구현 제약을 해결할 수 있는 방법이다. </p>
<h5 id="추상-클래스를-이용한-타입-계층-구현"><a href="#추상-클래스를-이용한-타입-계층-구현" class="headerlink" title="추상 클래스를 이용한 타입 계층 구현"></a>추상 클래스를 이용한 타입 계층 구현</h5><p>추상 클래스는, 클래스 상속을 이용해 구현을 공유하면서도 결합도로 인한 부작용을 피하는 방법이다.</p>
<h5 id="추상-클래스와-인터페이스-결합하기"><a href="#추상-클래스와-인터페이스-결합하기" class="headerlink" title="추상 클래스와 인터페이스 결합하기"></a>추상 클래스와 인터페이스 결합하기</h5><p>인터페이스를 이용해 타입을 정의하고 특정 상속 계층에 국한된 코드를 공유할 필요가 있으면 추상 클래스를 이용해 코드 중복을 방지 할 수 있다. 이것이 골격 구현 추상 클래스이다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DiscountPolicy</span> </span>&#123;</span><br><span class="line">  <span class="function">Money <span class="title">calculateDiscountAmount</span><span class="params">(Screening screeing)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultDiscountPolicy</span> <span class="keyword">implements</span> <span class="title">DiscountPolicy</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">   </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Money <span class="title">calculateDiscountAmount</span><span class="params">(Screening screeing)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">abstract</span> <span class="keyword">protected</span> Money <span class="title">getDiscountAmount</span><span class="params">(Screeing screening)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="덕-타이핑-사용하기"><a href="#덕-타이핑-사용하기" class="headerlink" title="덕 타이핑 사용하기"></a>덕 타이핑 사용하기</h5><p>덕 테스트는 어떤 대상의 행동이 오리와 같다면 그것을 오리라는 타입으로 취급해도 무방하다는 것이다. 즉, 객체가 어떤 인터페이스에 정의된 행동을 수행할 수 있다면 그 객체를 해당 타입으로 분류해도 문제가 없다.</p>
<p>자바 같은 대부분의 정적 타입 언어에서는 두 클래스를 동일한 타입으로 취급하기 위해서는, 코드 상의 타입이 동일하게 선언되어 있어야한다. </p>
<p>반면, 런타입에 타입을 결정하는 동적 타입 언어에서는 특정한 클래스를 상속받거나 인터페이스를 구현하지 않고도 객체가 수신할 수 있는 메세지의 지합으로 객체의 타입을 결정할 수 있다.</p>
<h5 id="믹스인과-타입-계층"><a href="#믹스인과-타입-계층" class="headerlink" title="믹스인과 타입 계층"></a>믹스인과 타입 계층</h5><p>믹스인은, 객체를 생성할 때 코드 일부를 섞어 넣을 수 있도록 만들어진 일종의 추상 서브클래스이다. 사용하는 목적은, 다양한 객체의 구현 안에서 동일한 행동을 중복 코드 없이 재사용할 수 있게 만드는 것이다. 즉, 공통의 행동이 믹스인된 객체들은 동일한 메세지를 수신할 수 있는 퍼블릭 인터페이스를 공유하는 것이다. 예를 들어, 스칼라의 trait 로 구현할 수 있다.</p>
<p>스칼라의 trait 와 유사하게, 자바 8에 추가된 default method 는 인터페스에 메서드의 기본 구현을 추가하는 것을 허용한다. 디폴트 메서드가 제공하는 혜택을 누리기 위해서는 한계를 명확히 인식해야한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DiscountPolicy</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">default</span> Money <span class="title">calculateDiscountAmount</span><span class="params">(Screening screeing)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(DiscountCondition each : getConditions())&#123;</span><br><span class="line">      <span class="keyword">if</span>(each.isSatisfiedBy(screeing))&#123;</span><br><span class="line">        <span class="keyword">return</span> getDiscountAmount(screening);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> screening.getMovieFee();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function">List&lt;DiscountCondition&gt; <span class="title">getConditions</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">Money <span class="title">getDiscountAmount</span><span class="params">(Screeing screening)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>calculateDiscountAmount 가 내부적으로 두개의 메서드를 사용한다. 그래서 이 인터페이스를 구현하는 모든 클래스들은 해당 메서드의 구현을 제공해야한다는 것을 명시한 것이다.</p>
<p>추상 클래스를 사용했을 경우에는, getDiscountAmount 메서드의 가시성이 protected 였다. 하지만 이제 디폴트 메서드안에서 사용된다는 이유만으로 public 메서드가 되어야한다. 이것은 외부에 노출할 필요가 없는 메서드를 불필요하게 퍼블릭 인터페이스에 추가한 결과를 낳는다.</p>
<p>디폴트 메서드가 추가된 이유는, 인터페이스에 새로운 오퍼레이션을 추가할 경우에 발생하는 하위 호환성 문제를 해결하기 위해서이다. 추상 클래스를 제거하기 위해서가 아니다.</p>
<hr>
<p>오브젝트 &lt;조영호&gt;</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-02-09T15:00:00.000Z" title="2020-02-09T15:00:00.000Z">2020-02-10</time><span class="level-item"><a class="link-muted" href="/categories/oop/">OOP</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/02/10/object-chapter-appendix-c/">[오브젝트] 부록 C 동적인 협력, 정적인 코드</a></h1><div class="content"><p>좋은 설계는 객체 사이의 협력과 행동을 표현하는 동적 모델을 기반으로 해야한다.</p>
<ol>
<li><p>동적 모델<br>프로그램 실행 구조를 표현하는 움직이는 모델</p>
</li>
<li><p>정적 모델<br>코드의 구조를 담는 고정된 모델</p>
</li>
</ol>
<h2 id="01-동적-모델과-정적-모델"><a href="#01-동적-모델과-정적-모델" class="headerlink" title="01 동적 모델과 정적 모델"></a>01 동적 모델과 정적 모델</h2><h5 id="행동이-코드를-결정한다"><a href="#행동이-코드를-결정한다" class="headerlink" title="행동이 코드를 결정한다"></a>행동이 코드를 결정한다</h5><p>객체가 외부에 제공하는 행동이 중요하다. 동적 모델이 정적 모델을 결정해야한다.</p>
<h2 id="02-도메인-모델과-구현"><a href="#02-도메인-모델과-구현" class="headerlink" title="02 도메인 모델과 구현"></a>02 도메인 모델과 구현</h2><h5 id="도메인-모델에-관하여"><a href="#도메인-모델에-관하여" class="headerlink" title="도메인 모델에 관하여"></a>도메인 모델에 관하여</h5><ol>
<li><p>도메인<br>사용자가 프로그램을 사용하는 대상 영역</p>
</li>
<li><p>모델<br>지식을 선택적으로 단순화하고 의식적으로 구조화한 형태</p>
</li>
<li><p>도메인 모델<br>사용자가 프로그램을 사용하는 대상 영역에 대한 지식을 선택적으로 단순화하고 의식적으로 구조화한 형태</p>
</li>
</ol>
<p>소프트웨어의 도메인에 대해 고민하고 도메인 모델을 기반으로 소프트웨어를 구축해야한다. 그러면, 개념과 소프트웨어 사이의 표현적 차이를 줄일 수 있기 때문에 이해하고 수정하기 쉬온 소프트웨어를 만들 수 있다. </p>
<p>중요한 것은, 도메인 모델을 작성하는 것이 목표가 아니라 출발점이다. 중요한 것은 객체들의 협력을 지원하는 코드 구조를 만드는 것이다. 코드의 구조를 주도하는 것은 행동이다.</p>
<h5 id="행동과-변경을-고려한-도메인-모델"><a href="#행동과-변경을-고려한-도메인-모델" class="headerlink" title="행동과 변경을 고려한 도메인 모델"></a>행동과 변경을 고려한 도메인 모델</h5><p>도메인 모델은 단순히 클래스 다이어그램이 아니다. 도메인의 핵심을 간략하게 단순화해서 표현할 수 있는 모든 것이다. 이렇게 작성된 개념이 코드에 대한 구조와 행동을 드러내면 훌륭한 도메인 모델이다.</p>
<hr>
<p>오브젝트 &lt;조영호&gt;</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-02-02T15:00:00.000Z" title="2020-02-02T15:00:00.000Z">2020-02-03</time><span class="level-item"><a class="link-muted" href="/categories/oop/">OOP</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/02/03/object-chapter-appendix-a/">[오브젝트] 부록 A 계약에 의한 설계</a></h1><div class="content"><p>인터페이스만으로 객체의 행동에 관한 다양한 관점을 전달하기 어렵다.<br>명령의 부수효과를 쉽고 명확하게 표현할 수 있는 커뮤니케이션 수단이, 계약에 의한 설계이다.<br>여기서 중요한 것은 코드가 아니라, 개념이다.</p>
<h2 id="01-협력과-계약"><a href="#01-협력과-계약" class="headerlink" title="01 협력과 계약"></a>01 협력과 계약</h2><h5 id="부수-효과를-명시적으로"><a href="#부수-효과를-명시적으로" class="headerlink" title="부수 효과를 명시적으로"></a>부수 효과를 명시적으로</h5><p>일반적인 정합성 체크 로직은 코드의 구현 내부에 숨겨져있어 실제로 코드를 분석하지 않는 한 정확하게 파악하기 어렵다.</p>
<p>하지만, Code Contracts 와 같이 계약에 의한 설계를 지원하는 라이브러리나 언어들은 일반 로직과 구분할 수 있도록 제약 조건을 명시적으로 표현하는 것이 가능하다.</p>
<h2 id="02-계약에-의한-설계"><a href="#02-계약에-의한-설계" class="headerlink" title="02 계약에 의한 설계"></a>02 계약에 의한 설계</h2><p>버트란드 마이어가 제시한 계약은, 사람들 사이의 계약과 유사하다. 계약은 협력에 참여하는 두 객체 사이의 의무와 이익을 문서화한 것이다.</p>
<ol>
<li>협력에 참여하는 객체는 계약으로부터 이익을 기대하고 이익을 얻기위해 의무를 이행한다.</li>
<li>협력에 참여하는 객체의 이익과 의무는 객체의 인터페이스 상에 문서화된다.</li>
</ol>
<p>의도를 드러내는 인터페이스는 오퍼레이션의 시그니처만으로 어느 정도 클라이언트와 서버가 협력을 위해 수행해야하는 제약 조건을 명시한다.</p>
<p>계약은 여기서 한 걸음 더 나아간다. 서버는 자신이 처리할 수 있는 범위의 값들을 클라이언트가 전달할 것으로 기대한다. 클아이언트는 자신이 원하는 값을 서버가 반환할 것이라고 예상한다. 클아이언트는 메세지 전송 전과 후의 서버 상태가 정상일 것이라고 기대한다.</p>
<ol>
<li><p>사전 조건<br>메서드가 호출되기 위해 만족되어야하는 조건. 클라이언트의 의무</p>
</li>
<li><p>사후 조건<br>메서드가 실행된 후에 클라이언트에게 보장해야하는 조건. 서버의 의무</p>
</li>
<li><p>불변식<br>항상 참이라고 보장되는 서버의 조건</p>
</li>
</ol>
<h5 id="사전-조건"><a href="#사전-조건" class="headerlink" title="사전 조건"></a>사전 조건</h5><p>클라이언트가 사전 조건을 만족시키지 못하면, 메서드는 최대한 빨리 실패해서 클라이언트에게 버그가 있다는 사실을 알린다.</p>
<h5 id="사후-조건"><a href="#사후-조건" class="headerlink" title="사후 조건"></a>사후 조건</h5><p>다음 세 용도로 사용된다.</p>
<ol>
<li>인스턴스 변수의 상태가 올바른지 서술하기 위해</li>
<li>메스드에 전달된 파라미터의 값이 올바르게 변경됐는지를 서술하기 위해</li>
<li>반환값이 올바른지를 서술하기 위해</li>
</ol>
<h5 id="불변식"><a href="#불변식" class="headerlink" title="불변식"></a>불변식</h5><p>객체의 내부 상태와 관련이 있다.</p>
<p>메서드 실행 중에는 객체의 상태가 불안정한 상태로 빠질 수 있기 때문에 불변식을 만족시킬 필요가 없지만, 메서드 실행 전과 종료 후에는 항상 불변식을 만족해야한다.</p>
<h2 id="03-계약에-의한-설계와-서브타이핑"><a href="#03-계약에-의한-설계와-서브타이핑" class="headerlink" title="03 계약에 의한 설계와 서브타이핑"></a>03 계약에 의한 설계와 서브타이핑</h2><p>리스코프 치환 원칙은, 슈퍼타입의 인스턴스와 협력하는 클라이언트의 관점에서 서브타입의 인스턴스가 슈퍼타입을 대체하더라도 협력에 지장이 없어야 한다는 것을 의미한다.</p>
<p>따라서 서브타입이 리스코프 치환 원칙을 만족하기 위해서는, 클라이언트와 슈퍼타입 간에 체결된 계약을 준수해야한다.</p>
<h5 id="계약-규칙"><a href="#계약-규칙" class="headerlink" title="계약 규칙"></a>계약 규칙</h5><ol>
<li><p>서브타입에 더 강력한 사전 조건을 정의할 수 없다.<br>계약서에 명시된 의무보다 더 많은 의무를 짊어져야한다는 사실을 납득하는 클라이언트는 없다.</p>
</li>
<li><p>서브타입에 더 완화된 사후 조건을 정의할 수 없다.<br>계약서에 명시된 이익보다 더 적은 이익을 받게 되는 사실을 납득하는 클라이언트는 없다.</p>
</li>
<li><p>슈퍼타입의 불변식은 서브타입에서도 유지되어야 한다.<br>메서드 실행 중에는 불변식을 만족시키지 않아도 되지만, 메서드 실행 전과 후에는 만족해야한다.</p>
</li>
</ol>
<h5 id="가변성-규칙"><a href="#가변성-규칙" class="headerlink" title="가변성 규칙"></a>가변성 규칙</h5><ol>
<li><p>서브타입은 슈퍼타입이 발생시키는 예외와 다른 타입의 예외를 발생시켜서는 안된다.<br>클라이언트는 Bird 의 인스턴스에 fly 메세지를 전송했을 때, UnsupportedOperationException 예외를 기대하지 않는다.</p>
</li>
<li><p>서브타입의 리턴타입은 공변성을 가져야한다.<br>리턴 타입 공변성 : 부모 클래스에서 구현된 메서드를 자식 클래스에서 오버라이딩할 때 부모 클래스에서 선언한 반환 타입의 서브타입으로 지정할 수 있는 특성</p>
</li>
<li><p>서브타입의 메서드 파라미터는 반공변성을 가져야 한다.<br>파라미터 타입 반공병성 : 부모 클래스에서 구현된 메서드를 자식 클래스에서 오버라이딩할 때 파라미터 타입을 부모 클래스에서 사용한 파라미터의 슈퍼타입으로 지정할 우 있는 특성</p>
</li>
</ol>
<hr>
<p>오브젝트 &lt;조영호&gt;</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-01-26T15:00:00.000Z" title="2020-01-26T15:00:00.000Z">2020-01-27</time><span class="level-item"><a class="link-muted" href="/categories/oop/">OOP</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/01/27/object-chapter15/">[오브젝트] 15장_디자인 패턴과 프레임워크</a></h1><div class="content"><ol>
<li><p>디자인 패턴<br>특정한 변경을 일관성있게 다룰 수 있는 협력 텝플릿 제공.<br>설계를 재사용하는 것이 목적.</p>
</li>
<li><p>프레임워크<br>특정한 변경을 일관성 있게 다룰 수 있는 확장 가능한 코드 템플릿 제공.<br>설계와 코드를 함께 재사용하기 위한 것이 목적.</p>
</li>
</ol>
<h2 id="01-디자인-패턴과-설계-재사용"><a href="#01-디자인-패턴과-설계-재사용" class="headerlink" title="01 디자인 패턴과 설계 재사용"></a>01 디자인 패턴과 설계 재사용</h2><h5 id="소프트웨어-패턴"><a href="#소프트웨어-패턴" class="headerlink" title="소프트웨어 패턴"></a>소프트웨어 패턴</h5><p>패턴의 특징은,</p>
<ol>
<li>반복적으로 발생하는 문제와 해법의 쌍으로 정의된다.</li>
<li>패턴을 사용해서 이미 알려진 문제와 이에 대한 해법을 문서로 정리할 수 있다. 다른 사람과 의사소통 가능.</li>
<li>추상적인 원칙과 실제 코드 작성 사이의 간극을 메워준다. 실질적인 코드 작성을 돕는다.</li>
<li>패턴은 실무에서 탄생했다.</li>
</ol>
<p>마틴 파울러에 의하면, 패턴은 하나의 실무 컨텍스트에서 유용하게 사용해왔고 다른 실무 컨텍스트엣도 유용할 것이라고 예상되는 아이디어다. 프로젝트 조직을 구성하는 방법, 프로젝트 일정을 추정하는 방법 등 반복적인 규칙을 발견할 수 있는 모든 영역이 패턴의 대상이다.</p>
<h5 id="패턴-분류"><a href="#패턴-분류" class="headerlink" title="패턴 분류"></a>패턴 분류</h5><ol>
<li><p>디자인 패턴<br>일반적인 설계 문제를 해결하며, 협력하는 컴포넌트들 사이에서 반복적으로 발생하는 구조를 서술한다. </p>
</li>
<li><p>아키텍쳐 패턴<br>디자인 패턴의 상위에 있다. 소프트웨어의 전체적인 구조를 결정한다.<br>미리 정의된 서브시스템들을 제공하고, 각 서브시스템들의 책임을 정의한다.<br>서트시스템들 사이의 관계를 조직화하고 규칙과 가이드라인을 포함한다.</p>
</li>
<li><p>이디엄<br>디자인 패턴의 하위에 있다. 특정 프로그래밍 언어에만 국한된 하위 레벨 패턴이다.<br>주어진 언어의 기능을 사용해 컴포넌트, 혹은 컴포넌트간의 특정 측면을 구현하는 방법을 서술한다.<br>예를 들어, C++ 의 COUNT POINT 이디엄은 자바에서는 유용하지 않다.</p>
</li>
<li><p>분석 패턴<br>도메인 내의 개념적인 문제를 해결하는데 초점을 맞춘다.</p>
</li>
</ol>
<h5 id="패턴과-책임-주도-설계"><a href="#패턴과-책임-주도-설계" class="headerlink" title="패턴과 책임-주도 설계"></a>패턴과 책임-주도 설계</h5><p>객체지향 설계에서 중요한 일은, <code>올바른 책임을 올바른 객체에게 할당하고 객체 간의 유연한 협력 관계를 구축하는 것</code>이다.</p>
<p>패턴은 공통으로 사용할 수 있는 역할, 책임, 협력의 템플릿이다. 예를 들면,</p>
<ol>
<li><p>STRATEGY 패턴<br>다양한 알고리즘을 동적으로 교체할 수 있는 역할과 책임을 제공한다.</p>
</li>
<li><p>BRIDGE 패턴<br>추상화의 조합으로 인한 클래스의 폭발적 증가 문제를 해결하기 위해 역할과 책임을 추상화와 구현의 두 개의 커다란 집합으로 분해해서 설계를 확장가능하게 한다.</p>
</li>
<li><p>OBSERVER 패턴<br>유연한 통지 매커니즘을 구축하기 위해 객체 간의 결합도를 낮출 수 있는 역할과 책임을 제공한다.</p>
</li>
</ol>
<p>패턴의 구성 요소는 클래스가 아니라, ‘역할’ 이다.<br>예를 들어, 클라이언트가 개별 객체와 복합 객체를 동일하게 취급할 수 있는 COMPOSITE 패턴을 보자. </p>
<p><img src="/image/object_c15_01.png" alt=""></p>
<p>패턴의 구성요소인 component, composite, leaf 는 클래스가 아니라 협력에 참여하는 객체들의 역할이다. component는 역할이기 때문에 component 가 제공하는 오퍼레이션을 구현하는 어떤 객체라도 component 의 역할을 수행할 수 있다.</p>
<p><img src="/image/object_c15_02.png" alt=""></p>
<p>중복 할인 설계의 기본 구조는 COMPOSITE 패턴을 따른다.<br>디자인 패턴은 단지 역할과 책임, 협력의 템플릿을 제안할 뿐, 구체적인 구현 방법에 대해서는 제한을 두지 않는다.</p>
<h5 id="캡슐화와-디자인-패턴"><a href="#캡슐화와-디자인-패턴" class="headerlink" title="캡슐화와 디자인 패턴"></a>캡슐화와 디자인 패턴</h5><p>각 디자인 패턴은 특정한 변경을 캡슐화하기 위해 독자적인 방법을 정의하고 있다.</p>
<p><img src="/image/object_c15_03.png" alt=""></p>
<p>위 그림은 STRATEGY 패턴을 적용한 영화 예매 시스템 설계이다. 변경을 캡슐화하기 위해 합성을 이용한다. Movie 와 DiscountPolicy 사이의 결합도를 낮춰 런타임에 알고리즘을 변경할 수 있다.</p>
<p><img src="/image/object_c15_04.png" alt=""></p>
<p>위 그림은 TEMPLATE METHOD 패턴을 적용한 설계이다. 변경을 캡슐화하기 위해 상속을 이용한다. 부모 클래스의 calculateFee 메서드 안에서 추상 메서드를 호출하고 자식 클래스들이 이 메서드를 오버라이딩해서 변하는 부분을 구현하는 것이 중요하다.<br>TEMPLATE METHOD 패턴은 합성 보다는 결합도가 높은 상속을 사용했기 때문에 런타임에 객체의 알고리즘을 변경하는 것이 불가능하다. 하지만, 알고리즘 교체와 같은 요구사항이 없었으면 복잡도를 낮출 수 있다는 장점이 있다.</p>
<p><img src="/image/object_c15_05.png" alt=""></p>
<p>위 그림은 DECORATOR 패턴을 적용한 설계이다. 객체의 행동을 동적으로 추가할 수 있는 패턴으로서, 객체의 행동을 결합하기 위해 객체 합성을 사용한다.</p>
<p>디자인 패턴에서 중요한 것은, 디자인 패턴의 구현 방법이나 구조가 아니다. <code>어떤 변경을 캡슐화하는지 이해하고 변경을 캡슐화하기 위해 어떤 방법을 사용하는지</code> 이해해야한다.</p>
<h5 id="패턴은-출발점이다"><a href="#패턴은-출발점이다" class="headerlink" title="패턴은 출발점이다"></a>패턴은 출발점이다</h5><p>패턴 입문자의 문제는, 패턴을 적용하는 컨텍스트의 적절성을 무시하고 패턴의 구조에만 초점을 맞춘다는 것이다. 패턴을 적용할 때는 설계를 단순하고 명확하게 만들 수 있는 방법이 없는지를 고민해야한다. 그리고, 코드를 공유하는 모든 사람들이 적용된 패턴을 알고 있어야한다.</p>
<h2 id="02-프레임워크와-코드-재사용"><a href="#02-프레임워크와-코드-재사용" class="headerlink" title="02 프레임워크와 코드 재사용"></a>02 프레임워크와 코드 재사용</h2><h5 id="코드-재사용-대-설계-재사용"><a href="#코드-재사용-대-설계-재사용" class="headerlink" title="코드 재사용 대 설계 재사용"></a>코드 재사용 대 설계 재사용</h5><p>프레임워크란, </p>
<ol>
<li>추상 클래스나 인터페이스를 정의하고 인스턴스 사이의 상호작용을 통해 시스템 전체 혹은 일부를 구현해 놓은 재사용 가능한 설계이다. </li>
<li>또는, 애플리케이션 개바자가 현재의 요구사항에 맞게 커스터마이징할 수 있는 애플리케이션의 골격이다.</li>
</ol>
<h5 id="상위-정책과-하위-정책으로-패키지-분리하기"><a href="#상위-정책과-하위-정책으로-패키지-분리하기" class="headerlink" title="상위 정책과 하위 정책으로 패키지 분리하기"></a>상위 정책과 하위 정책으로 패키지 분리하기</h5><p>프레임워크의 핵심은, 추상 클래스나 인터페이스와 같은 추상화이다.</p>
<p><img src="/image/object_c15_06.png" alt=""></p>
<p>위 그림에서, 추상화는 짙은 색으로 표시되어 있다. <code>의존성 역전 원칙에 기반하여, 구체 클래스들은 상위 클래스에 의존하지만 추상화들은 구체 클래스에 의존하지 않는다</code>.</p>
<p>상위 정책은 상대적으로 변경에 안정적이지만 세부 사항은 자주 변경된다. 만약, 상위 정책이 자주 변하는 세부 사항에 의존하면 변경에 대한 파급 효과로 상위 정책이 불안정해진다.</p>
<p>요점은, 상위 정책이 세부 사항보다 더 다양한 상황에서 재사용할 수 있어야한다. 그래서, 상위 정책과 세부 사항 모두 추상화에 의존해야한다.</p>
<p>프레임워크는 여러 애플리케이션에 걸쳐 재사용가능해야하기 때문에, 변하는 것과 변하지 않는 것을 서로 다른 주기로 배포할 수 있도록, 배포 단위를 분리해야한다. 이를 위해, 변하는 부분과 변하지 않는 부분을 별도의 패키지로 분리할 수 있다.</p>
<p><img src="/image/object_c15_07.png" alt=""></p>
<p>중요한 것은, 패키지 사이의 의존성 방향이다. 세부사항을 구현한 패키지는 항상 상위 정책을 구현한 패키지에 의존해야한다.</p>
<p>상위 정책을 구현하고 있는 패키지를 다른 애플리케이션에 재사용할 수 있다. 즉, <code>재사용 가능한 요금 계산 로직을 구현한 프레임워크가 만들어진 것</code>이다.</p>
<h5 id="제어-역전-원리"><a href="#제어-역전-원리" class="headerlink" title="제어 역전 원리"></a>제어 역전 원리</h5><p>의존성 역전 원리는, 프레임워크의 가장 기본적인 설계 메커니즘이다. 의존성 역적은, 의존성 방향 뿐만 아니라 제어 흐름의 주체 역시 역전시킨다. 전통적인 구조에서는 상위 정책이 구체적인 세부 사항에 의존한다. 상위 정책의 코드가 하부의 구체적인 코드를 호출한다. 즉, 애플리케이션의 코드가 재사용 가능한 라이브러리나 툴킷의 코드를 호출한다.</p>
<p>하지만, 의존성을 역전 시킨 객치지향 구조에서는 반대로 프레임워크가 에플리케이션에 속하는 서브 클래스들의 메서드를 호출한다. 즉, 개별 애플리케이션에서 프레임워크로 제어 흐름의 주체가 이동한다. 이를 제어 역전 원리, 할리우드 원리라고 한다. 할리우드에서 캐스팅 담장자가 배우에게 “먼저 연락하지 마세요. 저희가 연락드릴게요” 라고 말하는 것처럼 프레임워크는 자신을 찾지 말라고 한다.</p>
<p><img src="/image/object_c15_08.png" alt=""></p>
<p>위 그림에서, 특정한 기본 정책을 구현하는 개발자는 FeeCondition 을 대체할 서브 타입만 개발하면 프레임워크에 정의된 플로우에 따라 요금이 계산된다. 프레임워크에서는 일반적인 해결책만 제공하고 애플리케이션에 따라 달라질 수 있는 특정한 동작은 비워둔다. 이렇게 완성되지 않은 채로 남겨진 동작을 hook 이라고 부른다.</p>
<hr>
<p>오브젝트 &lt;조영호&gt;</p>
</div></article></div><nav class="pagination is-centered mt-4" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/page/4/">Previous</a></div><div class="pagination-next"><a href="/page/6/">Next</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/4/">4</a></li><li><a class="pagination-link is-current" href="/page/5/">5</a></li><li><a class="pagination-link" href="/page/6/">6</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/30/">30</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://www.gravatar.com/avatar/e6a876d587c47e3ce358b830fe131aae?s=128" alt="Junhee Ko"></figure><p class="title is-size-4 is-block line-height-inherit">Junhee Ko</p><p class="is-size-6 is-block">Always Learning</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Incheon</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">300</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">14</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">0</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/ppoffice" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/kojunhee"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://www.facebook.com/kojunheee/"><i class="fab fa-facebook"></i></a></div></div></div><!--!--><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/algorithm/"><span class="level-start"><span class="level-item">Algorithm</span></span><span class="level-end"><span class="level-item tag">180</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/big-data/"><span class="level-start"><span class="level-item">Big Data</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/boost-course/"><span class="level-start"><span class="level-item">Boost Course</span></span><span class="level-end"><span class="level-item tag">15</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/git/"><span class="level-start"><span class="level-item">Git</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/jpa/"><span class="level-start"><span class="level-item">JPA</span></span><span class="level-end"><span class="level-item tag">14</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/kafka/"><span class="level-start"><span class="level-item">Kafka</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/oop/"><span class="level-start"><span class="level-item">OOP</span></span><span class="level-end"><span class="level-item tag">18</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/os/"><span class="level-start"><span class="level-item">OS</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/spark/"><span class="level-start"><span class="level-item">Spark</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/spring/"><span class="level-start"><span class="level-item">Spring</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/tdd/"><span class="level-start"><span class="level-item">TDD</span></span><span class="level-end"><span class="level-item tag">32</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/test-code/"><span class="level-start"><span class="level-item">Test Code</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/etc/"><span class="level-start"><span class="level-item">etc</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">Recent</h3><article class="media"><div class="media-content size-small"><p><time dateTime="2020-06-27T15:00:00.000Z">2020-06-28</time></p><p class="title is-6"><a class="link-muted" href="/2020/06/28/logback/">Logback</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/spring/">Spring</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-06-26T15:00:00.000Z">2020-06-27</time></p><p class="title is-6"><a class="link-muted" href="/2020/06/27/spring-expert-ch-01/">[전문가를 위한 스프링 5] 3장_Spring IoC 와 DI</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/spring/">Spring</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-06-23T15:00:00.000Z">2020-06-24</time></p><p class="title is-6"><a class="link-muted" href="/2020/06/24/unit-test-ch-05/">[실용주의 단위 테스트] 5장_좋은 테스트의 FIRST 속성</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/test-code/">Test Code</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-06-21T15:00:00.000Z">2020-06-22</time></p><p class="title is-6"><a class="link-muted" href="/2020/06/22/unit-test-ch-04/">[실용주의 단위 테스트] 4장_테스트 조직</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/test-code/">Test Code</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-06-20T15:00:00.000Z">2020-06-21</time></p><p class="title is-6"><a class="link-muted" href="/2020/06/21/rebase/">Rebase</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/git/">Git</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Advertisement</h3><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-6880109808178384" data-ad-slot="3347750970" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Always Learning" height="28"></a><p class="size-small"><span>&copy; 2020 junhee.ko</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'https://kojunhee.github.io',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to Top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>