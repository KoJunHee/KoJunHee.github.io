<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  
  <title>junhee.ko</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="always learning">
<meta property="og:type" content="website">
<meta property="og:title" content="junhee.ko">
<meta property="og:url" content="https://kojunhee.github.io/page/4/index.html">
<meta property="og:site_name" content="junhee.ko">
<meta property="og:description" content="always learning">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="junhee.ko">
<meta name="twitter:description" content="always learning">
  
    <link rel="alternate" href="/atom.xml" title="junhee.ko" type="application/atom+xml">
  
  
    <link rel="icon" href="css/images/favicon.ico">
  
  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">
  
  <link rel="stylesheet" href="/css/style.css">
  
    <link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">
  
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">junhee.ko</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">always learning</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://kojunhee.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-tdd-chapter-01" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/02/24/tdd-chapter-01/" class="article-date">
  <time class="dt-published" datetime="2020-02-23T15:00:00.000Z" itemprop="datePublished">2020-02-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/tdd/">TDD</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/02/24/tdd-chapter-01/">[테스트 주도 개발] 1장_다중 통화를 지원하는 Money 객체</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>테스트 주도 개발의 리듬은 다음과 같다.</p>
<ol>
<li>재빨리 테스트 하나 추가</li>
<li>모든 테스트 실행하고 새로 추가한 것이 실패한지 확인</li>
<li>코드를 조금 변경</li>
<li>모든 테스트 실행하고 전부 성공하는지 확인</li>
<li>리팩토링으로 중복 제거</li>
</ol>
<p>어떤 테스트들이 있어야 보고서에 제대로 계산되도록 하는 코드가 완성됐다고 확신할 수 있을까 ?</p>
<ol>
<li>통화가 다른 두 금액을 더해서 주어진 환율에 맞게 변환 금액을 결과로 얻을 수 있어야한다.</li>
<li>어떤 금액을 어떤 수에 곱한 금액을 결과로 얻을 수 있어야한다.</li>
</ol>
<p>앞으로 어떤 일을 해야하는지 알려주고, 하는 일에 집중할 수 있게 하고, 언제 일이 끝나는지 알려 줄 수 있도록 할 일 목록을 만든다. 작업이 끝난 항목에는 줄을 긋는다.</p>
<p>할일 목록에서 볼 수 있듯이 곱하기를 먼저 다룬다. 작은 것부터 시작한다. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMultiplication</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Dollar five = <span class="keyword">new</span> Dollar(<span class="number">5</span>);</span><br><span class="line">	five.times(<span class="number">2</span>);</span><br><span class="line">	AssertionErrors.assertEquals(<span class="number">10</span>, five.amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위 테스트는 아직 컴파일조차 되지 않는다. 실행은 안되더라도, 컴파일만은 되도록 만들고 싶다. 네 개의 컴파일 에러가 있다.</p>
<ol>
<li>Dollar 클래스가 없음</li>
<li>생성자가 없음</li>
<li>times(int) 메서드가 없음</li>
<li>amount 필드가 없음</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dollar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> amount;</span><br><span class="line">    </span><br><span class="line">    Dollar(<span class="keyword">int</span> amount) &#123;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">times</span><span class="params">(<span class="keyword">int</span> multiplier)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위 코드에서 times(int multiplier) 는 stub 구현이다. 이 메서드를 호출하는 코드가 컴파일 될 수 있도록 껍데기만 만들어두는 것을 의미한다.</p>
<p>테스트를 다시 실행해보자. 실패한다. 테스팅 프레임워크가 결과로 10이 나와야 하는데 0이 나왔다는 것을 알려준다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dollar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> amount = <span class="number">10</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이제 다시 실행해보면, 초록 막대가 나온다. 이제 중복을 제거할 차례이다.</p>
<blockquote>
<p>“의존성과 중복”</p>
<p>의존성이 문제 그 자체라면, 중복은 문제의 징후다.</p>
<p>만약 특정 데이터베이스 벤더가 제공하는 세세한 기능들이 코드 곳곳에서 사용되고 있으면 다른 벤더 제품으로 변경할 때 해당 벤더에 의존성을 갖고 있다는 것을 알게 된다. 즉, 코드를 변경하지 않고 벤더를 바꿀 수 없다.</p>
<p>중복의 흔한 예는 로직의 중복이다. 중복된 로직을 하나로 끄집어내는 일엔 객체를 이용하는 것이 최고다.</p>
<p>다음 테스트로 진행하기 전에 중복을 제거하면, 다음 테스트도 통과되게 만들 가능성을 최대화한다.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dollar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> amount;</span><br><span class="line"></span><br><span class="line">    Dollar(<span class="keyword">int</span> amount) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">times</span><span class="params">(<span class="keyword">int</span> multiplier)</span></span>&#123;</span><br><span class="line">        amount = <span class="number">5</span> * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>테스트는 여전히 통과한다. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dollar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> amount;</span><br><span class="line"></span><br><span class="line">    Dollar(<span class="keyword">int</span> amount) &#123;</span><br><span class="line">        <span class="keyword">this</span>.amount = amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">times</span><span class="params">(<span class="keyword">int</span> multiplier)</span> </span>&#123;</span><br><span class="line">        amount *= multiplier;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이제 첫번째 테스트를 완료했다. 다음 장에서는 Dollar 부작용에 대한 작업을 한다.</p>
<hr>
<p>테스트 주도 개발 &lt;켄트 벡&gt;</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kojunhee.github.io/2020/02/24/tdd-chapter-01/" data-id="ck8ogwsy200n7q16wrh4lgwat" data-title="[테스트 주도 개발] 1장_다중 통화를 지원하는 Money 객체" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-tdd-chapter-03" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/02/24/tdd-chapter-03/" class="article-date">
  <time class="dt-published" datetime="2020-02-23T15:00:00.000Z" itemprop="datePublished">2020-02-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/tdd/">TDD</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/02/24/tdd-chapter-03/">[테스트 주도 개발] 3장_모두를 위한 평등</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Dollar 객체같이 객체를 값처럼 쓸 수 있는 것을 객체 Value Object Pattern 이라고 한다. 값 객체에 대한 제약사항 중 하나는 객체의 인스턴스 변수가 생성자를 통해서 일단 설정된 후에는 변하지 않는다는 것이다.</p>
<p>값 객체가 암시하는 것은,</p>
<ol>
<li>모든 연산은 새 객체를 반환해야한다.</li>
<li>값 객체는 equals() 를 구현해야한다.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testEquality</span><span class="params">()</span></span>&#123;</span><br><span class="line">	assertTrue(<span class="keyword">new</span> Dollar(<span class="number">5</span>).equals(<span class="keyword">new</span> Dollar(<span class="number">5</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>빨간 막대다. 가짜로 구현하는 방법은 단순히 true 를 반환하도록 하는 것이다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object object)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(삼각측량) 예제가 두 개 이상 있으면 코드를 일반화 할 수 있다.  다음과 같이 5!=6 을 해보자.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testEquality</span><span class="params">()</span></span>&#123;</span><br><span class="line">	assertTrue(<span class="keyword">new</span> Dollar(<span class="number">5</span>).equals(<span class="keyword">new</span> Dollar(<span class="number">5</span>)));</span><br><span class="line">  assertFalse(<span class="keyword">new</span> Dollar(<span class="number">5</span>).equals(<span class="keyword">new</span> Dollar(<span class="number">6</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이제 equlity 를 일반화하자.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object object)</span></span>&#123;</span><br><span class="line">	Dollar dollar = (Dollar) object;</span><br><span class="line">	<span class="keyword">return</span> amount == dollar.amount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이렇게 어떻게 리팩토링해야하는지 감이 안오면 삼각측량을 사용하자. 코드와 테스트 사이의 중복을 제거하고 일반적인 해법을 구할 방법이 보이면 그냥 그 방법대로 구현하면 된다.</p>
<p>자, 동일성 문제는 일시적으로 해결했다. 널 값이나 다른 객체들과 비교하는 상황은 일반적이진 않지만 당장은 필요하지 않다. 할일 목록에 적어 두기만 하자.</p>
<hr>
<p>테스트 주도 개발 &lt;켄트 벡&gt;</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kojunhee.github.io/2020/02/24/tdd-chapter-03/" data-id="ck8ogwsy400ncq16wyro6rlek" data-title="[테스트 주도 개발] 3장_모두를 위한 평등" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-tdd-chapter-02" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/02/24/tdd-chapter-02/" class="article-date">
  <time class="dt-published" datetime="2020-02-23T15:00:00.000Z" itemprop="datePublished">2020-02-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/tdd/">TDD</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/02/24/tdd-chapter-02/">[테스트 주도 개발] 2장_타락한 객체</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>TDD 주기는 다음과 같다.</p>
<ol>
<li>테스트를 작성한다. </li>
<li>실행가능하게 만든다.</li>
<li>올바르게 만든다. (중복 제거)</li>
</ol>
<p>“작동하는 깔끔한 코드” 를 얻어야한다는 전체 문제 중에서, “작동하는” 에 해당하는 부분을 먼저 해결해라.</p>
<p>테스트를 하나 통과했지만, Dollar 에 대한 연산을 수행한 후에 해당 Dollar 의 값이 바뀌는 것이 이상하다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testMultiplication</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Dollar product = <span class="keyword">new</span> Dollar(<span class="number">5</span>);</span><br><span class="line">	product.times(<span class="number">2</span>);</span><br><span class="line">	assertEquals(<span class="number">10</span>, product.amount);</span><br><span class="line">	product.times(<span class="number">3</span>);</span><br><span class="line">	assertEquals(<span class="number">15</span>, product.amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>times() 를 처음 호출한 이후에 product 는 더이상 5가 아니다. times() 가 새로운 객체를 반환하면 어떨까 ?</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testMultiplication</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Dollar five = <span class="keyword">new</span> Dollar(<span class="number">5</span>);</span><br><span class="line">	Dollar product = five.times(<span class="number">2</span>);</span><br><span class="line">	assertEquals(<span class="number">10</span>, product.amount);</span><br><span class="line">	product = five.times(<span class="number">3</span>);</span><br><span class="line">	assertEquals(<span class="number">15</span>, product.amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dollar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> amount;</span><br><span class="line"></span><br><span class="line">    Dollar(<span class="keyword">int</span> amount) &#123;</span><br><span class="line">        <span class="keyword">this</span>.amount = amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Dollar <span class="title">times</span><span class="params">(<span class="keyword">int</span> multiplier)</span> </span>&#123;</span><br><span class="line">        amount *= multiplier;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위 코드는 컴파일되지만 실행되지 않는다.  통과를 위해서는 올바른 금액을 갖는 새 Dollar 를 반환해야한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dollar</span> </span>&#123;</span><br><span class="line">		...</span><br><span class="line">		</span><br><span class="line">    <span class="function">Dollar <span class="title">times</span><span class="params">(<span class="keyword">int</span> multiplier)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Dollar(amount * multiplier);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>최대한 빨리 초록색을 보기 위한 방법이 있다.</p>
<ol>
<li><p>가짜로 구현하기<br>상수를 반환하게 만들고 진짜 코드를 얻을 때 까지 단계적으로 상수를 변수로 바꾸어간다.</p>
</li>
<li><p>명백한 구현 사용하기<br>실제 구현을 입력한다.</p>
</li>
</ol>
<p>보통 실무에서는 두 방법을 번갈아 사용한다. </p>
<ol>
<li>모든일이 잘 진행되고 뭘 입력할지 알 때는 병백한 구현을 더해나간다. </li>
<li>예상치 못한 빨간 막대를 만나면 가짜로 구현하는 방법을 사용하면서 올바른 코드르 리펙토링한다. </li>
<li>그리고 다시 자신감을 찾으면 명백한 구현을 사용한다.</li>
</ol>
<hr>
<p>테스트 주도 개발 &lt;켄트 벡&gt;</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kojunhee.github.io/2020/02/24/tdd-chapter-02/" data-id="ck8ogwsy300naq16ww4ft753a" data-title="[테스트 주도 개발] 2장_타락한 객체" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-object-chapter-appendix-c" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/02/10/object-chapter-appendix-c/" class="article-date">
  <time class="dt-published" datetime="2020-02-09T15:00:00.000Z" itemprop="datePublished">2020-02-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/object/">Object</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/02/10/object-chapter-appendix-c/">[오브젝트] 부록 C 동적인 협력, 정적인 코드</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>좋은 설계는 객체 사이의 협력과 행동을 표현하는 동적 모델을 기반으로 해야한다.</p>
<ol>
<li><p>동적 모델<br>프로그램 실행 구조를 표현하는 움직이는 모델</p>
</li>
<li><p>정적 모델<br>코드의 구조를 담는 고정된 모델</p>
</li>
</ol>
<h2 id="01-동적-모델과-정적-모델"><a href="#01-동적-모델과-정적-모델" class="headerlink" title="01 동적 모델과 정적 모델"></a>01 동적 모델과 정적 모델</h2><h5 id="행동이-코드를-결정한다"><a href="#행동이-코드를-결정한다" class="headerlink" title="행동이 코드를 결정한다"></a>행동이 코드를 결정한다</h5><p>객체가 외부에 제공하는 행동이 중요하다. 동적 모델이 정적 모델을 결정해야한다.</p>
<h2 id="02-도메인-모델과-구현"><a href="#02-도메인-모델과-구현" class="headerlink" title="02 도메인 모델과 구현"></a>02 도메인 모델과 구현</h2><h5 id="도메인-모델에-관하여"><a href="#도메인-모델에-관하여" class="headerlink" title="도메인 모델에 관하여"></a>도메인 모델에 관하여</h5><ol>
<li><p>도메인<br>사용자가 프로그램을 사용하는 대상 영역</p>
</li>
<li><p>모델<br>지식을 선택적으로 단순화하고 의식적으로 구조화한 형태</p>
</li>
<li><p>도메인 모델<br>사용자가 프로그램을 사용하는 대상 영역에 대한 지식을 선택적으로 단순화하고 의식적으로 구조화한 형태</p>
</li>
</ol>
<p>소프트웨어의 도메인에 대해 고민하고 도메인 모델을 기반으로 소프트웨어를 구축해야한다. 그러면, 개념과 소프트웨어 사이의 표현적 차이를 줄일 수 있기 때문에 이해하고 수정하기 쉬온 소프트웨어를 만들 수 있다. </p>
<p>중요한 것은, 도메인 모델을 작성하는 것이 목표가 아니라 출발점이다. 중요한 것은 객체들의 협력을 지원하는 코드 구조를 만드는 것이다. 코드의 구조를 주도하는 것은 행동이다.</p>
<h5 id="행동과-변경을-고려한-도메인-모델"><a href="#행동과-변경을-고려한-도메인-모델" class="headerlink" title="행동과 변경을 고려한 도메인 모델"></a>행동과 변경을 고려한 도메인 모델</h5><p>도메인 모델은 단순히 클래스 다이어그램이 아니다. 도메인의 핵심을 간략하게 단순화해서 표현할 수 있는 모든 것이다. 이렇게 작성된 개념이 코드에 대한 구조와 행동을 드러내면 훌륭한 도메인 모델이다.</p>
<hr>
<p>오브젝트 &lt;조영호&gt;</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kojunhee.github.io/2020/02/10/object-chapter-appendix-c/" data-id="ck8ogwsy100n5q16w5vw7uq7c" data-title="[오브젝트] 부록 C 동적인 협력, 정적인 코드" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-object-chapter-appendix-b" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/02/10/object-chapter-appendix-b/" class="article-date">
  <time class="dt-published" datetime="2020-02-09T15:00:00.000Z" itemprop="datePublished">2020-02-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/object/">Object</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/02/10/object-chapter-appendix-b/">[오브젝트] 부록 B 타입 계층의 구현</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>타입과 타입 계층을 구현할 수 있는 방법들을 정리하자.</p>
<h5 id="클래스를-이용한-타입-계층-구현"><a href="#클래스를-이용한-타입-계층-구현" class="headerlink" title="클래스를 이용한 타입 계층 구현"></a>클래스를 이용한 타입 계층 구현</h5><p>타입은 객체의 퍼블릭 인터페이스이다. 클래스는 객체의 타입과 구현을 동시에 정의한 것이다.</p>
<p>Phone 클래스가 있다. Phone 의 인스턴스는 calculateFee 메시지를 수신할 수 있는 퍼블릭 메서드를 구현한다. 타입은 퍼블릭 인터페이스이기 때문에, Phone 클래스는 calculateFee 메세지에 응답할 수 있는 타입을 선언한 동시에 객체 구현을 정의한 것이다.</p>
<p>상속은, 퍼블릭 인터페이스는 유지하면서 새로운 구현을 가진 객체를 추가할 수 있는 간단한 방법이다. 하지만, 상속은 자식 클래스를 부모 클래스의 구현에 강하게 결합시킨다.</p>
<h5 id="인터페이스를-이용한-타입-계층-구현"><a href="#인터페이스를-이용한-타입-계층-구현" class="headerlink" title="인터페이스를 이용한 타입 계층 구현"></a>인터페이스를 이용한 타입 계층 구현</h5><p>인터페이스는, 상속으로 인한 결합도 문제를 피하고 다중 상속이라는 구현 제약을 해결할 수 있는 방법이다. </p>
<h5 id="추상-클래스를-이용한-타입-계층-구현"><a href="#추상-클래스를-이용한-타입-계층-구현" class="headerlink" title="추상 클래스를 이용한 타입 계층 구현"></a>추상 클래스를 이용한 타입 계층 구현</h5><p>추상 클래스는, 클래스 상속을 이용해 구현을 공유하면서도 결합도로 인한 부작용을 피하는 방법이다.</p>
<h5 id="추상-클래스와-인터페이스-결합하기"><a href="#추상-클래스와-인터페이스-결합하기" class="headerlink" title="추상 클래스와 인터페이스 결합하기"></a>추상 클래스와 인터페이스 결합하기</h5><p>인터페이스를 이용해 타입을 정의하고 특정 상속 계층에 국한된 코드를 공유할 필요가 있으면 추상 클래스를 이용해 코드 중복을 방지 할 수 있다. 이것이 골격 구현 추상 클래스이다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DiscountPolicy</span> </span>&#123;</span><br><span class="line">  <span class="function">Money <span class="title">calculateDiscountAmount</span><span class="params">(Screening screeing)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultDiscountPolicy</span> <span class="keyword">implements</span> <span class="title">DiscountPolicy</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">   </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Money <span class="title">calculateDiscountAmount</span><span class="params">(Screening screeing)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">abstract</span> <span class="keyword">protected</span> Money <span class="title">getDiscountAmount</span><span class="params">(Screeing screening)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="덕-타이핑-사용하기"><a href="#덕-타이핑-사용하기" class="headerlink" title="덕 타이핑 사용하기"></a>덕 타이핑 사용하기</h5><p>덕 테스트는 어떤 대상의 행동이 오리와 같다면 그것을 오리라는 타입으로 취급해도 무방하다는 것이다. 즉, 객체가 어떤 인터페이스에 정의된 행동을 수행할 수 있다면 그 객체를 해당 타입으로 분류해도 문제가 없다.</p>
<p>자바 같은 대부분의 정적 타입 언어에서는 두 클래스를 동일한 타입으로 취급하기 위해서는, 코드 상의 타입이 동일하게 선언되어 있어야한다. </p>
<p>반면, 런타입에 타입을 결정하는 동적 타입 언어에서는 특정한 클래스를 상속받거나 인터페이스를 구현하지 않고도 객체가 수신할 수 있는 메세지의 지합으로 객체의 타입을 결정할 수 있다.</p>
<h5 id="믹스인과-타입-계층"><a href="#믹스인과-타입-계층" class="headerlink" title="믹스인과 타입 계층"></a>믹스인과 타입 계층</h5><p>믹스인은, 객체를 생성할 때 코드 일부를 섞어 넣을 수 있도록 만들어진 일종의 추상 서브클래스이다. 사용하는 목적은, 다양한 객체의 구현 안에서 동일한 행동을 중복 코드 없이 재사용할 수 있게 만드는 것이다. 즉, 공통의 행동이 믹스인된 객체들은 동일한 메세지를 수신할 수 있는 퍼블릭 인터페이스를 공유하는 것이다. 예를 들어, 스칼라의 trait 로 구현할 수 있다.</p>
<p>스칼라의 trait 와 유사하게, 자바 8에 추가된 default method 는 인터페스에 메서드의 기본 구현을 추가하는 것을 허용한다. 디폴트 메서드가 제공하는 혜택을 누리기 위해서는 한계를 명확히 인식해야한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DiscountPolicy</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">default</span> Money <span class="title">calculateDiscountAmount</span><span class="params">(Screening screeing)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(DiscountCondition each : getConditions())&#123;</span><br><span class="line">      <span class="keyword">if</span>(each.isSatisfiedBy(screeing))&#123;</span><br><span class="line">        <span class="keyword">return</span> getDiscountAmount(screening);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> screening.getMovieFee();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function">List&lt;DiscountCondition&gt; <span class="title">getConditions</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">Money <span class="title">getDiscountAmount</span><span class="params">(Screeing screening)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>calculateDiscountAmount 가 내부적으로 두개의 메서드를 사용한다. 그래서 이 인터페이스를 구현하는 모든 클래스들은 해당 메서드의 구현을 제공해야한다는 것을 명시한 것이다.</p>
<p>추상 클래스를 사용했을 경우에는, getDiscountAmount 메서드의 가시성이 protected 였다. 하지만 이제 디폴트 메서드안에서 사용된다는 이유만으로 public 메서드가 되어야한다. 이것은 외부에 노출할 필요가 없는 메서드를 불필요하게 퍼블릭 인터페이스에 추가한 결과를 낳는다.</p>
<p>디폴트 메서드가 추가된 이유는, 인터페이스에 새로운 오퍼레이션을 추가할 경우에 발생하는 하위 호환성 문제를 해결하기 위해서이다. 추상 클래스를 제거하기 위해서가 아니다.</p>
<hr>
<p>오브젝트 &lt;조영호&gt;</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kojunhee.github.io/2020/02/10/object-chapter-appendix-b/" data-id="ck8ogwsy000n2q16wbb0t8a55" data-title="[오브젝트] 부록 B 타입 계층의 구현" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-object-chapter-appendix-a" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/02/03/object-chapter-appendix-a/" class="article-date">
  <time class="dt-published" datetime="2020-02-02T15:00:00.000Z" itemprop="datePublished">2020-02-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/object/">Object</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/02/03/object-chapter-appendix-a/">[오브젝트] 부록 A 계약에 의한 설계</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>인터페이스만으로 객체의 행동에 관한 다양한 관점을 전달하기 어렵다.<br>명령의 부수효과를 쉽고 명확하게 표현할 수 있는 커뮤니케이션 수단이, 계약에 의한 설계이다.<br>여기서 중요한 것은 코드가 아니라, 개념이다.</p>
<h2 id="01-협력과-계약"><a href="#01-협력과-계약" class="headerlink" title="01 협력과 계약"></a>01 협력과 계약</h2><h5 id="부수-효과를-명시적으로"><a href="#부수-효과를-명시적으로" class="headerlink" title="부수 효과를 명시적으로"></a>부수 효과를 명시적으로</h5><p>일반적인 정합성 체크 로직은 코드의 구현 내부에 숨겨져있어 실제로 코드를 분석하지 않는 한 정확하게 파악하기 어렵다.</p>
<p>하지만, Code Contracts 와 같이 계약에 의한 설계를 지원하는 라이브러리나 언어들은 일반 로직과 구분할 수 있도록 제약 조건을 명시적으로 표현하는 것이 가능하다.</p>
<h2 id="02-계약에-의한-설계"><a href="#02-계약에-의한-설계" class="headerlink" title="02 계약에 의한 설계"></a>02 계약에 의한 설계</h2><p>버트란드 마이어가 제시한 계약은, 사람들 사이의 계약과 유사하다. 계약은 협력에 참여하는 두 객체 사이의 의무와 이익을 문서화한 것이다.</p>
<ol>
<li>협력에 참여하는 객체는 계약으로부터 이익을 기대하고 이익을 얻기위해 의무를 이행한다.</li>
<li>협력에 참여하는 객체의 이익과 의무는 객체의 인터페이스 상에 문서화된다.</li>
</ol>
<p>의도를 드러내는 인터페이스는 오퍼레이션의 시그니처만으로 어느 정도 클라이언트와 서버가 협력을 위해 수행해야하는 제약 조건을 명시한다.</p>
<p>계약은 여기서 한 걸음 더 나아간다. 서버는 자신이 처리할 수 있는 범위의 값들을 클라이언트가 전달할 것으로 기대한다. 클아이언트는 자신이 원하는 값을 서버가 반환할 것이라고 예상한다. 클아이언트는 메세지 전송 전과 후의 서버 상태가 정상일 것이라고 기대한다.</p>
<ol>
<li><p>사전 조건<br>메서드가 호출되기 위해 만족되어야하는 조건. 클라이언트의 의무</p>
</li>
<li><p>사후 조건<br>메서드가 실행된 후에 클라이언트에게 보장해야하는 조건. 서버의 의무</p>
</li>
<li><p>불변식<br>항상 참이라고 보장되는 서버의 조건</p>
</li>
</ol>
<h5 id="사전-조건"><a href="#사전-조건" class="headerlink" title="사전 조건"></a>사전 조건</h5><p>클라이언트가 사전 조건을 만족시키지 못하면, 메서드는 최대한 빨리 실패해서 클라이언트에게 버그가 있다는 사실을 알린다.</p>
<h5 id="사후-조건"><a href="#사후-조건" class="headerlink" title="사후 조건"></a>사후 조건</h5><p>다음 세 용도로 사용된다.</p>
<ol>
<li>인스턴스 변수의 상태가 올바른지 서술하기 위해</li>
<li>메스드에 전달된 파라미터의 값이 올바르게 변경됐는지를 서술하기 위해</li>
<li>반환값이 올바른지를 서술하기 위해</li>
</ol>
<h5 id="불변식"><a href="#불변식" class="headerlink" title="불변식"></a>불변식</h5><p>객체의 내부 상태와 관련이 있다.</p>
<p>메서드 실행 중에는 객체의 상태가 불안정한 상태로 빠질 수 있기 때문에 불변식을 만족시킬 필요가 없지만, 메서드 실행 전과 종료 후에는 항상 불변식을 만족해야한다.</p>
<h2 id="03-계약에-의한-설계와-서브타이핑"><a href="#03-계약에-의한-설계와-서브타이핑" class="headerlink" title="03 계약에 의한 설계와 서브타이핑"></a>03 계약에 의한 설계와 서브타이핑</h2><p>리스코프 치환 원칙은, 슈퍼타입의 인스턴스와 협력하는 클라이언트의 관점에서 서브타입의 인스턴스가 슈퍼타입을 대체하더라도 협력에 지장이 없어야 한다는 것을 의미한다.</p>
<p>따라서 서브타입이 리스코프 치환 원칙을 만족하기 위해서는, 클라이언트와 슈퍼타입 간에 체결된 계약을 준수해야한다.</p>
<h5 id="계약-규칙"><a href="#계약-규칙" class="headerlink" title="계약 규칙"></a>계약 규칙</h5><ol>
<li><p>서브타입에 더 강력한 사전 조건을 정의할 수 없다.<br>계약서에 명시된 의무보다 더 많은 의무를 짊어져야한다는 사실을 납득하는 클라이언트는 없다.</p>
</li>
<li><p>서브타입에 더 완화된 사후 조건을 정의할 수 없다.<br>계약서에 명시된 이익보다 더 적은 이익을 받게 되는 사실을 납득하는 클라이언트는 없다.</p>
</li>
<li><p>슈퍼타입의 불변식은 서브타입에서도 유지되어야 한다.<br>메서드 실행 중에는 불변식을 만족시키지 않아도 되지만, 메서드 실행 전과 후에는 만족해야한다.</p>
</li>
</ol>
<h5 id="가변성-규칙"><a href="#가변성-규칙" class="headerlink" title="가변성 규칙"></a>가변성 규칙</h5><ol>
<li><p>서브타입은 슈퍼타입이 발생시키는 예외와 다른 타입의 예외를 발생시켜서는 안된다.<br>클라이언트는 Bird 의 인스턴스에 fly 메세지를 전송했을 때, UnsupportedOperationException 예외를 기대하지 않는다.</p>
</li>
<li><p>서브타입의 리턴타입은 공변성을 가져야한다.<br>리턴 타입 공변성 : 부모 클래스에서 구현된 메서드를 자식 클래스에서 오버라이딩할 때 부모 클래스에서 선언한 반환 타입의 서브타입으로 지정할 수 있는 특성</p>
</li>
<li><p>서브타입의 메서드 파라미터는 반공변성을 가져야 한다.<br>파라미터 타입 반공병성 : 부모 클래스에서 구현된 메서드를 자식 클래스에서 오버라이딩할 때 파라미터 타입을 부모 클래스에서 사용한 파라미터의 슈퍼타입으로 지정할 우 있는 특성</p>
</li>
</ol>
<hr>
<p>오브젝트 &lt;조영호&gt;</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kojunhee.github.io/2020/02/03/object-chapter-appendix-a/" data-id="ck8ogwsxz00n0q16wsfn93tqv" data-title="[오브젝트] 부록 A 계약에 의한 설계" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-object-chapter15" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/01/27/object-chapter15/" class="article-date">
  <time class="dt-published" datetime="2020-01-26T15:00:00.000Z" itemprop="datePublished">2020-01-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/object/">Object</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/01/27/object-chapter15/">[오브젝트] 15장_디자인 패턴과 프레임워크</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ol>
<li><p>디자인 패턴<br>특정한 변경을 일관성있게 다룰 수 있는 협력 텝플릿 제공.<br>설계를 재사용하는 것이 목적.</p>
</li>
<li><p>프레임워크<br>특정한 변경을 일관성 있게 다룰 수 있는 확장 가능한 코드 템플릿 제공.<br>설계와 코드를 함께 재사용하기 위한 것이 목적.</p>
</li>
</ol>
<h2 id="01-디자인-패턴과-설계-재사용"><a href="#01-디자인-패턴과-설계-재사용" class="headerlink" title="01 디자인 패턴과 설계 재사용"></a>01 디자인 패턴과 설계 재사용</h2><h5 id="소프트웨어-패턴"><a href="#소프트웨어-패턴" class="headerlink" title="소프트웨어 패턴"></a>소프트웨어 패턴</h5><p>패턴의 특징은,</p>
<ol>
<li>반복적으로 발생하는 문제와 해법의 쌍으로 정의된다.</li>
<li>패턴을 사용해서 이미 알려진 문제와 이에 대한 해법을 문서로 정리할 수 있다. 다른 사람과 의사소통 가능.</li>
<li>추상적인 원칙과 실제 코드 작성 사이의 간극을 메워준다. 실질적인 코드 작성을 돕는다.</li>
<li>패턴은 실무에서 탄생했다.</li>
</ol>
<p>마틴 파울러에 의하면, 패턴은 하나의 실무 컨텍스트에서 유용하게 사용해왔고 다른 실무 컨텍스트엣도 유용할 것이라고 예상되는 아이디어다. 프로젝트 조직을 구성하는 방법, 프로젝트 일정을 추정하는 방법 등 반복적인 규칙을 발견할 수 있는 모든 영역이 패턴의 대상이다.</p>
<h5 id="패턴-분류"><a href="#패턴-분류" class="headerlink" title="패턴 분류"></a>패턴 분류</h5><ol>
<li><p>디자인 패턴<br>일반적인 설계 문제를 해결하며, 협력하는 컴포넌트들 사이에서 반복적으로 발생하는 구조를 서술한다. </p>
</li>
<li><p>아키텍쳐 패턴<br>디자인 패턴의 상위에 있다. 소프트웨어의 전체적인 구조를 결정한다.<br>미리 정의된 서브시스템들을 제공하고, 각 서브시스템들의 책임을 정의한다.<br>서트시스템들 사이의 관계를 조직화하고 규칙과 가이드라인을 포함한다.</p>
</li>
<li><p>이디엄<br>디자인 패턴의 하위에 있다. 특정 프로그래밍 언어에만 국한된 하위 레벨 패턴이다.<br>주어진 언어의 기능을 사용해 컴포넌트, 혹은 컴포넌트간의 특정 측면을 구현하는 방법을 서술한다.<br>예를 들어, C++ 의 COUNT POINT 이디엄은 자바에서는 유용하지 않다.</p>
</li>
<li><p>분석 패턴<br>도메인 내의 개념적인 문제를 해결하는데 초점을 맞춘다.</p>
</li>
</ol>
<h5 id="패턴과-책임-주도-설계"><a href="#패턴과-책임-주도-설계" class="headerlink" title="패턴과 책임-주도 설계"></a>패턴과 책임-주도 설계</h5><p>객체지향 설계에서 중요한 일은, <code>올바른 책임을 올바른 객체에게 할당하고 객체 간의 유연한 협력 관계를 구축하는 것</code>이다.</p>
<p>패턴은 공통으로 사용할 수 있는 역할, 책임, 협력의 템플릿이다. 예를 들면,</p>
<ol>
<li><p>STRATEGY 패턴<br>다양한 알고리즘을 동적으로 교체할 수 있는 역할과 책임을 제공한다.</p>
</li>
<li><p>BRIDGE 패턴<br>추상화의 조합으로 인한 클래스의 폭발적 증가 문제를 해결하기 위해 역할과 책임을 추상화와 구현의 두 개의 커다란 집합으로 분해해서 설계를 확장가능하게 한다.</p>
</li>
<li><p>OBSERVER 패턴<br>유연한 통지 매커니즘을 구축하기 위해 객체 간의 결합도를 낮출 수 있는 역할과 책임을 제공한다.</p>
</li>
</ol>
<p>패턴의 구성 요소는 클래스가 아니라, ‘역할’ 이다.<br>예를 들어, 클라이언트가 개별 객체와 복합 객체를 동일하게 취급할 수 있는 COMPOSITE 패턴을 보자. </p>
<p><img src="/image/object_c15_01.png" alt></p>
<p>패턴의 구성요소인 component, composite, leaf 는 클래스가 아니라 협력에 참여하는 객체들의 역할이다. component는 역할이기 때문에 component 가 제공하는 오퍼레이션을 구현하는 어떤 객체라도 component 의 역할을 수행할 수 있다.</p>
<p><img src="/image/object_c15_02.png" alt></p>
<p>중복 할인 설계의 기본 구조는 COMPOSITE 패턴을 따른다.<br>디자인 패턴은 단지 역할과 책임, 협력의 템플릿을 제안할 뿐, 구체적인 구현 방법에 대해서는 제한을 두지 않는다.</p>
<h5 id="캡슐화와-디자인-패턴"><a href="#캡슐화와-디자인-패턴" class="headerlink" title="캡슐화와 디자인 패턴"></a>캡슐화와 디자인 패턴</h5><p>각 디자인 패턴은 특정한 변경을 캡슐화하기 위해 독자적인 방법을 정의하고 있다.</p>
<p><img src="/image/object_c15_03.png" alt></p>
<p>위 그림은 STRATEGY 패턴을 적용한 영화 예매 시스템 설계이다. 변경을 캡슐화하기 위해 합성을 이용한다. Movie 와 DiscountPolicy 사이의 결합도를 낮춰 런타임에 알고리즘을 변경할 수 있다.</p>
<p><img src="/image/object_c15_04.png" alt></p>
<p>위 그림은 TEMPLATE METHOD 패턴을 적용한 설계이다. 변경을 캡슐화하기 위해 상속을 이용한다. 부모 클래스의 calculateFee 메서드 안에서 추상 메서드를 호출하고 자식 클래스들이 이 메서드를 오버라이딩해서 변하는 부분을 구현하는 것이 중요하다.<br>TEMPLATE METHOD 패턴은 합성 보다는 결합도가 높은 상속을 사용했기 때문에 런타임에 객체의 알고리즘을 변경하는 것이 불가능하다. 하지만, 알고리즘 교체와 같은 요구사항이 없었으면 복잡도를 낮출 수 있다는 장점이 있다.</p>
<p><img src="/image/object_c15_05.png" alt></p>
<p>위 그림은 DECORATOR 패턴을 적용한 설계이다. 객체의 행동을 동적으로 추가할 수 있는 패턴으로서, 객체의 행동을 결합하기 위해 객체 합성을 사용한다.</p>
<p>디자인 패턴에서 중요한 것은, 디자인 패턴의 구현 방법이나 구조가 아니다. <code>어떤 변경을 캡슐화하는지 이해하고 변경을 캡슐화하기 위해 어떤 방법을 사용하는지</code> 이해해야한다.</p>
<h5 id="패턴은-출발점이다"><a href="#패턴은-출발점이다" class="headerlink" title="패턴은 출발점이다"></a>패턴은 출발점이다</h5><p>패턴 입문자의 문제는, 패턴을 적용하는 컨텍스트의 적절성을 무시하고 패턴의 구조에만 초점을 맞춘다는 것이다. 패턴을 적용할 때는 설계를 단순하고 명확하게 만들 수 있는 방법이 없는지를 고민해야한다. 그리고, 코드를 공유하는 모든 사람들이 적용된 패턴을 알고 있어야한다.</p>
<h2 id="02-프레임워크와-코드-재사용"><a href="#02-프레임워크와-코드-재사용" class="headerlink" title="02 프레임워크와 코드 재사용"></a>02 프레임워크와 코드 재사용</h2><h5 id="코드-재사용-대-설계-재사용"><a href="#코드-재사용-대-설계-재사용" class="headerlink" title="코드 재사용 대 설계 재사용"></a>코드 재사용 대 설계 재사용</h5><p>프레임워크란, </p>
<ol>
<li>추상 클래스나 인터페이스를 정의하고 인스턴스 사이의 상호작용을 통해 시스템 전체 혹은 일부를 구현해 놓은 재사용 가능한 설계이다. </li>
<li>또는, 애플리케이션 개바자가 현재의 요구사항에 맞게 커스터마이징할 수 있는 애플리케이션의 골격이다.</li>
</ol>
<h5 id="상위-정책과-하위-정책으로-패키지-분리하기"><a href="#상위-정책과-하위-정책으로-패키지-분리하기" class="headerlink" title="상위 정책과 하위 정책으로 패키지 분리하기"></a>상위 정책과 하위 정책으로 패키지 분리하기</h5><p>프레임워크의 핵심은, 추상 클래스나 인터페이스와 같은 추상화이다.</p>
<p><img src="/image/object_c15_06.png" alt></p>
<p>위 그림에서, 추상화는 짙은 색으로 표시되어 있다. <code>의존성 역전 원칙에 기반하여, 구체 클래스들은 상위 클래스에 의존하지만 추상화들은 구체 클래스에 의존하지 않는다</code>.</p>
<p>상위 정책은 상대적으로 변경에 안정적이지만 세부 사항은 자주 변경된다. 만약, 상위 정책이 자주 변하는 세부 사항에 의존하면 변경에 대한 파급 효과로 상위 정책이 불안정해진다.</p>
<p>요점은, 상위 정책이 세부 사항보다 더 다양한 상황에서 재사용할 수 있어야한다. 그래서, 상위 정책과 세부 사항 모두 추상화에 의존해야한다.</p>
<p>프레임워크는 여러 애플리케이션에 걸쳐 재사용가능해야하기 때문에, 변하는 것과 변하지 않는 것을 서로 다른 주기로 배포할 수 있도록, 배포 단위를 분리해야한다. 이를 위해, 변하는 부분과 변하지 않는 부분을 별도의 패키지로 분리할 수 있다.</p>
<p><img src="/image/object_c15_07.png" alt></p>
<p>중요한 것은, 패키지 사이의 의존성 방향이다. 세부사항을 구현한 패키지는 항상 상위 정책을 구현한 패키지에 의존해야한다.</p>
<p>상위 정책을 구현하고 있는 패키지를 다른 애플리케이션에 재사용할 수 있다. 즉, <code>재사용 가능한 요금 계산 로직을 구현한 프레임워크가 만들어진 것</code>이다.</p>
<h5 id="제어-역전-원리"><a href="#제어-역전-원리" class="headerlink" title="제어 역전 원리"></a>제어 역전 원리</h5><p>의존성 역전 원리는, 프레임워크의 가장 기본적인 설계 메커니즘이다. 의존성 역적은, 의존성 방향 뿐만 아니라 제어 흐름의 주체 역시 역전시킨다. 전통적인 구조에서는 상위 정책이 구체적인 세부 사항에 의존한다. 상위 정책의 코드가 하부의 구체적인 코드를 호출한다. 즉, 애플리케이션의 코드가 재사용 가능한 라이브러리나 툴킷의 코드를 호출한다.</p>
<p>하지만, 의존성을 역전 시킨 객치지향 구조에서는 반대로 프레임워크가 에플리케이션에 속하는 서브 클래스들의 메서드를 호출한다. 즉, 개별 애플리케이션에서 프레임워크로 제어 흐름의 주체가 이동한다. 이를 제어 역전 원리, 할리우드 원리라고 한다. 할리우드에서 캐스팅 담장자가 배우에게 “먼저 연락하지 마세요. 저희가 연락드릴게요” 라고 말하는 것처럼 프레임워크는 자신을 찾지 말라고 한다.</p>
<p><img src="/image/object_c15_08.png" alt></p>
<p>위 그림에서, 특정한 기본 정책을 구현하는 개발자는 FeeCondition 을 대체할 서브 타입만 개발하면 프레임워크에 정의된 플로우에 따라 요금이 계산된다. 프레임워크에서는 일반적인 해결책만 제공하고 애플리케이션에 따라 달라질 수 있는 특정한 동작은 비워둔다. 이렇게 완성되지 않은 채로 남겨진 동작을 hook 이라고 부른다.</p>
<hr>
<p>오브젝트 &lt;조영호&gt;</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kojunhee.github.io/2020/01/27/object-chapter15/" data-id="ck8ogwt0d00qqq16w6mp7xkmo" data-title="[오브젝트] 15장_디자인 패턴과 프레임워크" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-kafka-chapter8" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/01/26/kafka-chapter8/" class="article-date">
  <time class="dt-published" datetime="2020-01-25T15:00:00.000Z" itemprop="datePublished">2020-01-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/kafka/">Kafka</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/01/26/kafka-chapter8/">[카프카] 8장_카프카 스트림즈 API</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>카프카 스트림즈 API 를 통해 스트림을 처리하는 방법을 정리한다.</p>
<h2 id="1-스트림-프로세싱-기초"><a href="#1-스트림-프로세싱-기초" class="headerlink" title="1. 스트림 프로세싱 기초"></a>1. 스트림 프로세싱 기초</h2><h4 id="1-1-스트림-프로세싱과-배치-프로세싱"><a href="#1-1-스트림-프로세싱과-배치-프로세싱" class="headerlink" title="1.1 스트림 프로세싱과 배치 프로세싱"></a>1.1 스트림 프로세싱과 배치 프로세싱</h4><p>오늘날 데이터 분석 시스템은 스트림 처리 시스템과 배치 처리 시스템을 모두 갖추어서 실시간과 정확성을 보장한다.</p>
<ol>
<li><p>스트림 프로세싱<br>데이터들이 지속적으로 유입되고 나가는 과정에서 데이터에 대한 분석이나 질의를 수행하는 것이다.<br>데이터가 분석 시스템이나 프로그램에 도달하자마자 처리를 해서 실시간 분석이라고도 한다.</p>
</li>
<li><p>배치 처리<br>이미 저장된 데이터를 기반으로 분석이나 질의를 수행하고 특정 시간에 처리하는 것이다.</p>
</li>
</ol>
<p>스티름 프로세싱의 장점은,</p>
<ol>
<li>이벤트 발생, 분석, 조치에 지연시간이 없기 때문에, <code>최신의 데이터</code>를 반영한다.</li>
<li>데이터 저장 후 분석을 하지 않으므로, 정적 분석보다 <code>더 많은 데이터를 분석</code>할 수 있다.</li>
<li>시간에 따라 <code>지속적으로 유입되는 데이터 분석에 최적화</code>되어 있다.</li>
<li>대규모 공유 데이터베이스에 대한 요구를 줄일 수 있어 <code>인프라에 독립적</code>으로 수행될 수 있다.</li>
</ol>
<h4 id="1-2-상태-기반-스트림-처리-무상태-스트림-처리"><a href="#1-2-상태-기반-스트림-처리-무상태-스트림-처리" class="headerlink" title="1.2 상태 기반 스트림 처리, 무상태 스트림 처리"></a>1.2 상태 기반 스트림 처리, 무상태 스트림 처리</h4><ol>
<li><p>상태 기반 스트림 처리<br><code>이전 스트림을 처리한 결과를 참조하는 방식</code>의 처리이다.<br>애플리케이션에서 각각의 이벤트를 처리하고 결과를 저장할 상태 저장소가 필요하다.</p>
</li>
<li><p>무상태 스트림 처리<br>이전 스트림의 처리 결과와 관계 없이, <code>현재 애플리케이션에 도달한 스트림만을 기준으로 처리</code>한다. </p>
</li>
</ol>
<h2 id="2-카프카-스트림즈"><a href="#2-카프카-스트림즈" class="headerlink" title="2. 카프카 스트림즈"></a>2. 카프카 스트림즈</h2><h4 id="2-1-카프카-스트림즈의-특징과-개념"><a href="#2-1-카프카-스트림즈의-특징과-개념" class="headerlink" title="2.1 카프카 스트림즈의 특징과 개념"></a>2.1 카프카 스트림즈의 특징과 개념</h4><p>카프카 스트림즈는 카프카에 저장된 데이터를 처리하고 분석하기 위해 개발된 클라이언트 라이브러리이다.<br>카프카 스트림즈의 특징은,</p>
<ol>
<li>간단하고 가벼운 클라이언트 라이브러리이다.</li>
<li>시스템이나 카프카에 대한 의존성이 없다.</li>
<li>이중화된 로컬 상태 저장소를 지원한다.</li>
<li>카프카 브로커나 클라이언트에 장애가 생겨도, 스트림에 대해선 1번만 처리되도록 보장한다.</li>
<li>한 번에 한 레코드만 처리한다.</li>
<li>고수준의 스트림 DSL 를 지원하고, 저수준의 프로세싱 API 도 제공한다.</li>
</ol>
<p>카프카 스트림즈는 <code>스트림 처리를 하는 프로세서들이 서로 연결되어 항상 Topology 를 만들어 처리하는 API</code> 이다.</p>
<p>다음 그림은 카프카 스트림즈 프로세스 토폴리지의 예이다.</p>
<p><img src="/image/kafka_chapter08_01.png" alt></p>
<p>프로세서 토폴리지 중에는 특별한 프로세서가 있다.</p>
<ol>
<li><p>소스 프로세서<br>위 쪽에 연결된 프로세서가 없는 프로세서이다.<br>하나 이상의 카프카 토픽에서 데이터 레코드를읽어 아래 쪽 프로세서에 전달한다.</p>
</li>
<li><p>싱크 프로세서<br>아래 쪽에 연결된 프로세서가 없는 프로세서이다.<br>상위 프로세서로부터. 받은 데이터 레코드를 특정 토픽에 저장한다.</p>
</li>
</ol>
<p>카프카 스트림즈는 이와같은 프로세서들을 만드는 2가지 방법을 제공한다.</p>
<ol>
<li><p>카프카 스트림즈 DSL 에서 데이터 처리를 할 때 공통적으로 필요한 데이터 프로세싱 메서드를 제공<br>ex) map, filter, join, aggregations</p>
</li>
<li><p>프로세서 API 를 제공해서 저수준의 처리를 직접할 수 있게 하는 것이다.</p>
</li>
</ol>
<h4 id="2-2-카프카-스트림즈-아키텍처"><a href="#2-2-카프카-스트림즈-아키텍처" class="headerlink" title="2.2 카프카 스트림즈 아키텍처"></a>2.2 카프카 스트림즈 아키텍처</h4><p>카프카 스트림즈에 들어오는 데이터는 카프카 토픽의 메세지이다.<br>카프카 토픽과 스트림의 관계는,</p>
<ol>
<li>각 스트림 파티션은 카프카의 토픽 파티션에 저장된 졍렬된 메세지이다.</li>
<li>스트림의 데이터 레코드는 카프카 해당 토픽의 메세지이다.</li>
<li>데이터 레코드의 키를 통해 다음 스트림으로 전달된다.</li>
</ol>
<p>카프카 스트림즈는 입력 스트림의  파티션 개수만큼 태스크를 생성한다.<br>각 태스크에는 입력 스트림, 즉 카프카 토픽 파티션들이 할당된다. 이것은 한번 정해지면 입력 토픽의 파티션이 변하지 않는한 변하지 않는다.<br>카프카 스트림즈는 사용자가 스레드의 개수를 지정할 수 있게 한다. 1개의 스레드는 1개 이상의 테스크를 처리할 수 있다. 다음 그림은 1개의 스레드에서 2개의 테스크가 수행되는 모습이다.</p>
<p><img src="/image/kafka_chapter08_02.png" alt></p>
<h2 id="3-파이프-예제-프로그램"><a href="#3-파이프-예제-프로그램" class="headerlink" title="3. 파이프 예제 프로그램"></a>3. 파이프 예제 프로그램</h2><p><img src="/image/kafka_chapter08_03.png" alt></p>
<p>단순히 한쪽 토픽에 입력된 값을 다른 쪽 토픽으로 옮기는 역할을 수행한다.</p>
<h2 id="4-행-분리-예제-프로그램"><a href="#4-행-분리-예제-프로그램" class="headerlink" title="4. 행 분리 예제 프로그램"></a>4. 행 분리 예제 프로그램</h2><p><img src="/image/kafka_chapter08_04.png" alt></p>
<p>한쪽 토픽에서 읽은 데이터를 공백 기준으로 분리해서 값으로 다른 토픽에 저장하는 역할을 수행한다.</p>
<h2 id="5-단어-빈도수-세기-예제-프로그램"><a href="#5-단어-빈도수-세기-예제-프로그램" class="headerlink" title="5. 단어 빈도수 세기 예제 프로그램"></a>5. 단어 빈도수 세기 예제 프로그램</h2><p><img src="/image/kafka_chapter08_05.png" alt></p>
<p>지금까지는 이전 데이터에 영향을 받지 않고, 스트림에 들어온 현재 데이터만을 처리하는 무상태 형태의 애플리케이션이었다.<br>이번에는 이전 스트림에서 처리한 단어의 빈도를 계산에 넣어서 현재까지의 총 단어 빈도를 구하는 상태 기반 형태의 애플리케이션이다.</p>
<hr>
<p>카프카, 데이터 플랫폼의 최강자 &lt;고승범, 공용준&gt;</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kojunhee.github.io/2020/01/26/kafka-chapter8/" data-id="ck8ogwsxy00mxq16wmksd7aj6" data-title="[카프카] 8장_카프카 스트림즈 API" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-kafka-chapter7" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/01/26/kafka-chapter7/" class="article-date">
  <time class="dt-published" datetime="2020-01-25T15:00:00.000Z" itemprop="datePublished">2020-01-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/kafka/">Kafka</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/01/26/kafka-chapter7/">[카프카] 7장_데이터 파이프라인 구축</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>데이터 파이프라인을 직접 구성해본다. 다음 애플리케이션을 사용한다.</p>
<ol>
<li>아파치 나이파이</li>
<li>엘라스틱 파일비트</li>
<li>엘라스틱 엘라스틱서치</li>
<li>엘라스틱 키바나</li>
</ol>
<h2 id="1-카프카를-활용한-데이터-흐름도"><a href="#1-카프카를-활용한-데이터-흐름도" class="headerlink" title="1. 카프카를 활용한 데이터 흐름도"></a>1. 카프카를 활용한 데이터 흐름도</h2><p><img src="/image/kafka_chapter07_01.png" alt></p>
<p>카프카에서 발생하는 로그를 이용해 데이터 흐름도를 구성해본다.<br>아파치 나이파이는 데이터 처리 흐름을 정의하고, 정의된 흐름대로 자동으로 실행해주는 애플리케이션이다.</p>
<ol>
<li>데이터 흐름을 처리하기 위한 워크플로우</li>
<li>데이터 처리</li>
</ol>
<h2 id="2-파일-비트를-이용한-메세지-전송"><a href="#2-파일-비트를-이용한-메세지-전송" class="headerlink" title="2. 파일 비트를 이용한 메세지 전송"></a>2. 파일 비트를 이용한 메세지 전송</h2><p>카프카의 로그를 카프카의 토픽으로 전송하려면 프로듀서가 필요하다. 프로듀서는,</p>
<ol>
<li>카프카 클라이언트 라이브러리를 이용해 프로그램으로 직접 구현</li>
<li>오픈소스 애플리케이션 이용. 여기서는 파일 비트.</li>
</ol>
<h2 id="3-나이파이를-이용해-메세지-가져오기"><a href="#3-나이파이를-이용해-메세지-가져오기" class="headerlink" title="3. 나이파이를 이용해 메세지 가져오기"></a>3. 나이파이를 이용해 메세지 가져오기</h2><p>이제 컨슈머를 이용해 카프카 토픽으로부터 메세지를 가져와와야한다. 컨슈머는,</p>
<ol>
<li>프로그래밍 언어로 직접 구현</li>
<li>오픈소스 애플리케이션 이용. 여기서는 나이파이.</li>
</ol>
<h4 id="3-1-나이파이를-이용한-컨슈머-설정"><a href="#3-1-나이파이를-이용한-컨슈머-설정" class="headerlink" title="3.1 나이파이를 이용한 컨슈머 설정"></a>3.1 나이파이를 이용한 컨슈머 설정</h4><p><img src="/image/kafka_chapter07_02.png" alt></p>
<p>프로세서를 추가하는 화면이다.<br>프로세서는 나이파이에서 데이터 처리를 위한 각각의 컴포넌트이다. AMQP 컨슘, 파일로 저장, 전송하기 등 여러가지 작업이 가능하다.<br>ConsumeKafka 프로세서를 추가하고 재생 버튼을 누르면, 설정한 브로커의 토픽에서 메세지를 가져오기 시작한다.<br>컨슈머가 잘 동작하는지 확인하는 방법은,</p>
<ol>
<li><p>나이파이에서 컨슈머 프로세서를 실행 시킨 후,</p>
</li>
<li><p>카프카 컨슈머 그룹 리스트에서, 등록한 컨슈머 그룹이 잘 등록되었는지 확인한다.<br>등록한 컨슈머 그룹 : ConsumeKafka 프로세서의 Properties 를 정의할 때 그룹 ID 를 기입했음.</p>
</li>
</ol>
<h2 id="4-실시간-분석을-위해-엘라스틱서치에-메세지-저장"><a href="#4-실시간-분석을-위해-엘라스틱서치에-메세지-저장" class="headerlink" title="4. 실시간 분석을 위해 엘라스틱서치에 메세지 저장"></a>4. 실시간 분석을 위해 엘라스틱서치에 메세지 저장</h2><p>이제, 가져온 메세지들을 나이파이의 또 다른 프로세서를 이용해 엘라스틱서치에 저장하겠다.<br>엘라스틱서치는 엘라스틱 사의 분산형 RESTFul 검색 및 분석 엔진이다. 전문 검색 질의를 이용해 원하는 데이터 분석을 빠르게 할 수 있는 애플리케이션이다.</p>
<h4 id="4-1-나이파이를-이용해-엘라스틱서치로-데이터-전송"><a href="#4-1-나이파이를-이용해-엘라스틱서치로-데이터-전송" class="headerlink" title="4.1 나이파이를 이용해 엘라스틱서치로 데이터 전송"></a>4.1 나이파이를 이용해 엘라스틱서치로 데이터 전송</h4><p>PutElasticsearchHttp 프로세서를 추가한다. 데이터를 엘라스틱서치로 넣어주는 역할을 한다.<br>그리고 다음 화면처럼, ConsumeKafka 와 연결한다.</p>
<p><img src="/image/kafka_chapter07_03.png" alt></p>
<p>데이터 흐름 중에 뒤에 있는 프로세서에서 처리 속도가 느려 바로 처리하지 못하거나 프로세서에 문제가 발생한 경우, 두 프로세스를 연결하는 큐에 레코드가 쌓인다.</p>
<h2 id="5-키바나를-이용해-엘라스틱서치에-저장된-데이터-확인"><a href="#5-키바나를-이용해-엘라스틱서치에-저장된-데이터-확인" class="headerlink" title="5. 키바나를 이용해 엘라스틱서치에 저장된 데이터 확인"></a>5. 키바나를 이용해 엘라스틱서치에 저장된 데이터 확인</h2><p>웹브라우저를 이용해 원하는 시간대에 발생한 로그들을 확인할 수 있고, 필터 기능으로 원하는 패턴의 로그만 빠르게 검색 가능하다.<br>각 브로커에서 수집되는 로그가 카프카의 토픽에 있기 때문에, 엘라스틱 서치에 전송하는 것 외에 추가로 하둡이나 로컬에 저장하길 원하면, 다음 화면처럼 나이파이의 PutHDFS 프로세서를 추가해 쉽게 하둡 등의 저장소에 저장할 수 있다.</p>
<p><img src="/image/kafka_chapter07_04.png" alt></p>
<h2 id="6-현재의-토픽을-이용해-새로운-토픽으로-메세지-재생산"><a href="#6-현재의-토픽을-이용해-새로운-토픽으로-메세지-재생산" class="headerlink" title="6. 현재의 토픽을 이용해 새로운 토픽으로 메세지 재생산"></a>6. 현재의 토픽을 이용해 새로운 토픽으로 메세지 재생산</h2><p><img src="/image/kafka_chapter07_05.png" alt></p>
<p>이번에는, 메세지의 양이 굉장히 많은 토픽의 내용 중 필요한 메세지만 꺼내서 다시 새로운 토픽으로 메세지를 보내는 방법을 정리한다.</p>
<p>전체적인 데이터 흐름은,</p>
<ol>
<li>나이파이 컨슈머가 peter-log 로부터 로그 메세지를 가져오면서 호스트 이름을 확인한다.</li>
<li>peter-log 토픽으로 로그 메세지를 보내는 서버는 peter-kafka001,peter-kafka002, peter-kafka003 모두 3대이다.</li>
<li>각각의 메세지마다 호스트 이름이 peter-kafka001,ppeter-kafka002, ppeter-kafka003 이 기록되어 있다.</li>
<li>전체 메세지 중에 호스트 이름이 peter-kafka001메세지만 peter-kafka001토픽으로 다시 전송하고,</li>
<li>나머지 메세지는 peter-failure 토픽으로 전송한다.</li>
</ol>
<h4 id="6-1-나이파이를-이용한-토픽별-라우팅"><a href="#6-1-나이파이를-이용한-토픽별-라우팅" class="headerlink" title="6.1 나이파이를 이용한 토픽별 라우팅"></a>6.1 나이파이를 이용한 토픽별 라우팅</h4><p>나이파이에서 토픽의 메세지를 가져와서 peter-kafka001 에서 온 메세지인지 확인한 후에 peter-kafka001 토픽으로 전송해야한다.<br>이를 위해, 나이파이의 EvaluateJsonPath, RouteOnAttribute 프로세서를 추가해서 라우팅 작업을 한다.</p>
<ol>
<li>EvaluateJsonPath 프로서는, 토픽으로 전송된 JSON 의 beat.hostname 을 읽어 호스트 이름을 구분한다.</li>
<li>RouteOnAttribute 프로세서는, attrubute 를 이용해 라우팅을 한다.</li>
</ol>
<p>마지막으로, 카프카 프로듀서 2개를 추가한다.</p>
<ol>
<li>호스트명이 peter-kafka001 인 메세지를  peter-kafka001 토픽으로 전송할 프로듀서</li>
<li>그 외 메세지를  peter-failure 토픽으로 전송할 프로듀서</li>
</ol>
<p>최종 플로우는 다음과 같다.</p>
<p><img src="/image/kafka_chapter07_06.png" alt></p>
<hr>
<p>카프카, 데이터 플랫폼의 최강자 &lt;고승범, 공용준&gt;</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kojunhee.github.io/2020/01/26/kafka-chapter7/" data-id="ck8ogwsxx00mwq16wko1uoqmu" data-title="[카프카] 7장_데이터 파이프라인 구축" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-object-chapter14" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/01/20/object-chapter14/" class="article-date">
  <time class="dt-published" datetime="2020-01-19T15:00:00.000Z" itemprop="datePublished">2020-01-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/object/">Object</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/01/20/object-chapter14/">[오브젝트] 14장_일관성 있는 협력</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="01-핸드폰-과금-시스템-변경하기"><a href="#01-핸드폰-과금-시스템-변경하기" class="headerlink" title="01 핸드폰 과금 시스템 변경하기"></a>01 핸드폰 과금 시스템 변경하기</h2><p><img src="/image/object_cowork_chapter14.png" alt></p>
<h5 id="기본-정책-확장"><a href="#기본-정책-확장" class="headerlink" title="기본 정책 확장"></a>기본 정책 확장</h5><ol>
<li><p>고정 요금 방식</p>
<p>ex ) 10초당 18원</p>
</li>
<li><p>시간대별 방식</p>
<p>ex ) 00시-19시 : 10초당 19월, 19시-24시 : 10초당 15원</p>
</li>
<li><p>요일별 방식</p>
<p>ex ) 평일 : 10초당 38원, 공휴일 : 10초당 19원</p>
</li>
<li><p>구간별 방식</p>
<p>ex) 초기 1분 : 10초당 50원, 초기 1분 이후 : 10초당 20원</p>
</li>
</ol>
<h5 id="고정-요금-방식-구현하기"><a href="#고정-요금-방식-구현하기" class="headerlink" title="고정 요금 방식 구현하기"></a>고정 요금 방식 구현하기</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FixedFeePolicy</span> <span class="keyword">extends</span> <span class="title">BasicRatePolicy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Money amount;</span><br><span class="line">    <span class="keyword">private</span> Duration duration;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FixedFeePolicy</span><span class="params">(Money amount, Duration duration)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.amount = amount;</span><br><span class="line">        <span class="keyword">this</span>.duration = duration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Money <span class="title">calculateCallFee</span><span class="params">(Call call)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> amount.times(call.getDuration().getSeconds() / seconds.getSeconds());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="시간대별-방식-구현하기"><a href="#시간대별-방식-구현하기" class="headerlink" title="시간대별 방식 구현하기"></a>시간대별 방식 구현하기</h5><p>TimeOfDayDiscountPolicy 클래스에서 가장 중요한 것은, 시간에 따라 서로 다른 요금 규칙을 정의하는 방법을 결정하는 것이다. </p>
<p>이를 위해 서로 다른 List 를 가질 수 있다. 같은 규칙에 포함된 요소들은 List 의 동일한 인덱스에 위치한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeOfDayDiscountPolicy</span> <span class="keyword">extends</span> <span class="title">BasicRatePolicy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;LocalTime&gt; starts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> List&lt;LocalTime&gt; ends = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> List&lt;LocalTime&gt; duration = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> List&lt;Money&gt; amounts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Money <span class="title">calculateCallFee</span><span class="params">(Call call)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="요일별-방식-구현하기"><a href="#요일별-방식-구현하기" class="headerlink" title="요일별 방식 구현하기"></a>요일별 방식 구현하기</h5><p>시간대별 방식의 4개 List 와 다르게, 규칙을 DayOfWeekDiscountRule 이라는 하나의 클래스로 구현해보자.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DayOfWeekDiscountRule</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;DayOfWeek&gt; dayOfWeeks = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Duration duration = Duration.ZERO;</span><br><span class="line">    <span class="keyword">private</span> Money amount = Money.ZERO;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DayOfDiscountRule</span><span class="params">(List&lt;DayOfWeek&gt; dayOfWeeks, Duration duration, Money amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dayOfWeeks = dayOfWeeks;</span><br><span class="line">        <span class="keyword">this</span>.duration = duration;</span><br><span class="line">        <span class="keyword">this</span>.amount = amount;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Money <span class="title">caculate</span><span class="params">(DateTimeInterval interval)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dayOfWeeks.contains(interval.getFrom().getDayOfWeek()))&#123;</span><br><span class="line">            <span class="keyword">return</span> ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DayOfWeekDiscountPolicy</span> <span class="keyword">extends</span> <span class="title">BasicRatePolicy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;DayOfWeekDiscountRule&gt; rules = <span class="keyword">new</span> ArrayList&lt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DayOfWeekDiscountPolicy</span><span class="params">(List&lt;DayOfWeekDiscountPolicy&gt; rules)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rules = rules;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Money <span class="title">calculateCallFee</span><span class="params">(Call call)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="구간별-방식-구현하기"><a href="#구간별-방식-구현하기" class="headerlink" title="구간별 방식 구현하기"></a>구간별 방식 구현하기</h5><p>(구간별 방식 구현 코드는 생략)</p>
<p>지금까지의 구현의 가장 큰 문제는, 이 클래스들이 <code>유사한 문제를 해결하고 있음에도 불구하고 설계에 일관성이 없다</code>는 것이다.</p>
<h2 id="02-설계에-일관성-부여하기"><a href="#02-설계에-일관성-부여하기" class="headerlink" title="02 설계에 일관성 부여하기"></a>02 설계에 일관성 부여하기</h2><p><code>협력을 일관성 있게</code> 만들기 위해서는,</p>
<ol>
<li>변하는 개념을 변하지 않는 개념으로 분리하라.</li>
<li>변하는 개념을 캡슐하하라.</li>
</ol>
<h5 id="조건-로직-객체-탐색"><a href="#조건-로직-객체-탐색" class="headerlink" title="조건 로직 객체 탐색"></a>조건 로직 객체 탐색</h5><p>4장의 절차적인 방식으로 구현했던 ReservationAgency 코드를 보자.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReservationAgency</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Reservation <span class="title">reservation</span><span class="params">(Screening screening, Customer customer, <span class="keyword">int</span> audienceCount)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(DiscountCondition condition : movie.getDiscountConditions()&#123;</span><br><span class="line">            <span class="keyword">if</span>(condition.getType() == DiscountCondition.PERIOD)&#123;</span><br><span class="line">                <span class="comment">//기간조건</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//회차 조건</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span>(discountable)&#123;</span><br><span class="line">            <span class="keyword">switch</span> (movie.getMovieType())&#123;</span><br><span class="line">                <span class="keyword">case</span> AMOUNT_DISCOUNT:</span><br><span class="line">                    <span class="comment">//금액할인 정책</span></span><br><span class="line">                <span class="keyword">case</span> PERCENT_DISCOUNT:</span><br><span class="line">                    <span class="comment">// 비율 할인 정책</span></span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>객체지향에서는, 변경을 다루는 전통적인 방법은 조건 로직을 객체 사이의 이동으로 바꾸는 것이다.</p>
<p><img src="/image/object_movie_chapter14.png" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Movie</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DiscountPolicy discountPolicy;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Money <span class="title">calculateMovieFee</span><span class="params">(Screening screening)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fee.minus(discountPolicy.calculateDiscountAmount(screening));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscountPolicy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;DiscountCondition&gt; conditions = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Money <span class="title">calculateDiscountAmount</span><span class="params">(Screening screening)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(DiscountCondition each : conditions)&#123;</span><br><span class="line">            <span class="keyword">if</span>(each.isSatisfiedBy(screening))&#123;</span><br><span class="line">                <span class="keyword">return</span> getDiscountAmount(screening);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> screening.getMovieFee();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>객체지향적인 코드는 조건을 판단하지 않는다. 단지 다음 객체로 이동할 뿐이다.</p>
<ol>
<li><p>Movie 는 현재의 할인 정책이 어떤 종류인지 판단하지 않는다. 단지 DiscountPolicy 로 향하는 참조를 통해 메세지를 전달할 뿐이다. </p>
</li>
<li><p>DiscountPolicy 역시 할인 조건의 종류를 판단하지 않는다. 단지 DiscountCondition 으로 향하는 참조를 통해 메세지를 전단할 뿐이다.</p>
</li>
</ol>
<p><code>협력을 일관성 있게</code> 만들기 위한 방법을 다시 정리하면,</p>
<ol>
<li><p>변하는 개념을 변하지 않는 개념으로 분리하라.</p>
<p>각 조건문을 개별적인 객체로 분리했고 이 객체들을 일관성 있게 협력하기 위해 타입 계층을 구성했다.</p>
</li>
<li><p>변하는 개념을 캡슐하하라.</p>
<p>Movie 가 알고 있는 사실은 협력하는 객체가 단지 DiscountPolicy 클래스의 인터페이스에 정의된 calculateDiscountAmount 메세지를 이해할 수 있다는 것 뿐이다. </p>
<p>메세지 수신자 타입은 Movie 에 대해 완벽히 캡슐화되었다.</p>
</li>
</ol>
<h5 id="캡슐화-다시-살펴보기"><a href="#캡슐화-다시-살펴보기" class="headerlink" title="캡슐화 다시 살펴보기"></a>캡슐화 다시 살펴보기</h5><p>캡슐화란 변하는 어떤 것이든 감추는 것이다.</p>
<p>다음 그림에는 다양한 종류의 캡슐화가 공존한다.</p>
<p><img src="/image/object_encapsulation_chapter14.png" alt></p>
<ol>
<li><p>데이터 캡슐화</p>
<p>클래스는 내부에 관리하는 데이터를 캡슐화한다.</p>
</li>
<li><p>메서드 캡슐화</p>
<p>DiscountPolicy 클래스에 정의된 getDiscountAmount 메서드의 가시성은 protected 이다.</p>
<p>즉, 클래스의 외부에서는 이 메서드에 접근하지 못하고 클래스 내부와 서브 클래스에서만 접근이 가능하다.</p>
</li>
<li><p>객체 캡슐화</p>
<p>Movie 클래스는 DiscountPolicy 타입의 인스턴스 변수를 포함한다. </p>
<p>이 인스턴스 변수는 private 가시성을 가지므로 Movie 와 DiscountPolicy 사이의 관계를 변경해도 외부에는 영향을 미치지 않는다.</p>
<p>즉, 합성이다.</p>
</li>
<li><p>서브타입 캡슐화</p>
<p>Movie 는 DiscountPolicy 에 대해서 알고 있지만, AmountDiscountPolicy 에 대해서는 모른다. </p>
<p>그러나 실행 시점에 협력할 수 있다.</p>
<p>서트타입의 종류를 캡슐화하고 있기 때문에, 다형성의 기반이 된다.</p>
</li>
</ol>
<h2 id="3-일관성-있는-기본-정책-구현하기"><a href="#3-일관성-있는-기본-정책-구현하기" class="headerlink" title="3 일관성 있는 기본 정책 구현하기"></a>3 일관성 있는 기본 정책 구현하기</h2><p>전체 설계는 다음과 같다.</p>
<p><img src="/image/object_all_chapter14.png" alt></p>
<h5 id="변경-분리하기"><a href="#변경-분리하기" class="headerlink" title="변경 분리하기"></a>변경 분리하기</h5><p>시간대별, 요일별, 구간별 방식의 공통점은 각 기본 정책을 구성하는 방식이 유사하는 것이다.</p>
<ol>
<li>기본 정책은 한 개 이상의 규칙으로 구성된다.</li>
<li>하나의 규칙은 적용 조건과 단위요금을 조합이다.</li>
</ol>
<p><img src="/image/object_rule_chapter14.png" alt></p>
<p>모든 규칙에 적용 조건이 포함된다는 사실은 변하지 않지만 실제 조건의 세부 내용은 다르다. </p>
<p>즉, 조건의 세부 내용이 바로 변화에 해당하는 것이다. </p>
<p>변하지 않는 ‘규칙’ 으로부터 변하는 ‘적용 조건’ 을 분리해야한다.</p>
<h5 id="변경-캡슐화하기"><a href="#변경-캡슐화하기" class="headerlink" title="변경 캡슐화하기"></a>변경 캡슐화하기</h5><p><img src="/image/object_fee_chapter14.png" alt></p>
<p>변하는 FeeCondition 의 서브 타입은 변하지 않는 FeeRule 로부터 캡슐화된다. </p>
<h5 id="협력-패턴-설계하기"><a href="#협력-패턴-설계하기" class="headerlink" title="협력 패턴 설계하기"></a>협력 패턴 설계하기</h5><p><img src="/image/object_basic_chapter14.png" alt></p>
<ol>
<li><p>BasicRatePolicy 의 calculateFee 메서드는 인자로 전달받은 통화 목록의 전체 요금을 계산한다.</p>
</li>
<li><p>BasicRatePolicy 는 목록에 포함된 각 Call 별로 FeeRule 의 calculateFee 메서드를 실행한다.</p>
</li>
<li><p>하나의 BasicRatePolicy 는 하나 이상의 FeeRule 로 구성되어서, Call 하나당 FeeRule 에 다수의 calculateFee 메세지가 전송된다.</p>
</li>
</ol>
<h5 id="추상화-수준에서-협력-패턴-구현하기"><a href="#추상화-수준에서-협력-패턴-구현하기" class="headerlink" title="추상화 수준에서 협력 패턴 구현하기"></a>추상화 수준에서 협력 패턴 구현하기</h5><p>변하지 않는 요소와 추상적인 요소만으로 요금 계산에 필요한 전체적인 협력 구조를 설명할 수 있다.</p>
<h5 id="구체적인-협력-구현하기"><a href="#구체적인-협력-구현하기" class="headerlink" title="구체적인 협력 구현하기"></a>구체적인 협력 구현하기</h5><p>code : 505 Page</p>
<p>유사한 기능에 대해 유사한 협력 패턴을 적용하는 것은 객체지향 시스템에서 개념적 무결성을 유지할 수 있는 방법이다. </p>
<p>개념적 무결성이란, 일관성이다.</p>
<hr>
<p>오브젝트 &lt;조영호&gt;</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kojunhee.github.io/2020/01/20/object-chapter14/" data-id="ck8ogwt0c00qoq16wh9s75vvu" data-title="[오브젝트] 14장_일관성 있는 협력" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/3/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/47/">47</a><a class="extend next" rel="next" href="/page/5/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/algorithm/">Algorithm</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/big-data/">Big Data</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/boost-course/">Boost Course</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/dip/">DIP</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/data-structure/">Data Structure</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/database/">Database</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/design-pattern/">Design Pattern</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/git/">Git</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/jpa/">JPA</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kafka/">Kafka</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/network/">Network</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/node-js/">Node.js</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/os/">OS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/object/">Object</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/software-engineering/">Software Engineering</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/spark/">Spark</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/tdd/">TDD</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/etc/">etc</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ios/">iOS</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/04/06/tdd-chapter-28/">[테스트 주도 개발] 28장_초록 막대 패턴</a>
          </li>
        
          <li>
            <a href="/2020/04/06/tdd-chapter-27/">[테스트 주도 개발] 27장_테스팅 패턴</a>
          </li>
        
          <li>
            <a href="/2020/04/06/tdd-chapter-26/">[테스트 주도 개발] 26장_빨간 막대 패턴</a>
          </li>
        
          <li>
            <a href="/2020/04/06/tdd-chapter-25/">[테스트 주도 개발] 25장_테스트 주도 개발 패턴</a>
          </li>
        
          <li>
            <a href="/2020/03/31/tdd-chapter-24/">[테스트 주도 개발] 24장_xUnit 회고</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 junhee.ko<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="/js/jquery-3.4.1.min.js"></script>


  <script src="/fancybox/jquery.fancybox.min.js"></script>


<script src="/js/script.js"></script>




  </div>
</body>
</html>