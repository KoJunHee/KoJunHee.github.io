<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  
  <title>Always Learning</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Always Learning">
<meta property="og:url" content="https://kojunhee.github.io/page/17/index.html">
<meta property="og:site_name" content="Always Learning">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Always Learning">
  
    <link rel="alternate" href="/atom.xml" title="Always Learning" type="application/atom+xml">
  
  
    <link rel="icon" href="css/images/favicon.ico">
  
  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">
  
  <link rel="stylesheet" href="/css/style.css">
  
    <link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">
  
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Always Learning</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">junhee.ko</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://kojunhee.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-활주로 건설" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/10/09/활주로 건설/" class="article-date">
  <time class="dt-published" datetime="2018-10-08T15:00:00.000Z" itemprop="datePublished">2018-10-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/algorithm/">Algorithm</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/10/09/활주로 건설/">활주로 건설</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><a href="https://www.swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWIeW7FakkUDFAVH" target="_blank" rel="noopener">https://www.swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWIeW7FakkUDFAVH</a></p>
<p>경우의 수를 나눈 후 조건에 맞게 짜려고 하였다. 해설을 보고 DFS로 풀면 쉽게 풀 수 있다는 것을 알았다.</p>
<h2 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h2><ol>
<li><p>모든 행과 열을 차례대로 체크한다.</p>
</li>
<li><p>현재 위치와 다음 위치를 비교한다.</p>
<ul>
<li><p>같은 높이인 경우 : 다음 위치 부터 체크</p>
</li>
<li><p>오르막인 경우 : 현재 위치 기준해서 왼쪽으로 경사로 둘 수 있는지 체크</p>
</li>
<li><p>내리막인 경우 : 현재 위치 기준해서 오른쪽으로 경사로 둘 수 있는지 체크</p>
</li>
<li><p>그 이외의 경우 : 이번 행이나 열은 실패</p>
</li>
</ul>
</li>
</ol>
<h2 id="코드"><a href="#코드" class="headerlink" title="코드"></a>코드</h2><p><img src="/image/runwayyy01.png" alt></p>
<p><img src="/image/runwayyy02.png" alt></p>
<p><img src="/image/runwayyy03.png" alt></p>
<p><img src="/image/runwayyy04.png" alt></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kojunhee.github.io/2018/10/09/활주로 건설/" data-id="ck913utu300hcp26wn9m0435s" data-title="활주로 건설" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-탐주범 검거" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/10/09/탐주범 검거/" class="article-date">
  <time class="dt-published" datetime="2018-10-08T15:00:00.000Z" itemprop="datePublished">2018-10-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/algorithm/">Algorithm</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/10/09/탐주범 검거/">탈주범 검거</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><a href="https://www.swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV5PpLlKAQ4DFAUq" target="_blank" rel="noopener">https://www.swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV5PpLlKAQ4DFAUq</a></p>
<p>소요시간 1시간. BFS 문제이다. 쉬운 문제이다. Queue에 넣어야 하는 경우의 수의 조건에서 시간이 오래 걸렸다.</p>
<p>더럽게 코드를 작성했다. 더 나은 방법은 없을까?</p>
<h2 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h2><ol>
<li>map에 터널 상태를 저장한다.</li>
<li>현재 위치에서 이동 가능한 위치를 큐에 넣는다. (이동 가능한 위치는 터널 상태를 보고 파악한다)</li>
<li>큐에서 pop한 위치에서 2번을 반복한다.</li>
<li>depth가 문제에서 주어진 시간이 되었을 때, 큐에 넣었던 위치 개수를 출력한다. </li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kojunhee.github.io/2018/10/09/탐주범 검거/" data-id="ck913utu300hap26wao04kduu" data-title="탈주범 검거" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Deadlock" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/10/09/Deadlock/" class="article-date">
  <time class="dt-published" datetime="2018-10-08T15:00:00.000Z" itemprop="datePublished">2018-10-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/os/">OS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/10/09/Deadlock/">Deadlock</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>출처 : 이화여자대학교 반효경 (<a href="http://www.kocw.net/home/search/kemView.do?kemId=1046323" target="_blank" rel="noopener">http://www.kocw.net/home/search/kemView.do?kemId=1046323</a>)</p>
<h2 id="Deadlock"><a href="#Deadlock" class="headerlink" title="Deadlock"></a>Deadlock</h2><p><img src="/image/dealock01.png" alt></p>
<p>일련의 프로세스들이 서로가 가진 자원을 기다리며 block된 상태</p>
<ul>
<li>자원<ul>
<li>하드웨어, 소프트웨어 등을 포함하느 개념</li>
<li>ex) I/O device, CPU cycle, memory space, semaphore 등</li>
</ul>
</li>
<li>예시<ul>
<li>시스템 2개의 tape drive가 있다</li>
<li>프로세스 P1과 P2 각각이 하나의 tape drive 를 보유한 채 다른 하나를 기다리고 있음</li>
</ul>
</li>
</ul>
<h2 id="Deadlock-발생의-4가지-조건"><a href="#Deadlock-발생의-4가지-조건" class="headerlink" title="Deadlock 발생의 4가지 조건"></a>Deadlock 발생의 4가지 조건</h2><ul>
<li>Mutual Exlusioin<ul>
<li>매 순간 하나의 프로세스만이 자원을 사용할 수 있음</li>
</ul>
</li>
<li>No Preemption <ul>
<li>프로세스는 자원을 스스로 내어놓을 뿐 강제로 뺏기지 않음 </li>
</ul>
</li>
<li>Hold and wiat <ul>
<li>자원을 가진 프로세스가 다른 자원을 기달리때 보유 자원을 놓지 않고 계속 가지고 있음</li>
</ul>
</li>
<li>Circular wait<ul>
<li>자워을 기다리는 프로세스 간에 사이클이 형성되어야 함 </li>
<li>P0은 P1이 가진 자원을 기다림</li>
<li>P1은 P2가 가진 자원을 기다림 ..</li>
</ul>
</li>
</ul>
<h2 id="자원-할당-그래프"><a href="#자원-할당-그래프" class="headerlink" title="자원 할당 그래프"></a>자원 할당 그래프</h2><p><img src="/image/dealock02.png" alt></p>
<ul>
<li><p>자원에서 프로세스쪽으로 나가는 화살표 </p>
</li>
<li><p>이 프로세스가 이 자원을 가지고 있다.</p>
</li>
<li><p>프로세스에서 자원쪽으로 나가는 화살표</p>
<ul>
<li>이 프로세스가 이 자원을 요청</li>
</ul>
</li>
<li><p>자원 안에 동그라미</p>
<ul>
<li>자원 개수</li>
</ul>
</li>
<li><p>그래프 안에 cycle이 없으면 deadlock이 아니다</p>
</li>
<li><p>cycle이 있으면</p>
<ul>
<li>자원당 인스턴스가 하나밖에 없으면, 데드락</li>
<li>자원의 인스턴스가 여러개면, 데드락수도 있고 아닐수도 있고</li>
</ul>
</li>
<li><p>왼쪽은 데드락, 오른쪽은 데드락이 아님</p>
</li>
</ul>
<h2 id="Deadlock-Prevention"><a href="#Deadlock-Prevention" class="headerlink" title="Deadlock Prevention"></a>Deadlock Prevention</h2><p>자원 할당시 Deadlock의 4가지 필요 조건 중 어느 하나가 만족되지 않도록 하는 것 </p>
<ul>
<li>Mutual Exclusion<ul>
<li>공유해서는 안되는 자원의 경우 반드시 성립해야함 </li>
</ul>
</li>
<li>Hold and wait<ul>
<li>프로세스 시작 시 모든 필요한 자원을 할당받게 하는 방법</li>
<li>자원이 필요할 경우 보유 자원을 모두 놓고 다시 요청</li>
</ul>
</li>
<li>No preemption <ul>
<li>빼앗아 올수 있게 하면 됨 </li>
<li>모든 필요한 자원을 얻을 수 있을 때 그 프로세스는 다시 시작된다. </li>
</ul>
</li>
<li>Circular Wait<ul>
<li>모든 자원 유형에 할당 순서를 정하여 정해진 순서대로 자원 할당</li>
</ul>
</li>
</ul>
<h2 id="Deadlock-Avoidance"><a href="#Deadlock-Avoidance" class="headerlink" title="Deadlock Avoidance"></a>Deadlock Avoidance</h2><p>자원 요청에 대한 부가적인 정보를 이용해서 데드락의 가능성이 없는 경우에만 자원 할당.</p>
<p>데드락으로부터 항상 safe한 상태를 유지.</p>
<p>자원 요청에 대한 부가정보를 이용해서 자원 할당이 데드락으로부터 safe한지를 동적으로 조사해서 안전한 경우에만 할당.</p>
<p>프로세스들이 필요로 하는 각 자원별 최대 사용량을 미리 선언</p>
<ul>
<li>Single instance per resouce types <ul>
<li>Resource Allocation Graph algorithm</li>
</ul>
</li>
<li>Multiple instance per resouce types  <ul>
<li>Banker’s Algorithm</li>
</ul>
</li>
</ul>
<h2 id="Resource-Allocation-Graph-algorithm"><a href="#Resource-Allocation-Graph-algorithm" class="headerlink" title="Resource Allocation Graph algorithm"></a>Resource Allocation Graph algorithm</h2><p>자원 당 인스턴스 하나</p>
<p>데드락의 위험성이 있으면 애초부터 자원을 내주지 않음.</p>
<p>점선 화살표 : 이 프로세스가 평생 적어도 한번 이 자원을 사용할 것이다.</p>
<p><img src="/image/dealock03.png" alt></p>
<h2 id="Banker’s-Algorithm"><a href="#Banker’s-Algorithm" class="headerlink" title="Banker’s Algorithm"></a>Banker’s Algorithm</h2><p>자원 당 인스턴스 여러개</p>
<p><img src="/image/dealock04.png" alt></p>
<p>5개의 프로세스 : P0 P1 P2 P3 P4</p>
<p>A자원 인스턴스 10개</p>
<p>B자원 인스턴스 5개</p>
<p>C자원 인스턴스 7개</p>
<ul>
<li><p>Allocation</p>
<ul>
<li>0번 프로세스는 현재 A 0개 / B 1개 / C 0개 할당되어 있음 </li>
</ul>
</li>
<li><p>Available</p>
<ul>
<li>현재 가용 자원</li>
<li>아무도 사용하지 않고 남아 있는 자원</li>
</ul>
</li>
<li><p>Max</p>
<ul>
<li>이 프로세스가 시작될 때, 이 프로세스가 평생 최대로 사용할 자원 개수를 선언했음</li>
</ul>
</li>
<li><p>Need</p>
<ul>
<li>추가로 요청 할 수  있는 양 </li>
</ul>
</li>
</ul>
<p>이 알고리즘은 프로세스가 자원을 요청했을 때, 이 요청을 받아들일것인지 결정하는 것임 </p>
<p>프로세스가 최대(Need)로 요청할 것을 가정한다. 그리고 이게 가용 자원으로 가능한지 체크. 가용자원으로 가능하지 않으면 요청을 거절.</p>
<p>P0는 7 4 3 으로 요청할것이다. 이게 3 3 2 로 커버 가능? NO. 요청 거절.</p>
<h2 id="Deadlock-Detection-and-recovery"><a href="#Deadlock-Detection-and-recovery" class="headerlink" title="Deadlock Detection and recovery"></a>Deadlock Detection and recovery</h2><p>Deadlock 발생은 허용하되 그에 대한 detection 루틴을 두어 deadlock 발생시 recover</p>
<ul>
<li><p>Single instance per resouce types </p>
<ul>
<li>Resource Allocation Graph algorithm</li>
<li>cycle이 곧 데드락</li>
</ul>
</li>
<li><p>Multiple instance per resouce types  </p>
<ul>
<li>Banker’s Algorithm과 유사한 방법 활용</li>
</ul>
</li>
<li><p>Recovery</p>
<ul>
<li><p>Process Termination</p>
<ul>
<li>abort all deadlocked processes(한꺼번에)</li>
<li>데드락에 연루된 프로세스드을 하나씩 죽여봄. 여전히 데드락이면 또 하나의 다른 프로세스 죽여봄.</li>
</ul>
</li>
<li><p>Resource Preemption</p>
<ul>
<li>데드락에 연루된 프로세스로부터 자원을 뺏음</li>
<li>safe state로 roolback하여 prcess를 restart</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Deadlock-Ignorance"><a href="#Deadlock-Ignorance" class="headerlink" title="Deadlock Ignorance"></a>Deadlock Ignorance</h2><p>Deadlock을 시스템이 책임지지 않음</p>
<p>UNIX를 포함한 대부분의 OS가 채택</p>
<p>데드락이 일어나지 않는다고 생각하고 아무런 조치 취하지 않음</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kojunhee.github.io/2018/10/09/Deadlock/" data-id="ck913utu200h8p26wnkscmdok" data-title="Deadlock" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-특이한 자석" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/10/07/특이한 자석/" class="article-date">
  <time class="dt-published" datetime="2018-10-06T15:00:00.000Z" itemprop="datePublished">2018-10-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/algorithm/">Algorithm</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/10/07/특이한 자석/">특이한 자석</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><a href="https://www.swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWIeV9sKkcoDFAVH" target="_blank" rel="noopener">https://www.swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWIeV9sKkcoDFAVH</a>    </p>
<h2 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h2><ol>
<li>현재 톱니 바퀴 기준으로 왼쪽과 오른쪽 확인 </li>
<li>각 톱니바퀴 회전</li>
<li>결과 값 계산</li>
<li>1번부터 다시</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kojunhee.github.io/2018/10/07/특이한 자석/" data-id="ck913utu200h6p26wfs980b7c" data-title="특이한 자석" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-줄기세포배양" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/10/07/줄기세포배양/" class="article-date">
  <time class="dt-published" datetime="2018-10-06T15:00:00.000Z" itemprop="datePublished">2018-10-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/algorithm/">Algorithm</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/10/07/줄기세포배양/">줄기세포배양</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><a href="https://www.swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWXRJ8EKe48DFAUo&amp;categoryId=AWXRJ8EKe48DFAUo&amp;categoryType=CODE" target="_blank" rel="noopener">https://www.swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWXRJ8EKe48DFAUo&amp;categoryId=AWXRJ8EKe48DFAUo&amp;categoryType=CODE</a>    </p>
<h2 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h2><ol>
<li><p>전체 map size를 450 * 450 으로 하고 초기 위치를 i+175, j+175로 하였다. ( 왜?? )</p>
</li>
<li><p>생명력을 저장하고, 활성 상태를 체크하기 위해 map(450)(450)(0) 에는 생명력을, map(450)(450)(1) 에는 생명력*2를 저장한다. map(450)(450)(1) &lt; map(450)(450)(0) 이 되면 활성상태가 되므로, 확장시킨다.  </p>
</li>
<li><p>생명력 수치가 높은 줄기 세포를 먼저 확장 시키기 위해, 생명력에 따른 Queue를 저장하는 배열을 생성한다.</p>
<p>arr[1] : 생명력이 1인 줄기 세포의 좌표를 저장하는 Queue</p>
<p>arr[2] : 생명력이 2인 줄기 세포의 좌표를 저장하는 Queue</p>
<p>…</p>
<p>arr[10] : 생명력이 10인 줄기 세포의 좌표를 저장하는 Queue </p>
</li>
<li><p>생명력이 10인 큐 ~ 생명력이 1인 큐를 순차적으로 확인한다.</p>
</li>
<li><p>큐에 저장되어 있는 줄기세포를 하나씩 remove하여 활성화되어있는지 체크하여 확장한다.</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kojunhee.github.io/2018/10/07/줄기세포배양/" data-id="ck913utu100h4p26w3189gorg" data-title="줄기세포배양" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-CPU Scheduling" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/10/06/CPU Scheduling/" class="article-date">
  <time class="dt-published" datetime="2018-10-05T15:00:00.000Z" itemprop="datePublished">2018-10-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/os/">OS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/10/06/CPU Scheduling/">CPU Scheduling</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h5 id="CPU-and-I-O-Bursts-in-program-execution-이란"><a href="#CPU-and-I-O-Bursts-in-program-execution-이란" class="headerlink" title="CPU and I/O Bursts in program execution 이란 ?"></a>CPU and I/O Bursts in program execution 이란 ?</h5><p><img src="/image/os100601.png" alt></p>
<h5 id="CPU-burst-time-의-분포는"><a href="#CPU-burst-time-의-분포는" class="headerlink" title="CPU-burst time 의 분포는 ?"></a>CPU-burst time 의 분포는 ?</h5><p><img src="/image/os100602.png" alt></p>
<h5 id="프로세를-분류하면"><a href="#프로세를-분류하면" class="headerlink" title="프로세를 분류하면 ?"></a>프로세를 분류하면 ?</h5><ol>
<li>I/O-bound process<br>CPU를 잡고 계산하는 시간보다 I/O에 많은 시간이 필요한 job 입니다.</li>
<li>CPU-bound process<br>계산 위주의 job 입니다.</li>
</ol>
<h5 id="CPU-스케쥴링이-왜-필요한가요"><a href="#CPU-스케쥴링이-왜-필요한가요" class="headerlink" title="CPU 스케쥴링이 왜 필요한가요?"></a>CPU 스케쥴링이 왜 필요한가요?</h5><ol>
<li>IO 대기, Memory stall과 같은 CPU idle time 을 최소화하여 CPU 자원의 활용을 극대화하기 위해 필요합니다.</li>
<li>여러 종료의 job(process)이 섞여 있기 때문에 CPU 스케쥴링이 필요하다.</li>
</ol>
<h5 id="CPU-스케쥴링을-위해-Ready-Queue-구현은-어떻게-하나요"><a href="#CPU-스케쥴링을-위해-Ready-Queue-구현은-어떻게-하나요" class="headerlink" title="CPU 스케쥴링을 위해 Ready Queue 구현은 어떻게 하나요?"></a>CPU 스케쥴링을 위해 Ready Queue 구현은 어떻게 하나요?</h5><p>스케쥴링 알고리즘에 따라 FIFO, Queue, tree, Linked List 등을 사용할 수 있습니다.</p>
<h5 id="CPU-Scheduler-amp-Dispatcher-이란"><a href="#CPU-Scheduler-amp-Dispatcher-이란" class="headerlink" title="CPU Scheduler &amp; Dispatcher 이란 ?"></a>CPU Scheduler &amp; Dispatcher 이란 ?</h5><ol>
<li><p>CPU Scheduler<br>운영체제 안에서 CPU 스케쥴링 하는 코드입니다. Ready 상태의 프로세스 중에서 이번에 CPU를 줄 프로세스를 고릅니다.</p>
</li>
<li><p>Dispatcher<br>CPU의 제어권을 CPU scheduler 에해 선택된 프로세스에게 넘깁니다. 이 과정을 context switch 라고 합니다.</p>
</li>
</ol>
<h5 id="CPU-스케쥴링이-필요한-경우는"><a href="#CPU-스케쥴링이-필요한-경우는" class="headerlink" title="CPU 스케쥴링이 필요한 경우는 ?"></a>CPU 스케쥴링이 필요한 경우는 ?</h5><ol>
<li>running -&gt; blocked (I/O 요청하는 systemcall) </li>
<li>running -&gt; ready (할당 시간 만료로 time interrupt)</li>
<li>blocked -&gt; ready (I/O 완료 후 interrupt)</li>
<li>terminate</li>
</ol>
<p>1,4 는 nonpreemtive (강제로 빼앗지 않고 자진 반납) 입니다.</p>
<h5 id="Scheduling-Criteria-성능-척도"><a href="#Scheduling-Criteria-성능-척도" class="headerlink" title="Scheduling Criteria (성능 척도)"></a>Scheduling Criteria (성능 척도)</h5><ol>
<li>system 입장<ul>
<li>CPU utilization<ul>
<li>keep the CPU as busy as possible</li>
</ul>
</li>
<li>Throughput<ul>
<li>number of processes that complete their execution per time unit</li>
</ul>
</li>
</ul>
</li>
<li>program 입장<ul>
<li>Turnaround time<ul>
<li>amount of time to execute a particular process</li>
</ul>
</li>
<li>Waiting time<ul>
<li>amount of time a process has been waiting in the ready</li>
</ul>
</li>
<li>Response time<ul>
<li>amount of time it takes from when a request was submitted unitl the first response is produced, not output (for time-sharing environment)</li>
<li>최초의 CPU 얻기까지 기다린 시간</li>
</ul>
</li>
</ul>
</li>
</ol>
<h5 id="CPU-스케쥴링-알고리즘은-어떤게-있나요"><a href="#CPU-스케쥴링-알고리즘은-어떤게-있나요" class="headerlink" title="CPU 스케쥴링 알고리즘은 어떤게 있나요?"></a>CPU 스케쥴링 알고리즘은 어떤게 있나요?</h5><p>First Come First Served, Shorted Job First, Priority Scheduling, Round Robin이 있습니다.</p>
<h5 id="FCFS-First-Come-First-Served-이란"><a href="#FCFS-First-Come-First-Served-이란" class="headerlink" title="FCFS (First-Come First-Served) 이란 ?"></a>FCFS (First-Come First-Served) 이란 ?</h5><p>먼저 온 순서대로 처리하는 알고리즘입니다. 비선점형입니다.</p>
<ul>
<li><p>도착 순서</p>
<ul>
<li>p1, p2, p3</li>
</ul>
</li>
<li><p>burst time </p>
<ul>
<li>24 / 3 / 3 </li>
</ul>
</li>
<li><p>wating time </p>
<ul>
<li>0 / 24/ 27</li>
</ul>
</li>
<li><p>Convoy effet</p>
<ul>
<li>short process behind long process</li>
</ul>
</li>
</ul>
<h5 id="SJF-Shorted-Job-First-이란"><a href="#SJF-Shorted-Job-First-이란" class="headerlink" title="SJF (Shorted-Job-First) 이란 ?"></a>SJF (Shorted-Job-First) 이란 ?</h5><p>CPU burst time이 가장 짧은 프로세스를 제일 먼저 스케쥴링합니다. 비선점형과 선점형이 있습니다. 비선점형의 경우, 일단 CPU를 잡으면 이번 CPU burst가 완료될 때까지 CPU를 선점 당하지 않습니다. 선졈형의 경우, 현재 수행중인 프로세스의 남은 burst time 보다 더 짧은 CPU burst time 을 가지는 새로운 프로세스가 도착하면 CPU를 빼앗깁니다. 이 방법을 SRTF (Shorted-Remaing-Time-First) 라고도 부릅니다.</p>
<h5 id="SJF는-어떤-문제가-있나요"><a href="#SJF는-어떤-문제가-있나요" class="headerlink" title="SJF는 어떤 문제가 있나요?"></a>SJF는 어떤 문제가 있나요?</h5><p>starvation 문제가 있습니다. CPU 사용 시간이 긴 프로세스는 거의 영원히 CPU 를 할당받을 수 없습니다.</p>
<h5 id="SJF에서-다음-CPU-burst-time을-어떻게-알-수-있나요"><a href="#SJF에서-다음-CPU-burst-time을-어떻게-알-수-있나요" class="headerlink" title="SJF에서 다음 CPU burst time을 어떻게 알 수 있나요?"></a>SJF에서 다음 CPU burst time을 어떻게 알 수 있나요?</h5><p>과거의 CPU burst time을 이용해서 추정 (exponential averaging) 합니다.</p>
<h5 id="Proirity-Scheduling-이란"><a href="#Proirity-Scheduling-이란" class="headerlink" title="Proirity Scheduling 이란 ?"></a>Proirity Scheduling 이란 ?</h5><p>우선순위가 제일 높은 process에게 CPU를 먼저 주는 알고리즘입니다.  선점형 스케줄링은, 더 높은 우선순위의 프로세스가 도착하면 실행중인 프로세스를 멈추고 CPU 를 선점합니다. 비선점형 스케줄링 방식은, 더 높은 우선순위의 프로세스가 도착하면 Ready Queue 의 Head 에 넣습니다.</p>
<p>#####Prirority Sceduling의 문제는 뭔가요?</p>
<p>starvation 문제가 있습니다. 낮은 우선순위의 프로세스는 CPU 를 할당받을 수 없습니다.</p>
<h5 id="Prirority-Sceduling의-starvation-문제를-어떻게-해결해야할까요"><a href="#Prirority-Sceduling의-starvation-문제를-어떻게-해결해야할까요" class="headerlink" title="Prirority Sceduling의 starvation 문제를 어떻게 해결해야할까요?"></a>Prirority Sceduling의 starvation 문제를 어떻게 해결해야할까요?</h5><p>aging을 사용합니다. 아무리 우선순위가 낮은 프로세스라도 오래 기다리면 우선순위를 높여주면 됩니다.</p>
<h5 id="Round-Robin-이란"><a href="#Round-Robin-이란" class="headerlink" title="Round Robin 이란 ?"></a>Round Robin 이란 ?</h5><p>각 프로세스는 동일한 크기의 할당 시간 (time quantum) 을 가집니다. 할당 시간이 지나면 프로세스는 선점 당하고 ready queue의 제일 뒤에 가서 다시 줄을 서는 알고리즘입니다.</p>
<p>Response time이 빠릅니다. time quantum large 하면 FCFS 와 같고, time quantum small 하면 context switch overhead가 커집니다.</p>
<h5 id="Multilevel-Queue-란"><a href="#Multilevel-Queue-란" class="headerlink" title="Multilevel Queue 란 ?"></a>Multilevel Queue 란 ?</h5><p><img src="/image/os100603.png" alt></p>
<ul>
<li>Ready queue를 여러 개로 분할합니다.<ul>
<li>foreground (interactive)</li>
<li>background (batch - no human interaction)</li>
</ul>
</li>
<li>각 큐는 독립적인 스케쥴링 알고리즘을 가집니다.<ul>
<li>foreground - RB</li>
<li>background - FCFS</li>
</ul>
</li>
<li>어느 큐에 CPU를 줄지 결정하고, 그 큐 안에서 누구에게 CPU를 줄지 결정해야합니다.</li>
<li>큐에 대한 스케쥴링이 필요합니다.<ul>
<li>fixed priority scheduling    <ul>
<li>serve all from foreground then from background</li>
<li>Possibility of starvation</li>
</ul>
</li>
<li>time slice<ul>
<li>각 큐에 CPU time을 적절한 비율로 할당합니다.</li>
<li>ex) 80 % to foreground in RB , 20% to background in FCFS</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="Multilevel-Feedback-Queue-란"><a href="#Multilevel-Feedback-Queue-란" class="headerlink" title="Multilevel Feedback Queue 란 ?"></a>Multilevel Feedback Queue 란 ?</h5><p><img src="/image/os100604.png" alt></p>
<ul>
<li>프로세스가 다른 큐로 이동 가능합니다.</li>
<li>againg을 이와 같은 방식으로 구현 가능합니다.</li>
<li>Multilevel Feedback Queue Scheduler를 정의하는 파라미터들<ul>
<li>Queue의 수</li>
<li>각 큐의 스케쥴링 알고리즘</li>
<li>Process를 상위 큐로 보내는 기준</li>
<li>Process를 하 큐로 내쫓는 기준</li>
<li>프로세스가 CPU 서비스를 받으려 할 때 들어갈 큐를 결정하는 기준</li>
</ul>
</li>
<li>할당 시간 끝나면 아래로 강등됩니다. CPU 사용 시간이 짧은 프로세스에게 우선 순위를 많이 줍니다.</li>
</ul>
<h5 id="Multiple-Processor-Scheduling-이란"><a href="#Multiple-Processor-Scheduling-이란" class="headerlink" title="Multiple-Processor Scheduling 이란 ?"></a>Multiple-Processor Scheduling 이란 ?</h5><p>CPU가 여러개인 경우</p>
<ul>
<li>Homogeneous process인 경우<ul>
<li>Queue에 한 줄로 세워서 각 프로세서가 알아서 꺼내가게 할 수 있음</li>
<li>반드시 특정 프로세서에서 수행되어야 하는 프로세스가 있는 경우에는 문제가 더 복잡해짐</li>
</ul>
</li>
<li>Load sharing<ul>
<li>일부 프로세서에 job이 몰리지 않도록 부하를 적절히 공유하는 메커니즘 필요</li>
<li>별개의 큐를 두는 방법 vs 공동 큐를 사용하는 방법</li>
</ul>
</li>
<li>Sysmmetric Multiprocessing (SMP)<ul>
<li>각 프로세서가 각자 알아서 스케쥴링 결정</li>
</ul>
</li>
<li>Asysmmetric Multiprocessing<ul>
<li>하나의 프로세서가 시스템 데이터의 접근과 공유를 책임지고 나머지 프로세서는 거기에 따름</li>
</ul>
</li>
</ul>
<h5 id="Real-Time-Scheduling-이란"><a href="#Real-Time-Scheduling-이란" class="headerlink" title="Real-Time Scheduling 이란 ?"></a>Real-Time Scheduling 이란 ?</h5><ul>
<li>Hard real-time systems<ul>
<li>정해진 시간 안에 반드시 끝내도록 스케쥴링해야 함</li>
</ul>
</li>
<li>Soft real-time systems<ul>
<li>일반 프로세스에 비해 높은 priority를 갖도록 해야 함</li>
</ul>
</li>
</ul>
<h5 id="Thread-Scheduling-이란"><a href="#Thread-Scheduling-이란" class="headerlink" title="Thread Scheduling 이란 ?"></a>Thread Scheduling 이란 ?</h5><ul>
<li>Local Scheduling<ul>
<li>User level thread의 경우 사용자 수준의 thread library에 의해 어떤 thread를 스케쥴할지 결정</li>
</ul>
</li>
<li>Global Scheduling<ul>
<li>Kenel level thread의 경우 일반 프로세스와 마찬 가지로 커널의 단기 스케쥴러가 어떤 thread를 스케쥴할지 결정</li>
</ul>
</li>
</ul>
<h5 id="Algorithm-Evaluation"><a href="#Algorithm-Evaluation" class="headerlink" title="Algorithm Evaluation"></a>Algorithm Evaluation</h5><ul>
<li><p>Queueing models</p>
<ul>
<li>server가 CPU, 확률 분포로 주어지는 arrivate rate와 service rate 등을 통해 각종 performance index 값을 계산</li>
</ul>
<p><img src="/image/os100605.png" alt></p>
</li>
<li><p>Implemetatation(구현) &amp; Measurement(성능 측정)</p>
<ul>
<li>실제 시스템에 알고리즘을 구현하여 실제 작업에 대해서 성능을 측정 비교</li>
</ul>
</li>
<li><p>Simulation (모의 실험)</p>
<ul>
<li>알고리즘을 모의 프로그램으로 작성후 trace(input data) 를 입력으로 하여 결과 비교</li>
</ul>
</li>
</ul>
<h5 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h5><p>이화여자대학교 반효경 (<a href="http://www.kocw.net/home/search/kemView.do?kemId=1046323" target="_blank" rel="noopener">http://www.kocw.net/home/search/kemView.do?kemId=1046323</a>)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kojunhee.github.io/2018/10/06/CPU Scheduling/" data-id="ck913utu000h1p26wbzvuspvc" data-title="CPU Scheduling" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Process Synchronization" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/10/06/Process Synchronization/" class="article-date">
  <time class="dt-published" datetime="2018-10-05T15:00:00.000Z" itemprop="datePublished">2018-10-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/os/">OS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/10/06/Process Synchronization/">Process Sysncronization</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h5 id="데이터의-접근"><a href="#데이터의-접근" class="headerlink" title="데이터의 접근"></a>데이터의 접근</h5><p>데이터를 읽어와서 연산하고 다시 저장합니다.</p>
<p><img src="/image/100601.png" alt></p>
<h5 id="Race-Condition"><a href="#Race-Condition" class="headerlink" title="Race Condition"></a>Race Condition</h5><p>S-box를 공유하는 E-box가 여럿 있는 경우 Race Condition의 가능성이 있습니다.<br>ex) 커널 모드 수행 중 인터럽트로 커널모드 다른 루틴 수행시</p>
<p><img src="/image/100602.png" alt></p>
<h5 id="race-condition-1-3"><a href="#race-condition-1-3" class="headerlink" title="race condition (1/3)"></a>race condition (1/3)</h5><ul>
<li>kernel 수행 중 인터럽트 발생</li>
<li>커널모드 running 중 inetrrupt 발생하여 인터럽트 처리 루틴이 수행</li>
<li>양쪽 다 커널 코드이므로 kernel address space 공유</li>
</ul>
<p><img src="/image/100603.png" alt></p>
<h5 id="race-condition-2-3"><a href="#race-condition-2-3" class="headerlink" title="race condition (2/3)"></a>race condition (2/3)</h5><p>해결책 : 커널 모드에서 수행 중일 때는 CPU를 preempt 하지 않음. 커널 모드에서 사용자 모드로 돌아 갈때 preempt.</p>
<p><img src="/image/100604.png" alt></p>
<p><img src="/image/100605.png" alt></p>
<h5 id="race-condition-3-3"><a href="#race-condition-3-3" class="headerlink" title="race condition (3/3)"></a>race condition (3/3)</h5><ul>
<li><p>CPU가 여러개인 경우</p>
</li>
<li><p>해결</p>
<ul>
<li>커널 내부에 있는 각 공유 데이터에 접근할 때마다 그 데이터에 lock / unlock을 하는 방법</li>
<li>한번에 하나의 CPU만이 커널에 들어갈 수 있게 하는 방법</li>
</ul>
</li>
</ul>
<p><img src="/image/100606.png" alt>    </p>
<h5 id="Process-Syncronization-문제"><a href="#Process-Syncronization-문제" class="headerlink" title="Process Syncronization 문제"></a>Process Syncronization 문제</h5><ul>
<li>공유 데이터의 동시 접근은 데이터의 불일치 문제 발생시킬 수 있음</li>
<li>일관성 유지를 위해서 협력 프로세스간의 실행순서를 정해주는 매커니즘 필요</li>
<li>Race condition<ul>
<li>여러 프로세스들이 동시에 공유 데이터를 접근하는 상황</li>
<li>데이터의 최종 연산 결과는 마지막에 그 데이터를 다룬 프로세스에 따라다라짐</li>
<li>이를 막기 위해 concurrent processsms 동기화 되어야한다.</li>
</ul>
</li>
</ul>
<p><img src="/image/100607.png" alt></p>
<h5 id="The-Critical-Section-Problem"><a href="#The-Critical-Section-Problem" class="headerlink" title="The Critical-Section Problem"></a>The Critical-Section Problem</h5><p>Critical-Section은 공유 데이터를 접근하는 코드입니다.</p>
<ul>
<li>n개의 프로세스가 공유 데이터를 동시에 사용하기를 원하는 경우</li>
<li>각 프로세스의 code segment에는 공유 데이터를 접근하는 코드인 ciritical sectoin이 존재</li>
<li>하나의 프로세스가 ciritical section에 있을 때 다른 모든 프로세스는 ciritical section에 들어갈 수 없어야한다.</li>
</ul>
<p><img src="/image/100608.png" alt></p>
<p><img src="/image/os100701.png" alt></p>
<h5 id="프로그램적-해결법의-충족-조건"><a href="#프로그램적-해결법의-충족-조건" class="headerlink" title="프로그램적 해결법의 충족 조건"></a>프로그램적 해결법의 충족 조건</h5><ul>
<li>Mutual Exclution<ul>
<li>프로세스가 pi가 critical section 부분을 수행중이면 다른 모든 프로세스들은 그들의 critical section에 들어가면 안된다.</li>
</ul>
</li>
<li>Progress<ul>
<li>아무도 critical section에 있지 않은 상태에서 critical section에 들어가고자 하는 프로세스가 있으면 critical section에 들어가게 해주어야 한다.</li>
</ul>
</li>
<li>Bounded Wating<ul>
<li>프로세스가 critical section에 들어가려고 요청한 후부터 그 요청이 허용될 때까지 다른 프로세스들이 critical section에 들어가는 횟수에 한계가 있어야 한다.</li>
</ul>
</li>
</ul>
<h5 id="알고리즘-1"><a href="#알고리즘-1" class="headerlink" title="알고리즘 1"></a>알고리즘 1</h5><p>P0</p>
<p>int turn ;</p>
<p>initially turn=0; (turn이 0 : 0번 프로세스 차례)</p>
<p><img src="/image/os100702.png" alt></p>
<p>P0이 빈번히 들어가고 싶으면?</p>
<h5 id="알고리즘-2"><a href="#알고리즘-2" class="headerlink" title="알고리즘 2"></a>알고리즘 2</h5><p>boolean flag[2];</p>
<p>initially flag[모두] =false; // no one is in CS</p>
<p>Pi ready to enter its critical section if flag[i] == true</p>
<p><img src="/image/os100703.png" alt></p>
<p>들어가기전에 둘다 깃발을 들으면 아무도 못들어가.</p>
<h5 id="알고리즘3-Peterson’s-Algorithm"><a href="#알고리즘3-Peterson’s-Algorithm" class="headerlink" title="알고리즘3 (Peterson’s Algorithm)"></a>알고리즘3 (Peterson’s Algorithm)</h5><p><img src="/image/os100704.png" alt></p>
<p>Busy Wating (spin lock)</p>
<p>내가 CPU를 잡고 while문에 있는데, 그때 다른 애가 CPU를 잡으면 ? </p>
<h5 id="Sysnchnization-Hardware"><a href="#Sysnchnization-Hardware" class="headerlink" title="Sysnchnization Hardware"></a>Sysnchnization Hardware</h5><p><img src="/image/os100705.png" alt></p>
<p><img src="/image/os100706.png" alt></p>
<ul>
<li>하드웨어적으로 Test &amp; modify를 atuomic하게 수행할 수 있도록 지원하는 경우 앞의 문제는 간단히 해결</li>
<li>값을 읽어내고 바꾸는 과정을 한번에</li>
</ul>
<h5 id="Lock이-뭔가요"><a href="#Lock이-뭔가요" class="headerlink" title="Lock이 뭔가요?"></a>Lock이 뭔가요?</h5><p>동시에 공유 자원에 접근하는 것을 막기 위해 Critical Section 에 진입하는 프로세스는 Lock 을 획득하고 Critical Section을 빠져나올 때, Lock을 방출함으로써 동시에 접근이 되지 않도록 합니다.</p>
<h5 id="세마포어가-뭔가요"><a href="#세마포어가-뭔가요" class="headerlink" title="세마포어가 뭔가요?"></a>세마포어가 뭔가요?</h5><p>크리티컬 섹션 문제를 해결하고 멀티 프로세싱 환경에서 프로세스 동기화를 이루기 위해 사용되는 Interger 변수입니다. </p>
<p>Counting 세마포어와 Binary 세마포어가 있습니다. Counting 세마포어는 가용한 개수를 가진 자원 에 대한 접근 제어용으로 사용되며, 그 가용한 자원의 개수로 초기화 됩니다. 자원을 사용하면 세마포어가 감소, 방출하면 세마포어가 증가합니다. Binaray 세마포어는 0 과 1 사이의 값만 가능합니다.</p>
<h5 id="P-연산과-V-연산이-뭔가요"><a href="#P-연산과-V-연산이-뭔가요" class="headerlink" title="P 연산과 V 연산이 뭔가요"></a>P 연산과 V 연산이 뭔가요</h5><p>P 연산은 공유자원을 획득하는 연산(Wait Function)이고, V 연산은 공유자원을  반납하는 연산(Signal Function)입니다. </p>
<p>프로세스 동기화를 이루기 위해, 크리티컬 섹션은 P 연산과 V 연산으로 둘러싸여 있습니다.</p>
<p><img src="/image/os100707.png" alt></p>
<p><img src="/image/os100708.png" alt></p>
<h5 id="뮤텍스와-세마포어는-어떤-차이인가요"><a href="#뮤텍스와-세마포어는-어떤-차이인가요" class="headerlink" title="뮤텍스와 세마포어는 어떤 차이인가요?"></a>뮤텍스와 세마포어는 어떤 차이인가요?</h5><p>구현 둘의 목적이 다릅니다. 뮤텍스는 locking mechanism 이고 세마포어는  signaling mechanism 입니다.<br>뮤텍스 : 오직 하나의 테스크만이 뮤텍스를 획득할 수 있습니다.<br>세마포어 :  “I am done, you can carry on” kind of signal .</p>
<h5 id="Critical-Section-of-n-Processes"><a href="#Critical-Section-of-n-Processes" class="headerlink" title="Critical Section of n Processes"></a>Critical Section of n Processes</h5><p><img src="/image/os100709.png" alt></p>
<h5 id="Block-Wakeup-Impemetation"><a href="#Block-Wakeup-Impemetation" class="headerlink" title="Block / Wakeup Impemetation"></a>Block / Wakeup Impemetation</h5><p><img src="/image/os100710.png" alt></p>
<p><img src="/image/os100711.png" alt></p>
<ul>
<li>block<ul>
<li>커널은 block을 호출한 프로세스를 suspend 시킴</li>
<li>이 프로세스의 PCB를 semaphore에 대한 wait queue에 넣음</li>
</ul>
</li>
<li>wakeup(P)<ul>
<li>block 된 프로세스 P를 wakeup 시킴</li>
<li>이 프로세스의 PCB를 ready queue로 옮김</li>
</ul>
</li>
</ul>
<h5 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h5><p><img src="/image/os100712.png" alt></p>
<h5 id="busy-wati-vs-block-wakeup"><a href="#busy-wati-vs-block-wakeup" class="headerlink" title="busy-wati vs block/wakeup"></a>busy-wati vs block/wakeup</h5><p>CS 길이가 긴 경우 Block/Wakeup이 적당합니다. CS 길이가 매우 짧은 경우 Block/Wakeup 오버헤드가 busy-wait 오버헤드보다 더 커질 수 있습니다. 일반적으로  block/wakeup 방식이 더 좋습니다.</p>
<h5 id="Deadlock-and-Starvation"><a href="#Deadlock-and-Starvation" class="headerlink" title="Deadlock and Starvation"></a>Deadlock and Starvation</h5><ul>
<li><p>Deadlock</p>
<p>둘 이상의 프로세스가 서로 상대방에 의해 충족될 수 있는 event를 무한히 기다리는 현상</p>
<p>P0와 P1은 S와 Q 모두가 필요하다.</p>
<p>P0가 S를 차지했을 때, P1이 CPU를 가져가버리면, Deadlock 발생</p>
</li>
</ul>
<p><img src="/image/os100713.png" alt></p>
<ul>
<li><p>Starvation</p>
<p>indefinite blocking. 프로세스가 suspend된 이유에 해당하는 세마포어 큐에서 빠져나갈수 없는 현상</p>
</li>
</ul>
<h5 id="Bounded-Buffer-Problem"><a href="#Bounded-Buffer-Problem" class="headerlink" title="Bounded-Buffer Problem"></a>Bounded-Buffer Problem</h5><p>Producer-Consumer Problem</p>
<p><img src="/image/os100714.png" alt></p>
<p>주황색은 Producer가 생성한다.</p>
<p>생산자 둘이 한 위치에 생성하면?</p>
<p>하나를 소비자 둘이 동시에 소비 하려고 하면?</p>
<p>비버있는 버퍼가 없는데 또 생산자가 만들려고 하면?</p>
<ul>
<li><p>Syncrhonization variables</p>
<ul>
<li>mutual exclution<ul>
<li>need binary semaphore (shared data의 mutual exlusion을 위해)</li>
<li>lock 걸고 풀고</li>
</ul>
</li>
<li>resource count <ul>
<li>need integer semaphore (남은 full/empty buffer의 수 표시)</li>
<li>자원 개수</li>
</ul>
</li>
</ul>
<p>semaphore full =0, empty =n, mutex =1;</p>
</li>
</ul>
<p><img src="/image/os100715.png" alt></p>
<ul>
<li><p>Produer</p>
<ul>
<li>빈 버퍼가 있으면 버퍼 획득하고, 버퍼에 락 걸고, 버퍼에 데이터 넣고, 버퍼에 락 풀고, full++</li>
</ul>
</li>
<li><p>Consumer</p>
<ul>
<li>내용이 들어잇는 버퍼 있으면, 버퍼에 락 걸고, 버퍼에서 데이터 빼고, 버퍼 락 풀고, empty ++</li>
</ul>
</li>
</ul>
<h5 id="Readers-Writes-Problem"><a href="#Readers-Writes-Problem" class="headerlink" title="Readers-Writes Problem"></a>Readers-Writes Problem</h5><p>한 process가 DB에 write 중일 때 다른 process가 접근하면 안됨 / read는 동시에 여럿이 해도 됨</p>
<ul>
<li>Shared data<ul>
<li>DB 자체</li>
<li>int readcount=0; //현재 DB에 접근 중인 Reader의 수</li>
</ul>
</li>
<li>Sysncronization variablees<ul>
<li>semaphore mutex =1 ( 공유변수 readcount를 접근하는 코드의 mutual exlution 보장), db=1;</li>
</ul>
</li>
</ul>
<p><img src="/image/os100716.png" alt></p>
<h5 id="Dining-Philosophers-Problem"><a href="#Dining-Philosophers-Problem" class="headerlink" title="Dining-Philosophers Problem"></a>Dining-Philosophers Problem</h5><p>배가 고파지면 자기의 왼쪽과 오른쪽에 놓아져 있는 젓가락을 잡음</p>
<p><img src="/image/os100717.png" alt></p>
<p><img src="/image/os100718.png" alt></p>
<ul>
<li><p>문제</p>
<ul>
<li>모두다 왼쪽 젓가락을 잡아버리면? </li>
<li>Deadlock</li>
</ul>
</li>
<li><p>해결</p>
<ul>
<li>4명의 철학자만이 테이블에 동시에 앉을 수 있도록</li>
<li>젓가락을 두개 모두 집을 수 있을 때에만 젓가락을 잡을 수 있도록 (아래의 경우)</li>
<li>비대칭. 짝수 철학자는 왼쪽 젓가락부터 집도록</li>
</ul>
</li>
</ul>
<p>enum {thinking, hungry, eating} state[5];</p>
<p>semaphore self[5]=0;    // 동시에 젓가락 두개 모두 잡을 수 있는 권한</p>
<p>semaphore mutex=1;</p>
<p><img src="/image/os100719.png" alt></p>
<p><img src="/image/os100720.png" alt></p>
<h5 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h5><ul>
<li>Semaphore의 문제점<ul>
<li>코딩이 힘들다</li>
<li>정확성의 입증이 어려움</li>
<li>자발적 협력이 필요</li>
<li>한번의 실수가 모든 시스템에 영향</li>
</ul>
</li>
</ul>
<p><img src="/image/os100721.png" alt></p>
<ul>
<li>동시 수행중인 프로세스 사이에서 abstract data type의 안전한 공유를 보장하기위한 high-level syncronization  construct <ul>
<li>모니터 내에서는 한번에 하나의 하나의 프로세스만이 활동 가능</li>
<li>프로그래머가 동기화 제약 조건을 명시적으로 코딩할 필요 없음</li>
<li>프로세스가 모니터 안에서 기다릴수 있도록 하기 위해 condition variable 사용. condition x, y</li>
<li>condition variable 은 wait와 signal 연산에 의해서만 접근 가능<ul>
<li>x.wait();<ul>
<li>x.wait()을 invoke한 프로세스는 다른 프로세스가 x.signal()을 invoke 하기 전까지 suspend</li>
</ul>
</li>
<li>x.siganl();<ul>
<li>x.signal()은 정확하게 하나의 suspend된 프로세스를 resume한다. Suspend된 프로세스가 없으면 아무 일도 일어나지 않는다. </li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/image/os100722.png" alt></p>
<p><img src="/image/os100723.png" alt></p>
<p><img src="/image/os100724.png" alt></p>
<h5 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h5><p>이화여자대학교 반효경 (<a href="http://www.kocw.net/home/search/kemView.do?kemId=1046323" target="_blank" rel="noopener">http://www.kocw.net/home/search/kemView.do?kemId=1046323</a>)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kojunhee.github.io/2018/10/06/Process Synchronization/" data-id="ck913utyj00pjp26wr87ing4j" data-title="Process Sysncronization" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-보물상자 비밀번호" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/10/04/보물상자 비밀번호/" class="article-date">
  <time class="dt-published" datetime="2018-10-03T15:00:00.000Z" itemprop="datePublished">2018-10-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/algorithm/">Algorithm</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/10/04/보물상자 비밀번호/">보물상자 비밀번호</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><a href="https://www.swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWXRUN9KfZ8DFAUo&amp;categoryId=AWXRUN9KfZ8DFAUo&amp;categoryType=CODE" target="_blank" rel="noopener">https://www.swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWXRUN9KfZ8DFAUo&amp;categoryId=AWXRUN9KfZ8DFAUo&amp;categoryType=CODE</a></p>
<p>쉬운 문제이다. 이 문제에서는 정렬과 진법 변환을 배울 수 있다.</p>
<h2 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h2><ol>
<li>회전 시키고</li>
<li>각 변 확인하며 리스트에 저장</li>
</ol>
<h2 id="개념"><a href="#개념" class="headerlink" title="개념"></a>개념</h2><ol>
<li><p>정렬</p>
<p>오름차순 정렬 : Collections.sort(list)</p>
<p>내림차순 정렬 : Collections.sort(list) –&gt;  Collections.reverse(list)</p>
</li>
<li><p>진법 변환</p>
<p>string 을 radix 진법으로 변환 : Integer.parseInt(String s, int radix) </p>
</li>
</ol>
<h2 id="코드"><a href="#코드" class="headerlink" title="코드"></a>코드</h2><p><img src="/image/treasurepwd01.png" alt></p>
<p><img src="/image/treasurepwd02.png" alt></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kojunhee.github.io/2018/10/04/보물상자 비밀번호/" data-id="ck913utu000gzp26wxcw7ybbh" data-title="보물상자 비밀번호" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-벽돌깨기" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/10/04/벽돌깨기/" class="article-date">
  <time class="dt-published" datetime="2018-10-03T15:00:00.000Z" itemprop="datePublished">2018-10-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/algorithm/">Algorithm</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/10/04/벽돌깨기/">벽돌깨기</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><a href="https://www.swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWXRQm6qfL0DFAUo&amp;categoryId=AWXRQm6qfL0DFAUo&amp;categoryType=CODE&amp;&amp;&amp;" target="_blank" rel="noopener">https://www.swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWXRQm6qfL0DFAUo&amp;categoryId=AWXRQm6qfL0DFAUo&amp;categoryType=CODE&amp;&amp;&amp;</a></p>
<p>어려운 문제는 아니다. 방향은 잡았는데, 코드로 구현하는데 오래 걸렸다.</p>
<h2 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h2><ol>
<li>구슬 선택 : DFS</li>
<li>벽돌 깨기 : 재귀</li>
</ol>
<p>DFS는 다음 그림과 같이 진행한다. 구슬을 쏠 수 있는 칼럼은 0, 1, 2, 3 으로 4개가 있다고 하면,</p>
<p><img src="/image/breakBrick02.png" alt></p>
<p>재귀는 다음 그림과 같이 구현한다. 3을 기준으로 벽돌을 깬다고 하면, </p>
<p>3 기준 동서남북을 체크한다. 3의 동쪽을 깨는 중에, 9가 나오기 때문에, 9 위치에서 다시 재귀 함수를 호출 한다.</p>
<p><img src="/image/breakBrick01.png" alt></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kojunhee.github.io/2018/10/04/벽돌깨기/" data-id="ck913uttx00gwp26whcn6ygsp" data-title="벽돌깨기" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Process Managemnet" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/10/04/Process Managemnet/" class="article-date">
  <time class="dt-published" datetime="2018-10-03T15:00:00.000Z" itemprop="datePublished">2018-10-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/os/">OS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/10/04/Process Managemnet/">Process Management</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>출처 : 이화여자대학교 반효경 (<a href="http://www.kocw.net/home/search/kemView.do?kemId=1046323" target="_blank" rel="noopener">http://www.kocw.net/home/search/kemView.do?kemId=1046323</a>)</p>
<h2 id="프로세스-생성"><a href="#프로세스-생성" class="headerlink" title="프로세스 생성"></a>프로세스 생성</h2><ul>
<li>부모 프로세스가 자식 프로세스 생성</li>
<li>프로세스의 트리(계층 구조) 생성</li>
<li>프로세스는 자원을 필요로 함<ul>
<li>운영체제로부터 받는다</li>
<li>부모와 공유한다</li>
</ul>
</li>
<li>주소 공간<ul>
<li>자식은 부모의 공간을 복사</li>
<li>자식은 그 공간에 새로운 프로그램을 올림</li>
</ul>
</li>
<li>유닉스의 예 : 복제 생성하고 덮어씌움<ul>
<li>fork() 시스템 콜이 새로운 프로세스를 복제 생성<ul>
<li>부모를 그대로 복사</li>
<li>주소 공간 할당</li>
</ul>
</li>
<li>exec()<ul>
<li>fork 다음에 이어지는  exec() 시스템 콜을 통해 새로운 프로그램을 메모리에 올림 (덮어 씌움)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="프로세스-종료"><a href="#프로세스-종료" class="headerlink" title="프로세스 종료"></a>프로세스 종료</h2><ul>
<li>exit<ul>
<li>exit 시스템 콜을 통해 프로세스가 마지막 명령을 수행한후 운영체제에게 이를 알려줌</li>
<li>자식이 부모에게 output data를 보냄(via wait system call)</li>
<li>프로세의 각종 자원들이 운영체제에게 반납됨</li>
</ul>
</li>
<li>abort<ul>
<li>부모 프로세스가 자식의 수행을 종료시킴</li>
<li>자식이 할당 자원의 한계치를 넘어섬</li>
<li>자식에게 할당된 테스크가 더 이사 필요하지 않음</li>
<li>부모가 종료하는 경우<ul>
<li>운영체제는 부모 프로세스가 종료하는 경우 자식이 더 이상 수행되도록 두지 않음</li>
<li>단계적인 종료</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="fork-system-call"><a href="#fork-system-call" class="headerlink" title="fork() system call"></a>fork() system call</h2><p>왼쪽은 부모, 오른쪽은 자식. 자식은 fork() 이후의 라인부터 실행</p>
<p><img src="/image/os100401.png" alt></p>
<p><img src="/image/os100402.png" alt></p>
<h2 id="exec-system-call"><a href="#exec-system-call" class="headerlink" title="exec() system call"></a>exec() system call</h2><p>새로운 프로그램을 덮어씌움. </p>
<p>부모가 자식을 만든다음에, 자식은 오른쪽의 date라는 프로그램으로 완전히 덮어씌었음</p>
<p><img src="/image/os100403.png" alt></p>
<h2 id="wait-system-call"><a href="#wait-system-call" class="headerlink" title="wait() system call"></a>wait() system call</h2><p>프로세스 A가 wait() system call을 하면, </p>
<p>커널은 child가 종료될 때까지 프로세스 A를 slepp 시킴(block 상태)</p>
<p>child process가 종료되면 커널은 프로세스 A를 깨움(ready 상태)</p>
<p><img src="/image/os100404.png" alt></p>
<h2 id="exit-system-call"><a href="#exit-system-call" class="headerlink" title="exit() system call"></a>exit() system call</h2><p>프로세스의 종료</p>
<ul>
<li>자발적 종료<ul>
<li>마지막 statement 수행 후에 exit() 시스템 콜 통해</li>
<li>프로그램에 명싱적으로 적어주지 않아도 main 함수가 리턴되는 위치에 컴파일러가 넣어줌</li>
</ul>
</li>
<li>비자발적 종료<ul>
<li>부모가 자식을 죽임<ul>
<li>자식이 한계치 넘어서는 자원 자원 요청</li>
<li>자식에게 할당된 테스크가 더이상 필요하지 않음</li>
</ul>
</li>
<li>키모드로 kill, break 친 경우</li>
<li>부모가 종료하는 경우<ul>
<li>부모가 종료하기 전에 자식들이 먼저 종료됨</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="프로세스-간-협력"><a href="#프로세스-간-협력" class="headerlink" title="프로세스 간 협력"></a>프로세스 간 협력</h2><ul>
<li>독릭접 프로세스<ul>
<li>프로세는 각자의 주소 공간을 가지고 수행되므로 원친적으로 하나의 프로세스가 다른 프로세스의 수행에 영향을 미치지 못함</li>
</ul>
</li>
<li>협력 프로세스<ul>
<li>하나의 프로세스가 다른 프로세싀의 수행에 여향을 미칠 수 있음</li>
</ul>
</li>
<li>프로세스 간 협력 메커니즘(IPC : Interprocess Communication)<ul>
<li>메세지를 전달하는 방법 (message passing)<ul>
<li>커널을 통해 메세지 전달</li>
</ul>
</li>
<li>주소 공간을 공유하는 방법 (shraed memory)<ul>
<li>서로 다른 프로세 간에도 일부 주소 공간을 공유하게하는 메커니즘</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="IPC"><a href="#IPC" class="headerlink" title="IPC"></a>IPC</h2><p><img src="/image/os100405.png" alt></p>
<h2 id="Message-Passing"><a href="#Message-Passing" class="headerlink" title="Message Passing"></a>Message Passing</h2><p><img src="/image/os100406.png" alt></p>
<ul>
<li><p>Direcit Communicaiton</p>
<ul>
<li>통신하려는 프로세스의 이름을 명시적으료 표시</li>
</ul>
</li>
<li><p>Indirecit Communicaiton</p>
<ul>
<li>mailbot or port 를 통해 메시지를 간접 전달</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kojunhee.github.io/2018/10/04/Process Managemnet/" data-id="ck913uttx00gup26w49gwc0vk" data-title="Process Management" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/16/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><a class="page-number" href="/page/16/">16</a><span class="page-number current">17</span><a class="page-number" href="/page/18/">18</a><a class="page-number" href="/page/19/">19</a><span class="space">&hellip;</span><a class="page-number" href="/page/47/">47</a><a class="extend next" rel="next" href="/page/18/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/algorithm/">Algorithm</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/big-data/">Big Data</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/boost-course/">Boost Course</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/dip/">DIP</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/data-structure/">Data Structure</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/database/">Database</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/design-pattern/">Design Pattern</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/git/">Git</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/jpa/">JPA</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kafka/">Kafka</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/network/">Network</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/node-js/">Node.js</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/oop/">OOP</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/os/">OS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/software-engineering/">Software Engineering</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/spark/">Spark</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/tdd/">TDD</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/etc/">etc</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ios/">iOS</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/04/07/bigdata-chapter-06/">[빅데이터] 6장_일괄처리 계층</a>
          </li>
        
          <li>
            <a href="/2020/04/06/tdd-chapter-28/">[테스트 주도 개발] 28장_초록 막대 패턴</a>
          </li>
        
          <li>
            <a href="/2020/04/06/tdd-chapter-27/">[테스트 주도 개발] 27장_테스팅 패턴</a>
          </li>
        
          <li>
            <a href="/2020/04/06/tdd-chapter-26/">[테스트 주도 개발] 26장_빨간 막대 패턴</a>
          </li>
        
          <li>
            <a href="/2020/04/06/tdd-chapter-25/">[테스트 주도 개발] 25장_테스트 주도 개발 패턴</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 junhee.ko<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="/js/jquery-3.4.1.min.js"></script>


  <script src="/fancybox/jquery.fancybox.min.js"></script>


<script src="/js/script.js"></script>




  </div>
</body>
</html>