<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.1"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Always Learning</title><meta property="og:type" content="blog"><meta property="og:title" content="Always Learning"><meta property="og:url" content="https://kojunhee.github.io/"><meta property="og:site_name" content="Always Learning"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://kojunhee.github.io/img/og_image.png"><meta property="article:author" content="junhee.ko"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://kojunhee.github.io"},"headline":"Always Learning","image":["https://kojunhee.github.io/img/og_image.png"],"author":{"@type":"Person","name":"junhee.ko"},"description":null}</script><link rel="icon" href="/img/favicon.ico"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/default.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><script data-ad-client="ca-pub-6880109808178384" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js" async></script></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Always Learning" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a></div><div class="navbar-end"><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-02-09T15:00:00.000Z" title="2020-02-09T15:00:00.000Z">2020-02-10</time><span class="level-item"><a class="link-muted" href="/categories/oop/">OOP</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/02/10/object-chapter-appendix-b/">[오브젝트] 부록 B 타입 계층의 구현</a></h1><div class="content"><p>타입과 타입 계층을 구현할 수 있는 방법들을 정리하자.</p>
<h5 id="클래스를-이용한-타입-계층-구현"><a href="#클래스를-이용한-타입-계층-구현" class="headerlink" title="클래스를 이용한 타입 계층 구현"></a>클래스를 이용한 타입 계층 구현</h5><p>타입은 객체의 퍼블릭 인터페이스이다. 클래스는 객체의 타입과 구현을 동시에 정의한 것이다.</p>
<p>Phone 클래스가 있다. Phone 의 인스턴스는 calculateFee 메시지를 수신할 수 있는 퍼블릭 메서드를 구현한다. 타입은 퍼블릭 인터페이스이기 때문에, Phone 클래스는 calculateFee 메세지에 응답할 수 있는 타입을 선언한 동시에 객체 구현을 정의한 것이다.</p>
<p>상속은, 퍼블릭 인터페이스는 유지하면서 새로운 구현을 가진 객체를 추가할 수 있는 간단한 방법이다. 하지만, 상속은 자식 클래스를 부모 클래스의 구현에 강하게 결합시킨다.</p>
<h5 id="인터페이스를-이용한-타입-계층-구현"><a href="#인터페이스를-이용한-타입-계층-구현" class="headerlink" title="인터페이스를 이용한 타입 계층 구현"></a>인터페이스를 이용한 타입 계층 구현</h5><p>인터페이스는, 상속으로 인한 결합도 문제를 피하고 다중 상속이라는 구현 제약을 해결할 수 있는 방법이다. </p>
<h5 id="추상-클래스를-이용한-타입-계층-구현"><a href="#추상-클래스를-이용한-타입-계층-구현" class="headerlink" title="추상 클래스를 이용한 타입 계층 구현"></a>추상 클래스를 이용한 타입 계층 구현</h5><p>추상 클래스는, 클래스 상속을 이용해 구현을 공유하면서도 결합도로 인한 부작용을 피하는 방법이다.</p>
<h5 id="추상-클래스와-인터페이스-결합하기"><a href="#추상-클래스와-인터페이스-결합하기" class="headerlink" title="추상 클래스와 인터페이스 결합하기"></a>추상 클래스와 인터페이스 결합하기</h5><p>인터페이스를 이용해 타입을 정의하고 특정 상속 계층에 국한된 코드를 공유할 필요가 있으면 추상 클래스를 이용해 코드 중복을 방지 할 수 있다. 이것이 골격 구현 추상 클래스이다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DiscountPolicy</span> </span>&#123;</span><br><span class="line">  <span class="function">Money <span class="title">calculateDiscountAmount</span><span class="params">(Screening screeing)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultDiscountPolicy</span> <span class="keyword">implements</span> <span class="title">DiscountPolicy</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">   </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Money <span class="title">calculateDiscountAmount</span><span class="params">(Screening screeing)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">abstract</span> <span class="keyword">protected</span> Money <span class="title">getDiscountAmount</span><span class="params">(Screeing screening)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="덕-타이핑-사용하기"><a href="#덕-타이핑-사용하기" class="headerlink" title="덕 타이핑 사용하기"></a>덕 타이핑 사용하기</h5><p>덕 테스트는 어떤 대상의 행동이 오리와 같다면 그것을 오리라는 타입으로 취급해도 무방하다는 것이다. 즉, 객체가 어떤 인터페이스에 정의된 행동을 수행할 수 있다면 그 객체를 해당 타입으로 분류해도 문제가 없다.</p>
<p>자바 같은 대부분의 정적 타입 언어에서는 두 클래스를 동일한 타입으로 취급하기 위해서는, 코드 상의 타입이 동일하게 선언되어 있어야한다. </p>
<p>반면, 런타입에 타입을 결정하는 동적 타입 언어에서는 특정한 클래스를 상속받거나 인터페이스를 구현하지 않고도 객체가 수신할 수 있는 메세지의 지합으로 객체의 타입을 결정할 수 있다.</p>
<h5 id="믹스인과-타입-계층"><a href="#믹스인과-타입-계층" class="headerlink" title="믹스인과 타입 계층"></a>믹스인과 타입 계층</h5><p>믹스인은, 객체를 생성할 때 코드 일부를 섞어 넣을 수 있도록 만들어진 일종의 추상 서브클래스이다. 사용하는 목적은, 다양한 객체의 구현 안에서 동일한 행동을 중복 코드 없이 재사용할 수 있게 만드는 것이다. 즉, 공통의 행동이 믹스인된 객체들은 동일한 메세지를 수신할 수 있는 퍼블릭 인터페이스를 공유하는 것이다. 예를 들어, 스칼라의 trait 로 구현할 수 있다.</p>
<p>스칼라의 trait 와 유사하게, 자바 8에 추가된 default method 는 인터페스에 메서드의 기본 구현을 추가하는 것을 허용한다. 디폴트 메서드가 제공하는 혜택을 누리기 위해서는 한계를 명확히 인식해야한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DiscountPolicy</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">default</span> Money <span class="title">calculateDiscountAmount</span><span class="params">(Screening screeing)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(DiscountCondition each : getConditions())&#123;</span><br><span class="line">      <span class="keyword">if</span>(each.isSatisfiedBy(screeing))&#123;</span><br><span class="line">        <span class="keyword">return</span> getDiscountAmount(screening);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> screening.getMovieFee();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function">List&lt;DiscountCondition&gt; <span class="title">getConditions</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">Money <span class="title">getDiscountAmount</span><span class="params">(Screeing screening)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>calculateDiscountAmount 가 내부적으로 두개의 메서드를 사용한다. 그래서 이 인터페이스를 구현하는 모든 클래스들은 해당 메서드의 구현을 제공해야한다는 것을 명시한 것이다.</p>
<p>추상 클래스를 사용했을 경우에는, getDiscountAmount 메서드의 가시성이 protected 였다. 하지만 이제 디폴트 메서드안에서 사용된다는 이유만으로 public 메서드가 되어야한다. 이것은 외부에 노출할 필요가 없는 메서드를 불필요하게 퍼블릭 인터페이스에 추가한 결과를 낳는다.</p>
<p>디폴트 메서드가 추가된 이유는, 인터페이스에 새로운 오퍼레이션을 추가할 경우에 발생하는 하위 호환성 문제를 해결하기 위해서이다. 추상 클래스를 제거하기 위해서가 아니다.</p>
<hr>
<p>오브젝트 &lt;조영호&gt;</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-02-09T15:00:00.000Z" title="2020-02-09T15:00:00.000Z">2020-02-10</time><span class="level-item"><a class="link-muted" href="/categories/oop/">OOP</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/02/10/object-chapter-appendix-c/">[오브젝트] 부록 C 동적인 협력, 정적인 코드</a></h1><div class="content"><p>좋은 설계는 객체 사이의 협력과 행동을 표현하는 동적 모델을 기반으로 해야한다.</p>
<ol>
<li><p>동적 모델<br>프로그램 실행 구조를 표현하는 움직이는 모델</p>
</li>
<li><p>정적 모델<br>코드의 구조를 담는 고정된 모델</p>
</li>
</ol>
<h2 id="01-동적-모델과-정적-모델"><a href="#01-동적-모델과-정적-모델" class="headerlink" title="01 동적 모델과 정적 모델"></a>01 동적 모델과 정적 모델</h2><h5 id="행동이-코드를-결정한다"><a href="#행동이-코드를-결정한다" class="headerlink" title="행동이 코드를 결정한다"></a>행동이 코드를 결정한다</h5><p>객체가 외부에 제공하는 행동이 중요하다. 동적 모델이 정적 모델을 결정해야한다.</p>
<h2 id="02-도메인-모델과-구현"><a href="#02-도메인-모델과-구현" class="headerlink" title="02 도메인 모델과 구현"></a>02 도메인 모델과 구현</h2><h5 id="도메인-모델에-관하여"><a href="#도메인-모델에-관하여" class="headerlink" title="도메인 모델에 관하여"></a>도메인 모델에 관하여</h5><ol>
<li><p>도메인<br>사용자가 프로그램을 사용하는 대상 영역</p>
</li>
<li><p>모델<br>지식을 선택적으로 단순화하고 의식적으로 구조화한 형태</p>
</li>
<li><p>도메인 모델<br>사용자가 프로그램을 사용하는 대상 영역에 대한 지식을 선택적으로 단순화하고 의식적으로 구조화한 형태</p>
</li>
</ol>
<p>소프트웨어의 도메인에 대해 고민하고 도메인 모델을 기반으로 소프트웨어를 구축해야한다. 그러면, 개념과 소프트웨어 사이의 표현적 차이를 줄일 수 있기 때문에 이해하고 수정하기 쉬온 소프트웨어를 만들 수 있다. </p>
<p>중요한 것은, 도메인 모델을 작성하는 것이 목표가 아니라 출발점이다. 중요한 것은 객체들의 협력을 지원하는 코드 구조를 만드는 것이다. 코드의 구조를 주도하는 것은 행동이다.</p>
<h5 id="행동과-변경을-고려한-도메인-모델"><a href="#행동과-변경을-고려한-도메인-모델" class="headerlink" title="행동과 변경을 고려한 도메인 모델"></a>행동과 변경을 고려한 도메인 모델</h5><p>도메인 모델은 단순히 클래스 다이어그램이 아니다. 도메인의 핵심을 간략하게 단순화해서 표현할 수 있는 모든 것이다. 이렇게 작성된 개념이 코드에 대한 구조와 행동을 드러내면 훌륭한 도메인 모델이다.</p>
<hr>
<p>오브젝트 &lt;조영호&gt;</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-02-02T15:00:00.000Z" title="2020-02-02T15:00:00.000Z">2020-02-03</time><span class="level-item"><a class="link-muted" href="/categories/oop/">OOP</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/02/03/object-chapter-appendix-a/">[오브젝트] 부록 A 계약에 의한 설계</a></h1><div class="content"><p>인터페이스만으로 객체의 행동에 관한 다양한 관점을 전달하기 어렵다.<br>명령의 부수효과를 쉽고 명확하게 표현할 수 있는 커뮤니케이션 수단이, 계약에 의한 설계이다.<br>여기서 중요한 것은 코드가 아니라, 개념이다.</p>
<h2 id="01-협력과-계약"><a href="#01-협력과-계약" class="headerlink" title="01 협력과 계약"></a>01 협력과 계약</h2><h5 id="부수-효과를-명시적으로"><a href="#부수-효과를-명시적으로" class="headerlink" title="부수 효과를 명시적으로"></a>부수 효과를 명시적으로</h5><p>일반적인 정합성 체크 로직은 코드의 구현 내부에 숨겨져있어 실제로 코드를 분석하지 않는 한 정확하게 파악하기 어렵다.</p>
<p>하지만, Code Contracts 와 같이 계약에 의한 설계를 지원하는 라이브러리나 언어들은 일반 로직과 구분할 수 있도록 제약 조건을 명시적으로 표현하는 것이 가능하다.</p>
<h2 id="02-계약에-의한-설계"><a href="#02-계약에-의한-설계" class="headerlink" title="02 계약에 의한 설계"></a>02 계약에 의한 설계</h2><p>버트란드 마이어가 제시한 계약은, 사람들 사이의 계약과 유사하다. 계약은 협력에 참여하는 두 객체 사이의 의무와 이익을 문서화한 것이다.</p>
<ol>
<li>협력에 참여하는 객체는 계약으로부터 이익을 기대하고 이익을 얻기위해 의무를 이행한다.</li>
<li>협력에 참여하는 객체의 이익과 의무는 객체의 인터페이스 상에 문서화된다.</li>
</ol>
<p>의도를 드러내는 인터페이스는 오퍼레이션의 시그니처만으로 어느 정도 클라이언트와 서버가 협력을 위해 수행해야하는 제약 조건을 명시한다.</p>
<p>계약은 여기서 한 걸음 더 나아간다. 서버는 자신이 처리할 수 있는 범위의 값들을 클라이언트가 전달할 것으로 기대한다. 클아이언트는 자신이 원하는 값을 서버가 반환할 것이라고 예상한다. 클아이언트는 메세지 전송 전과 후의 서버 상태가 정상일 것이라고 기대한다.</p>
<ol>
<li><p>사전 조건<br>메서드가 호출되기 위해 만족되어야하는 조건. 클라이언트의 의무</p>
</li>
<li><p>사후 조건<br>메서드가 실행된 후에 클라이언트에게 보장해야하는 조건. 서버의 의무</p>
</li>
<li><p>불변식<br>항상 참이라고 보장되는 서버의 조건</p>
</li>
</ol>
<h5 id="사전-조건"><a href="#사전-조건" class="headerlink" title="사전 조건"></a>사전 조건</h5><p>클라이언트가 사전 조건을 만족시키지 못하면, 메서드는 최대한 빨리 실패해서 클라이언트에게 버그가 있다는 사실을 알린다.</p>
<h5 id="사후-조건"><a href="#사후-조건" class="headerlink" title="사후 조건"></a>사후 조건</h5><p>다음 세 용도로 사용된다.</p>
<ol>
<li>인스턴스 변수의 상태가 올바른지 서술하기 위해</li>
<li>메스드에 전달된 파라미터의 값이 올바르게 변경됐는지를 서술하기 위해</li>
<li>반환값이 올바른지를 서술하기 위해</li>
</ol>
<h5 id="불변식"><a href="#불변식" class="headerlink" title="불변식"></a>불변식</h5><p>객체의 내부 상태와 관련이 있다.</p>
<p>메서드 실행 중에는 객체의 상태가 불안정한 상태로 빠질 수 있기 때문에 불변식을 만족시킬 필요가 없지만, 메서드 실행 전과 종료 후에는 항상 불변식을 만족해야한다.</p>
<h2 id="03-계약에-의한-설계와-서브타이핑"><a href="#03-계약에-의한-설계와-서브타이핑" class="headerlink" title="03 계약에 의한 설계와 서브타이핑"></a>03 계약에 의한 설계와 서브타이핑</h2><p>리스코프 치환 원칙은, 슈퍼타입의 인스턴스와 협력하는 클라이언트의 관점에서 서브타입의 인스턴스가 슈퍼타입을 대체하더라도 협력에 지장이 없어야 한다는 것을 의미한다.</p>
<p>따라서 서브타입이 리스코프 치환 원칙을 만족하기 위해서는, 클라이언트와 슈퍼타입 간에 체결된 계약을 준수해야한다.</p>
<h5 id="계약-규칙"><a href="#계약-규칙" class="headerlink" title="계약 규칙"></a>계약 규칙</h5><ol>
<li><p>서브타입에 더 강력한 사전 조건을 정의할 수 없다.<br>계약서에 명시된 의무보다 더 많은 의무를 짊어져야한다는 사실을 납득하는 클라이언트는 없다.</p>
</li>
<li><p>서브타입에 더 완화된 사후 조건을 정의할 수 없다.<br>계약서에 명시된 이익보다 더 적은 이익을 받게 되는 사실을 납득하는 클라이언트는 없다.</p>
</li>
<li><p>슈퍼타입의 불변식은 서브타입에서도 유지되어야 한다.<br>메서드 실행 중에는 불변식을 만족시키지 않아도 되지만, 메서드 실행 전과 후에는 만족해야한다.</p>
</li>
</ol>
<h5 id="가변성-규칙"><a href="#가변성-규칙" class="headerlink" title="가변성 규칙"></a>가변성 규칙</h5><ol>
<li><p>서브타입은 슈퍼타입이 발생시키는 예외와 다른 타입의 예외를 발생시켜서는 안된다.<br>클라이언트는 Bird 의 인스턴스에 fly 메세지를 전송했을 때, UnsupportedOperationException 예외를 기대하지 않는다.</p>
</li>
<li><p>서브타입의 리턴타입은 공변성을 가져야한다.<br>리턴 타입 공변성 : 부모 클래스에서 구현된 메서드를 자식 클래스에서 오버라이딩할 때 부모 클래스에서 선언한 반환 타입의 서브타입으로 지정할 수 있는 특성</p>
</li>
<li><p>서브타입의 메서드 파라미터는 반공변성을 가져야 한다.<br>파라미터 타입 반공병성 : 부모 클래스에서 구현된 메서드를 자식 클래스에서 오버라이딩할 때 파라미터 타입을 부모 클래스에서 사용한 파라미터의 슈퍼타입으로 지정할 우 있는 특성</p>
</li>
</ol>
<hr>
<p>오브젝트 &lt;조영호&gt;</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-01-26T15:00:00.000Z" title="2020-01-26T15:00:00.000Z">2020-01-27</time><span class="level-item"><a class="link-muted" href="/categories/oop/">OOP</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/01/27/object-chapter15/">[오브젝트] 15장_디자인 패턴과 프레임워크</a></h1><div class="content"><ol>
<li><p>디자인 패턴<br>특정한 변경을 일관성있게 다룰 수 있는 협력 텝플릿 제공.<br>설계를 재사용하는 것이 목적.</p>
</li>
<li><p>프레임워크<br>특정한 변경을 일관성 있게 다룰 수 있는 확장 가능한 코드 템플릿 제공.<br>설계와 코드를 함께 재사용하기 위한 것이 목적.</p>
</li>
</ol>
<h2 id="01-디자인-패턴과-설계-재사용"><a href="#01-디자인-패턴과-설계-재사용" class="headerlink" title="01 디자인 패턴과 설계 재사용"></a>01 디자인 패턴과 설계 재사용</h2><h5 id="소프트웨어-패턴"><a href="#소프트웨어-패턴" class="headerlink" title="소프트웨어 패턴"></a>소프트웨어 패턴</h5><p>패턴의 특징은,</p>
<ol>
<li>반복적으로 발생하는 문제와 해법의 쌍으로 정의된다.</li>
<li>패턴을 사용해서 이미 알려진 문제와 이에 대한 해법을 문서로 정리할 수 있다. 다른 사람과 의사소통 가능.</li>
<li>추상적인 원칙과 실제 코드 작성 사이의 간극을 메워준다. 실질적인 코드 작성을 돕는다.</li>
<li>패턴은 실무에서 탄생했다.</li>
</ol>
<p>마틴 파울러에 의하면, 패턴은 하나의 실무 컨텍스트에서 유용하게 사용해왔고 다른 실무 컨텍스트엣도 유용할 것이라고 예상되는 아이디어다. 프로젝트 조직을 구성하는 방법, 프로젝트 일정을 추정하는 방법 등 반복적인 규칙을 발견할 수 있는 모든 영역이 패턴의 대상이다.</p>
<h5 id="패턴-분류"><a href="#패턴-분류" class="headerlink" title="패턴 분류"></a>패턴 분류</h5><ol>
<li><p>디자인 패턴<br>일반적인 설계 문제를 해결하며, 협력하는 컴포넌트들 사이에서 반복적으로 발생하는 구조를 서술한다. </p>
</li>
<li><p>아키텍쳐 패턴<br>디자인 패턴의 상위에 있다. 소프트웨어의 전체적인 구조를 결정한다.<br>미리 정의된 서브시스템들을 제공하고, 각 서브시스템들의 책임을 정의한다.<br>서트시스템들 사이의 관계를 조직화하고 규칙과 가이드라인을 포함한다.</p>
</li>
<li><p>이디엄<br>디자인 패턴의 하위에 있다. 특정 프로그래밍 언어에만 국한된 하위 레벨 패턴이다.<br>주어진 언어의 기능을 사용해 컴포넌트, 혹은 컴포넌트간의 특정 측면을 구현하는 방법을 서술한다.<br>예를 들어, C++ 의 COUNT POINT 이디엄은 자바에서는 유용하지 않다.</p>
</li>
<li><p>분석 패턴<br>도메인 내의 개념적인 문제를 해결하는데 초점을 맞춘다.</p>
</li>
</ol>
<h5 id="패턴과-책임-주도-설계"><a href="#패턴과-책임-주도-설계" class="headerlink" title="패턴과 책임-주도 설계"></a>패턴과 책임-주도 설계</h5><p>객체지향 설계에서 중요한 일은, <code>올바른 책임을 올바른 객체에게 할당하고 객체 간의 유연한 협력 관계를 구축하는 것</code>이다.</p>
<p>패턴은 공통으로 사용할 수 있는 역할, 책임, 협력의 템플릿이다. 예를 들면,</p>
<ol>
<li><p>STRATEGY 패턴<br>다양한 알고리즘을 동적으로 교체할 수 있는 역할과 책임을 제공한다.</p>
</li>
<li><p>BRIDGE 패턴<br>추상화의 조합으로 인한 클래스의 폭발적 증가 문제를 해결하기 위해 역할과 책임을 추상화와 구현의 두 개의 커다란 집합으로 분해해서 설계를 확장가능하게 한다.</p>
</li>
<li><p>OBSERVER 패턴<br>유연한 통지 매커니즘을 구축하기 위해 객체 간의 결합도를 낮출 수 있는 역할과 책임을 제공한다.</p>
</li>
</ol>
<p>패턴의 구성 요소는 클래스가 아니라, ‘역할’ 이다.<br>예를 들어, 클라이언트가 개별 객체와 복합 객체를 동일하게 취급할 수 있는 COMPOSITE 패턴을 보자. </p>
<p><img src="/image/object_c15_01.png" alt=""></p>
<p>패턴의 구성요소인 component, composite, leaf 는 클래스가 아니라 협력에 참여하는 객체들의 역할이다. component는 역할이기 때문에 component 가 제공하는 오퍼레이션을 구현하는 어떤 객체라도 component 의 역할을 수행할 수 있다.</p>
<p><img src="/image/object_c15_02.png" alt=""></p>
<p>중복 할인 설계의 기본 구조는 COMPOSITE 패턴을 따른다.<br>디자인 패턴은 단지 역할과 책임, 협력의 템플릿을 제안할 뿐, 구체적인 구현 방법에 대해서는 제한을 두지 않는다.</p>
<h5 id="캡슐화와-디자인-패턴"><a href="#캡슐화와-디자인-패턴" class="headerlink" title="캡슐화와 디자인 패턴"></a>캡슐화와 디자인 패턴</h5><p>각 디자인 패턴은 특정한 변경을 캡슐화하기 위해 독자적인 방법을 정의하고 있다.</p>
<p><img src="/image/object_c15_03.png" alt=""></p>
<p>위 그림은 STRATEGY 패턴을 적용한 영화 예매 시스템 설계이다. 변경을 캡슐화하기 위해 합성을 이용한다. Movie 와 DiscountPolicy 사이의 결합도를 낮춰 런타임에 알고리즘을 변경할 수 있다.</p>
<p><img src="/image/object_c15_04.png" alt=""></p>
<p>위 그림은 TEMPLATE METHOD 패턴을 적용한 설계이다. 변경을 캡슐화하기 위해 상속을 이용한다. 부모 클래스의 calculateFee 메서드 안에서 추상 메서드를 호출하고 자식 클래스들이 이 메서드를 오버라이딩해서 변하는 부분을 구현하는 것이 중요하다.<br>TEMPLATE METHOD 패턴은 합성 보다는 결합도가 높은 상속을 사용했기 때문에 런타임에 객체의 알고리즘을 변경하는 것이 불가능하다. 하지만, 알고리즘 교체와 같은 요구사항이 없었으면 복잡도를 낮출 수 있다는 장점이 있다.</p>
<p><img src="/image/object_c15_05.png" alt=""></p>
<p>위 그림은 DECORATOR 패턴을 적용한 설계이다. 객체의 행동을 동적으로 추가할 수 있는 패턴으로서, 객체의 행동을 결합하기 위해 객체 합성을 사용한다.</p>
<p>디자인 패턴에서 중요한 것은, 디자인 패턴의 구현 방법이나 구조가 아니다. <code>어떤 변경을 캡슐화하는지 이해하고 변경을 캡슐화하기 위해 어떤 방법을 사용하는지</code> 이해해야한다.</p>
<h5 id="패턴은-출발점이다"><a href="#패턴은-출발점이다" class="headerlink" title="패턴은 출발점이다"></a>패턴은 출발점이다</h5><p>패턴 입문자의 문제는, 패턴을 적용하는 컨텍스트의 적절성을 무시하고 패턴의 구조에만 초점을 맞춘다는 것이다. 패턴을 적용할 때는 설계를 단순하고 명확하게 만들 수 있는 방법이 없는지를 고민해야한다. 그리고, 코드를 공유하는 모든 사람들이 적용된 패턴을 알고 있어야한다.</p>
<h2 id="02-프레임워크와-코드-재사용"><a href="#02-프레임워크와-코드-재사용" class="headerlink" title="02 프레임워크와 코드 재사용"></a>02 프레임워크와 코드 재사용</h2><h5 id="코드-재사용-대-설계-재사용"><a href="#코드-재사용-대-설계-재사용" class="headerlink" title="코드 재사용 대 설계 재사용"></a>코드 재사용 대 설계 재사용</h5><p>프레임워크란, </p>
<ol>
<li>추상 클래스나 인터페이스를 정의하고 인스턴스 사이의 상호작용을 통해 시스템 전체 혹은 일부를 구현해 놓은 재사용 가능한 설계이다. </li>
<li>또는, 애플리케이션 개바자가 현재의 요구사항에 맞게 커스터마이징할 수 있는 애플리케이션의 골격이다.</li>
</ol>
<h5 id="상위-정책과-하위-정책으로-패키지-분리하기"><a href="#상위-정책과-하위-정책으로-패키지-분리하기" class="headerlink" title="상위 정책과 하위 정책으로 패키지 분리하기"></a>상위 정책과 하위 정책으로 패키지 분리하기</h5><p>프레임워크의 핵심은, 추상 클래스나 인터페이스와 같은 추상화이다.</p>
<p><img src="/image/object_c15_06.png" alt=""></p>
<p>위 그림에서, 추상화는 짙은 색으로 표시되어 있다. <code>의존성 역전 원칙에 기반하여, 구체 클래스들은 상위 클래스에 의존하지만 추상화들은 구체 클래스에 의존하지 않는다</code>.</p>
<p>상위 정책은 상대적으로 변경에 안정적이지만 세부 사항은 자주 변경된다. 만약, 상위 정책이 자주 변하는 세부 사항에 의존하면 변경에 대한 파급 효과로 상위 정책이 불안정해진다.</p>
<p>요점은, 상위 정책이 세부 사항보다 더 다양한 상황에서 재사용할 수 있어야한다. 그래서, 상위 정책과 세부 사항 모두 추상화에 의존해야한다.</p>
<p>프레임워크는 여러 애플리케이션에 걸쳐 재사용가능해야하기 때문에, 변하는 것과 변하지 않는 것을 서로 다른 주기로 배포할 수 있도록, 배포 단위를 분리해야한다. 이를 위해, 변하는 부분과 변하지 않는 부분을 별도의 패키지로 분리할 수 있다.</p>
<p><img src="/image/object_c15_07.png" alt=""></p>
<p>중요한 것은, 패키지 사이의 의존성 방향이다. 세부사항을 구현한 패키지는 항상 상위 정책을 구현한 패키지에 의존해야한다.</p>
<p>상위 정책을 구현하고 있는 패키지를 다른 애플리케이션에 재사용할 수 있다. 즉, <code>재사용 가능한 요금 계산 로직을 구현한 프레임워크가 만들어진 것</code>이다.</p>
<h5 id="제어-역전-원리"><a href="#제어-역전-원리" class="headerlink" title="제어 역전 원리"></a>제어 역전 원리</h5><p>의존성 역전 원리는, 프레임워크의 가장 기본적인 설계 메커니즘이다. 의존성 역적은, 의존성 방향 뿐만 아니라 제어 흐름의 주체 역시 역전시킨다. 전통적인 구조에서는 상위 정책이 구체적인 세부 사항에 의존한다. 상위 정책의 코드가 하부의 구체적인 코드를 호출한다. 즉, 애플리케이션의 코드가 재사용 가능한 라이브러리나 툴킷의 코드를 호출한다.</p>
<p>하지만, 의존성을 역전 시킨 객치지향 구조에서는 반대로 프레임워크가 에플리케이션에 속하는 서브 클래스들의 메서드를 호출한다. 즉, 개별 애플리케이션에서 프레임워크로 제어 흐름의 주체가 이동한다. 이를 제어 역전 원리, 할리우드 원리라고 한다. 할리우드에서 캐스팅 담장자가 배우에게 “먼저 연락하지 마세요. 저희가 연락드릴게요” 라고 말하는 것처럼 프레임워크는 자신을 찾지 말라고 한다.</p>
<p><img src="/image/object_c15_08.png" alt=""></p>
<p>위 그림에서, 특정한 기본 정책을 구현하는 개발자는 FeeCondition 을 대체할 서브 타입만 개발하면 프레임워크에 정의된 플로우에 따라 요금이 계산된다. 프레임워크에서는 일반적인 해결책만 제공하고 애플리케이션에 따라 달라질 수 있는 특정한 동작은 비워둔다. 이렇게 완성되지 않은 채로 남겨진 동작을 hook 이라고 부른다.</p>
<hr>
<p>오브젝트 &lt;조영호&gt;</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-01-25T15:00:00.000Z" title="2020-01-25T15:00:00.000Z">2020-01-26</time><span class="level-item"><a class="link-muted" href="/categories/kafka/">Kafka</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/01/26/kafka-chapter7/">[카프카] 7장_데이터 파이프라인 구축</a></h1><div class="content"><p>데이터 파이프라인을 직접 구성해본다. 다음 애플리케이션을 사용한다.</p>
<ol>
<li>아파치 나이파이</li>
<li>엘라스틱 파일비트</li>
<li>엘라스틱 엘라스틱서치</li>
<li>엘라스틱 키바나</li>
</ol>
<h2 id="1-카프카를-활용한-데이터-흐름도"><a href="#1-카프카를-활용한-데이터-흐름도" class="headerlink" title="1. 카프카를 활용한 데이터 흐름도"></a>1. 카프카를 활용한 데이터 흐름도</h2><p><img src="/image/kafka_chapter07_01.png" alt=""></p>
<p>카프카에서 발생하는 로그를 이용해 데이터 흐름도를 구성해본다.<br>아파치 나이파이는 데이터 처리 흐름을 정의하고, 정의된 흐름대로 자동으로 실행해주는 애플리케이션이다.</p>
<ol>
<li>데이터 흐름을 처리하기 위한 워크플로우</li>
<li>데이터 처리</li>
</ol>
<h2 id="2-파일-비트를-이용한-메세지-전송"><a href="#2-파일-비트를-이용한-메세지-전송" class="headerlink" title="2. 파일 비트를 이용한 메세지 전송"></a>2. 파일 비트를 이용한 메세지 전송</h2><p>카프카의 로그를 카프카의 토픽으로 전송하려면 프로듀서가 필요하다. 프로듀서는,</p>
<ol>
<li>카프카 클라이언트 라이브러리를 이용해 프로그램으로 직접 구현</li>
<li>오픈소스 애플리케이션 이용. 여기서는 파일 비트.</li>
</ol>
<h2 id="3-나이파이를-이용해-메세지-가져오기"><a href="#3-나이파이를-이용해-메세지-가져오기" class="headerlink" title="3. 나이파이를 이용해 메세지 가져오기"></a>3. 나이파이를 이용해 메세지 가져오기</h2><p>이제 컨슈머를 이용해 카프카 토픽으로부터 메세지를 가져와와야한다. 컨슈머는,</p>
<ol>
<li>프로그래밍 언어로 직접 구현</li>
<li>오픈소스 애플리케이션 이용. 여기서는 나이파이.</li>
</ol>
<h4 id="3-1-나이파이를-이용한-컨슈머-설정"><a href="#3-1-나이파이를-이용한-컨슈머-설정" class="headerlink" title="3.1 나이파이를 이용한 컨슈머 설정"></a>3.1 나이파이를 이용한 컨슈머 설정</h4><p><img src="/image/kafka_chapter07_02.png" alt=""></p>
<p>프로세서를 추가하는 화면이다.<br>프로세서는 나이파이에서 데이터 처리를 위한 각각의 컴포넌트이다. AMQP 컨슘, 파일로 저장, 전송하기 등 여러가지 작업이 가능하다.<br>ConsumeKafka 프로세서를 추가하고 재생 버튼을 누르면, 설정한 브로커의 토픽에서 메세지를 가져오기 시작한다.<br>컨슈머가 잘 동작하는지 확인하는 방법은,</p>
<ol>
<li><p>나이파이에서 컨슈머 프로세서를 실행 시킨 후,</p>
</li>
<li><p>카프카 컨슈머 그룹 리스트에서, 등록한 컨슈머 그룹이 잘 등록되었는지 확인한다.<br>등록한 컨슈머 그룹 : ConsumeKafka 프로세서의 Properties 를 정의할 때 그룹 ID 를 기입했음.</p>
</li>
</ol>
<h2 id="4-실시간-분석을-위해-엘라스틱서치에-메세지-저장"><a href="#4-실시간-분석을-위해-엘라스틱서치에-메세지-저장" class="headerlink" title="4. 실시간 분석을 위해 엘라스틱서치에 메세지 저장"></a>4. 실시간 분석을 위해 엘라스틱서치에 메세지 저장</h2><p>이제, 가져온 메세지들을 나이파이의 또 다른 프로세서를 이용해 엘라스틱서치에 저장하겠다.<br>엘라스틱서치는 엘라스틱 사의 분산형 RESTFul 검색 및 분석 엔진이다. 전문 검색 질의를 이용해 원하는 데이터 분석을 빠르게 할 수 있는 애플리케이션이다.</p>
<h4 id="4-1-나이파이를-이용해-엘라스틱서치로-데이터-전송"><a href="#4-1-나이파이를-이용해-엘라스틱서치로-데이터-전송" class="headerlink" title="4.1 나이파이를 이용해 엘라스틱서치로 데이터 전송"></a>4.1 나이파이를 이용해 엘라스틱서치로 데이터 전송</h4><p>PutElasticsearchHttp 프로세서를 추가한다. 데이터를 엘라스틱서치로 넣어주는 역할을 한다.<br>그리고 다음 화면처럼, ConsumeKafka 와 연결한다.</p>
<p><img src="/image/kafka_chapter07_03.png" alt=""></p>
<p>데이터 흐름 중에 뒤에 있는 프로세서에서 처리 속도가 느려 바로 처리하지 못하거나 프로세서에 문제가 발생한 경우, 두 프로세스를 연결하는 큐에 레코드가 쌓인다.</p>
<h2 id="5-키바나를-이용해-엘라스틱서치에-저장된-데이터-확인"><a href="#5-키바나를-이용해-엘라스틱서치에-저장된-데이터-확인" class="headerlink" title="5. 키바나를 이용해 엘라스틱서치에 저장된 데이터 확인"></a>5. 키바나를 이용해 엘라스틱서치에 저장된 데이터 확인</h2><p>웹브라우저를 이용해 원하는 시간대에 발생한 로그들을 확인할 수 있고, 필터 기능으로 원하는 패턴의 로그만 빠르게 검색 가능하다.<br>각 브로커에서 수집되는 로그가 카프카의 토픽에 있기 때문에, 엘라스틱 서치에 전송하는 것 외에 추가로 하둡이나 로컬에 저장하길 원하면, 다음 화면처럼 나이파이의 PutHDFS 프로세서를 추가해 쉽게 하둡 등의 저장소에 저장할 수 있다.</p>
<p><img src="/image/kafka_chapter07_04.png" alt=""></p>
<h2 id="6-현재의-토픽을-이용해-새로운-토픽으로-메세지-재생산"><a href="#6-현재의-토픽을-이용해-새로운-토픽으로-메세지-재생산" class="headerlink" title="6. 현재의 토픽을 이용해 새로운 토픽으로 메세지 재생산"></a>6. 현재의 토픽을 이용해 새로운 토픽으로 메세지 재생산</h2><p><img src="/image/kafka_chapter07_05.png" alt=""></p>
<p>이번에는, 메세지의 양이 굉장히 많은 토픽의 내용 중 필요한 메세지만 꺼내서 다시 새로운 토픽으로 메세지를 보내는 방법을 정리한다.</p>
<p>전체적인 데이터 흐름은,</p>
<ol>
<li>나이파이 컨슈머가 peter-log 로부터 로그 메세지를 가져오면서 호스트 이름을 확인한다.</li>
<li>peter-log 토픽으로 로그 메세지를 보내는 서버는 peter-kafka001,peter-kafka002, peter-kafka003 모두 3대이다.</li>
<li>각각의 메세지마다 호스트 이름이 peter-kafka001,ppeter-kafka002, ppeter-kafka003 이 기록되어 있다.</li>
<li>전체 메세지 중에 호스트 이름이 peter-kafka001메세지만 peter-kafka001토픽으로 다시 전송하고,</li>
<li>나머지 메세지는 peter-failure 토픽으로 전송한다.</li>
</ol>
<h4 id="6-1-나이파이를-이용한-토픽별-라우팅"><a href="#6-1-나이파이를-이용한-토픽별-라우팅" class="headerlink" title="6.1 나이파이를 이용한 토픽별 라우팅"></a>6.1 나이파이를 이용한 토픽별 라우팅</h4><p>나이파이에서 토픽의 메세지를 가져와서 peter-kafka001 에서 온 메세지인지 확인한 후에 peter-kafka001 토픽으로 전송해야한다.<br>이를 위해, 나이파이의 EvaluateJsonPath, RouteOnAttribute 프로세서를 추가해서 라우팅 작업을 한다.</p>
<ol>
<li>EvaluateJsonPath 프로서는, 토픽으로 전송된 JSON 의 beat.hostname 을 읽어 호스트 이름을 구분한다.</li>
<li>RouteOnAttribute 프로세서는, attrubute 를 이용해 라우팅을 한다.</li>
</ol>
<p>마지막으로, 카프카 프로듀서 2개를 추가한다.</p>
<ol>
<li>호스트명이 peter-kafka001 인 메세지를  peter-kafka001 토픽으로 전송할 프로듀서</li>
<li>그 외 메세지를  peter-failure 토픽으로 전송할 프로듀서</li>
</ol>
<p>최종 플로우는 다음과 같다.</p>
<p><img src="/image/kafka_chapter07_06.png" alt=""></p>
<hr>
<p>카프카, 데이터 플랫폼의 최강자 &lt;고승범, 공용준&gt;</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-01-25T15:00:00.000Z" title="2020-01-25T15:00:00.000Z">2020-01-26</time><span class="level-item"><a class="link-muted" href="/categories/kafka/">Kafka</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/01/26/kafka-chapter8/">[카프카] 8장_카프카 스트림즈 API</a></h1><div class="content"><p>카프카 스트림즈 API 를 통해 스트림을 처리하는 방법을 정리한다.</p>
<h2 id="1-스트림-프로세싱-기초"><a href="#1-스트림-프로세싱-기초" class="headerlink" title="1. 스트림 프로세싱 기초"></a>1. 스트림 프로세싱 기초</h2><h4 id="1-1-스트림-프로세싱과-배치-프로세싱"><a href="#1-1-스트림-프로세싱과-배치-프로세싱" class="headerlink" title="1.1 스트림 프로세싱과 배치 프로세싱"></a>1.1 스트림 프로세싱과 배치 프로세싱</h4><p>오늘날 데이터 분석 시스템은 스트림 처리 시스템과 배치 처리 시스템을 모두 갖추어서 실시간과 정확성을 보장한다.</p>
<ol>
<li><p>스트림 프로세싱<br>데이터들이 지속적으로 유입되고 나가는 과정에서 데이터에 대한 분석이나 질의를 수행하는 것이다.<br>데이터가 분석 시스템이나 프로그램에 도달하자마자 처리를 해서 실시간 분석이라고도 한다.</p>
</li>
<li><p>배치 처리<br>이미 저장된 데이터를 기반으로 분석이나 질의를 수행하고 특정 시간에 처리하는 것이다.</p>
</li>
</ol>
<p>스티름 프로세싱의 장점은,</p>
<ol>
<li>이벤트 발생, 분석, 조치에 지연시간이 없기 때문에, <code>최신의 데이터</code>를 반영한다.</li>
<li>데이터 저장 후 분석을 하지 않으므로, 정적 분석보다 <code>더 많은 데이터를 분석</code>할 수 있다.</li>
<li>시간에 따라 <code>지속적으로 유입되는 데이터 분석에 최적화</code>되어 있다.</li>
<li>대규모 공유 데이터베이스에 대한 요구를 줄일 수 있어 <code>인프라에 독립적</code>으로 수행될 수 있다.</li>
</ol>
<h4 id="1-2-상태-기반-스트림-처리-무상태-스트림-처리"><a href="#1-2-상태-기반-스트림-처리-무상태-스트림-처리" class="headerlink" title="1.2 상태 기반 스트림 처리, 무상태 스트림 처리"></a>1.2 상태 기반 스트림 처리, 무상태 스트림 처리</h4><ol>
<li><p>상태 기반 스트림 처리<br><code>이전 스트림을 처리한 결과를 참조하는 방식</code>의 처리이다.<br>애플리케이션에서 각각의 이벤트를 처리하고 결과를 저장할 상태 저장소가 필요하다.</p>
</li>
<li><p>무상태 스트림 처리<br>이전 스트림의 처리 결과와 관계 없이, <code>현재 애플리케이션에 도달한 스트림만을 기준으로 처리</code>한다. </p>
</li>
</ol>
<h2 id="2-카프카-스트림즈"><a href="#2-카프카-스트림즈" class="headerlink" title="2. 카프카 스트림즈"></a>2. 카프카 스트림즈</h2><h4 id="2-1-카프카-스트림즈의-특징과-개념"><a href="#2-1-카프카-스트림즈의-특징과-개념" class="headerlink" title="2.1 카프카 스트림즈의 특징과 개념"></a>2.1 카프카 스트림즈의 특징과 개념</h4><p>카프카 스트림즈는 카프카에 저장된 데이터를 처리하고 분석하기 위해 개발된 클라이언트 라이브러리이다.<br>카프카 스트림즈의 특징은,</p>
<ol>
<li>간단하고 가벼운 클라이언트 라이브러리이다.</li>
<li>시스템이나 카프카에 대한 의존성이 없다.</li>
<li>이중화된 로컬 상태 저장소를 지원한다.</li>
<li>카프카 브로커나 클라이언트에 장애가 생겨도, 스트림에 대해선 1번만 처리되도록 보장한다.</li>
<li>한 번에 한 레코드만 처리한다.</li>
<li>고수준의 스트림 DSL 를 지원하고, 저수준의 프로세싱 API 도 제공한다.</li>
</ol>
<p>카프카 스트림즈는 <code>스트림 처리를 하는 프로세서들이 서로 연결되어 항상 Topology 를 만들어 처리하는 API</code> 이다.</p>
<p>다음 그림은 카프카 스트림즈 프로세스 토폴리지의 예이다.</p>
<p><img src="/image/kafka_chapter08_01.png" alt=""></p>
<p>프로세서 토폴리지 중에는 특별한 프로세서가 있다.</p>
<ol>
<li><p>소스 프로세서<br>위 쪽에 연결된 프로세서가 없는 프로세서이다.<br>하나 이상의 카프카 토픽에서 데이터 레코드를읽어 아래 쪽 프로세서에 전달한다.</p>
</li>
<li><p>싱크 프로세서<br>아래 쪽에 연결된 프로세서가 없는 프로세서이다.<br>상위 프로세서로부터. 받은 데이터 레코드를 특정 토픽에 저장한다.</p>
</li>
</ol>
<p>카프카 스트림즈는 이와같은 프로세서들을 만드는 2가지 방법을 제공한다.</p>
<ol>
<li><p>카프카 스트림즈 DSL 에서 데이터 처리를 할 때 공통적으로 필요한 데이터 프로세싱 메서드를 제공<br>ex) map, filter, join, aggregations</p>
</li>
<li><p>프로세서 API 를 제공해서 저수준의 처리를 직접할 수 있게 하는 것이다.</p>
</li>
</ol>
<h4 id="2-2-카프카-스트림즈-아키텍처"><a href="#2-2-카프카-스트림즈-아키텍처" class="headerlink" title="2.2 카프카 스트림즈 아키텍처"></a>2.2 카프카 스트림즈 아키텍처</h4><p>카프카 스트림즈에 들어오는 데이터는 카프카 토픽의 메세지이다.<br>카프카 토픽과 스트림의 관계는,</p>
<ol>
<li>각 스트림 파티션은 카프카의 토픽 파티션에 저장된 졍렬된 메세지이다.</li>
<li>스트림의 데이터 레코드는 카프카 해당 토픽의 메세지이다.</li>
<li>데이터 레코드의 키를 통해 다음 스트림으로 전달된다.</li>
</ol>
<p>카프카 스트림즈는 입력 스트림의  파티션 개수만큼 태스크를 생성한다.<br>각 태스크에는 입력 스트림, 즉 카프카 토픽 파티션들이 할당된다. 이것은 한번 정해지면 입력 토픽의 파티션이 변하지 않는한 변하지 않는다.<br>카프카 스트림즈는 사용자가 스레드의 개수를 지정할 수 있게 한다. 1개의 스레드는 1개 이상의 테스크를 처리할 수 있다. 다음 그림은 1개의 스레드에서 2개의 테스크가 수행되는 모습이다.</p>
<p><img src="/image/kafka_chapter08_02.png" alt=""></p>
<h2 id="3-파이프-예제-프로그램"><a href="#3-파이프-예제-프로그램" class="headerlink" title="3. 파이프 예제 프로그램"></a>3. 파이프 예제 프로그램</h2><p><img src="/image/kafka_chapter08_03.png" alt=""></p>
<p>단순히 한쪽 토픽에 입력된 값을 다른 쪽 토픽으로 옮기는 역할을 수행한다.</p>
<h2 id="4-행-분리-예제-프로그램"><a href="#4-행-분리-예제-프로그램" class="headerlink" title="4. 행 분리 예제 프로그램"></a>4. 행 분리 예제 프로그램</h2><p><img src="/image/kafka_chapter08_04.png" alt=""></p>
<p>한쪽 토픽에서 읽은 데이터를 공백 기준으로 분리해서 값으로 다른 토픽에 저장하는 역할을 수행한다.</p>
<h2 id="5-단어-빈도수-세기-예제-프로그램"><a href="#5-단어-빈도수-세기-예제-프로그램" class="headerlink" title="5. 단어 빈도수 세기 예제 프로그램"></a>5. 단어 빈도수 세기 예제 프로그램</h2><p><img src="/image/kafka_chapter08_05.png" alt=""></p>
<p>지금까지는 이전 데이터에 영향을 받지 않고, 스트림에 들어온 현재 데이터만을 처리하는 무상태 형태의 애플리케이션이었다.<br>이번에는 이전 스트림에서 처리한 단어의 빈도를 계산에 넣어서 현재까지의 총 단어 빈도를 구하는 상태 기반 형태의 애플리케이션이다.</p>
<hr>
<p>카프카, 데이터 플랫폼의 최강자 &lt;고승범, 공용준&gt;</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-01-19T15:00:00.000Z" title="2020-01-19T15:00:00.000Z">2020-01-20</time><span class="level-item"><a class="link-muted" href="/categories/oop/">OOP</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/01/20/object-chapter14/">[오브젝트] 14장_일관성 있는 협력</a></h1><div class="content"><h2 id="01-핸드폰-과금-시스템-변경하기"><a href="#01-핸드폰-과금-시스템-변경하기" class="headerlink" title="01 핸드폰 과금 시스템 변경하기"></a>01 핸드폰 과금 시스템 변경하기</h2><p><img src="/image/object_cowork_chapter14.png" alt=""></p>
<h5 id="기본-정책-확장"><a href="#기본-정책-확장" class="headerlink" title="기본 정책 확장"></a>기본 정책 확장</h5><ol>
<li><p>고정 요금 방식</p>
<p>ex ) 10초당 18원</p>
</li>
<li><p>시간대별 방식</p>
<p>ex ) 00시-19시 : 10초당 19월, 19시-24시 : 10초당 15원</p>
</li>
<li><p>요일별 방식</p>
<p>ex ) 평일 : 10초당 38원, 공휴일 : 10초당 19원</p>
</li>
<li><p>구간별 방식</p>
<p>ex) 초기 1분 : 10초당 50원, 초기 1분 이후 : 10초당 20원</p>
</li>
</ol>
<h5 id="고정-요금-방식-구현하기"><a href="#고정-요금-방식-구현하기" class="headerlink" title="고정 요금 방식 구현하기"></a>고정 요금 방식 구현하기</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FixedFeePolicy</span> <span class="keyword">extends</span> <span class="title">BasicRatePolicy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Money amount;</span><br><span class="line">    <span class="keyword">private</span> Duration duration;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FixedFeePolicy</span><span class="params">(Money amount, Duration duration)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.amount = amount;</span><br><span class="line">        <span class="keyword">this</span>.duration = duration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Money <span class="title">calculateCallFee</span><span class="params">(Call call)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> amount.times(call.getDuration().getSeconds() / seconds.getSeconds());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="시간대별-방식-구현하기"><a href="#시간대별-방식-구현하기" class="headerlink" title="시간대별 방식 구현하기"></a>시간대별 방식 구현하기</h5><p>TimeOfDayDiscountPolicy 클래스에서 가장 중요한 것은, 시간에 따라 서로 다른 요금 규칙을 정의하는 방법을 결정하는 것이다. </p>
<p>이를 위해 서로 다른 List 를 가질 수 있다. 같은 규칙에 포함된 요소들은 List 의 동일한 인덱스에 위치한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeOfDayDiscountPolicy</span> <span class="keyword">extends</span> <span class="title">BasicRatePolicy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;LocalTime&gt; starts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> List&lt;LocalTime&gt; ends = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> List&lt;LocalTime&gt; duration = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> List&lt;Money&gt; amounts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Money <span class="title">calculateCallFee</span><span class="params">(Call call)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="요일별-방식-구현하기"><a href="#요일별-방식-구현하기" class="headerlink" title="요일별 방식 구현하기"></a>요일별 방식 구현하기</h5><p>시간대별 방식의 4개 List 와 다르게, 규칙을 DayOfWeekDiscountRule 이라는 하나의 클래스로 구현해보자.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DayOfWeekDiscountRule</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;DayOfWeek&gt; dayOfWeeks = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Duration duration = Duration.ZERO;</span><br><span class="line">    <span class="keyword">private</span> Money amount = Money.ZERO;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DayOfDiscountRule</span><span class="params">(List&lt;DayOfWeek&gt; dayOfWeeks, Duration duration, Money amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dayOfWeeks = dayOfWeeks;</span><br><span class="line">        <span class="keyword">this</span>.duration = duration;</span><br><span class="line">        <span class="keyword">this</span>.amount = amount;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Money <span class="title">caculate</span><span class="params">(DateTimeInterval interval)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dayOfWeeks.contains(interval.getFrom().getDayOfWeek()))&#123;</span><br><span class="line">            <span class="keyword">return</span> ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DayOfWeekDiscountPolicy</span> <span class="keyword">extends</span> <span class="title">BasicRatePolicy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;DayOfWeekDiscountRule&gt; rules = <span class="keyword">new</span> ArrayList&lt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DayOfWeekDiscountPolicy</span><span class="params">(List&lt;DayOfWeekDiscountPolicy&gt; rules)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rules = rules;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Money <span class="title">calculateCallFee</span><span class="params">(Call call)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="구간별-방식-구현하기"><a href="#구간별-방식-구현하기" class="headerlink" title="구간별 방식 구현하기"></a>구간별 방식 구현하기</h5><p>(구간별 방식 구현 코드는 생략)</p>
<p>지금까지의 구현의 가장 큰 문제는, 이 클래스들이 <code>유사한 문제를 해결하고 있음에도 불구하고 설계에 일관성이 없다</code>는 것이다.</p>
<h2 id="02-설계에-일관성-부여하기"><a href="#02-설계에-일관성-부여하기" class="headerlink" title="02 설계에 일관성 부여하기"></a>02 설계에 일관성 부여하기</h2><p><code>협력을 일관성 있게</code> 만들기 위해서는,</p>
<ol>
<li>변하는 개념을 변하지 않는 개념으로 분리하라.</li>
<li>변하는 개념을 캡슐하하라.</li>
</ol>
<h5 id="조건-로직-객체-탐색"><a href="#조건-로직-객체-탐색" class="headerlink" title="조건 로직 객체 탐색"></a>조건 로직 객체 탐색</h5><p>4장의 절차적인 방식으로 구현했던 ReservationAgency 코드를 보자.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReservationAgency</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Reservation <span class="title">reservation</span><span class="params">(Screening screening, Customer customer, <span class="keyword">int</span> audienceCount)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(DiscountCondition condition : movie.getDiscountConditions()&#123;</span><br><span class="line">            <span class="keyword">if</span>(condition.getType() == DiscountCondition.PERIOD)&#123;</span><br><span class="line">                <span class="comment">//기간조건</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//회차 조건</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span>(discountable)&#123;</span><br><span class="line">            <span class="keyword">switch</span> (movie.getMovieType())&#123;</span><br><span class="line">                <span class="keyword">case</span> AMOUNT_DISCOUNT:</span><br><span class="line">                    <span class="comment">//금액할인 정책</span></span><br><span class="line">                <span class="keyword">case</span> PERCENT_DISCOUNT:</span><br><span class="line">                    <span class="comment">// 비율 할인 정책</span></span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>객체지향에서는, 변경을 다루는 전통적인 방법은 조건 로직을 객체 사이의 이동으로 바꾸는 것이다.</p>
<p><img src="/image/object_movie_chapter14.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Movie</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DiscountPolicy discountPolicy;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Money <span class="title">calculateMovieFee</span><span class="params">(Screening screening)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fee.minus(discountPolicy.calculateDiscountAmount(screening));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscountPolicy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;DiscountCondition&gt; conditions = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Money <span class="title">calculateDiscountAmount</span><span class="params">(Screening screening)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(DiscountCondition each : conditions)&#123;</span><br><span class="line">            <span class="keyword">if</span>(each.isSatisfiedBy(screening))&#123;</span><br><span class="line">                <span class="keyword">return</span> getDiscountAmount(screening);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> screening.getMovieFee();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>객체지향적인 코드는 조건을 판단하지 않는다. 단지 다음 객체로 이동할 뿐이다.</p>
<ol>
<li><p>Movie 는 현재의 할인 정책이 어떤 종류인지 판단하지 않는다. 단지 DiscountPolicy 로 향하는 참조를 통해 메세지를 전달할 뿐이다. </p>
</li>
<li><p>DiscountPolicy 역시 할인 조건의 종류를 판단하지 않는다. 단지 DiscountCondition 으로 향하는 참조를 통해 메세지를 전단할 뿐이다.</p>
</li>
</ol>
<p><code>협력을 일관성 있게</code> 만들기 위한 방법을 다시 정리하면,</p>
<ol>
<li><p>변하는 개념을 변하지 않는 개념으로 분리하라.</p>
<p>각 조건문을 개별적인 객체로 분리했고 이 객체들을 일관성 있게 협력하기 위해 타입 계층을 구성했다.</p>
</li>
<li><p>변하는 개념을 캡슐하하라.</p>
<p>Movie 가 알고 있는 사실은 협력하는 객체가 단지 DiscountPolicy 클래스의 인터페이스에 정의된 calculateDiscountAmount 메세지를 이해할 수 있다는 것 뿐이다. </p>
<p>메세지 수신자 타입은 Movie 에 대해 완벽히 캡슐화되었다.</p>
</li>
</ol>
<h5 id="캡슐화-다시-살펴보기"><a href="#캡슐화-다시-살펴보기" class="headerlink" title="캡슐화 다시 살펴보기"></a>캡슐화 다시 살펴보기</h5><p>캡슐화란 변하는 어떤 것이든 감추는 것이다.</p>
<p>다음 그림에는 다양한 종류의 캡슐화가 공존한다.</p>
<p><img src="/image/object_encapsulation_chapter14.png" alt=""></p>
<ol>
<li><p>데이터 캡슐화</p>
<p>클래스는 내부에 관리하는 데이터를 캡슐화한다.</p>
</li>
<li><p>메서드 캡슐화</p>
<p>DiscountPolicy 클래스에 정의된 getDiscountAmount 메서드의 가시성은 protected 이다.</p>
<p>즉, 클래스의 외부에서는 이 메서드에 접근하지 못하고 클래스 내부와 서브 클래스에서만 접근이 가능하다.</p>
</li>
<li><p>객체 캡슐화</p>
<p>Movie 클래스는 DiscountPolicy 타입의 인스턴스 변수를 포함한다. </p>
<p>이 인스턴스 변수는 private 가시성을 가지므로 Movie 와 DiscountPolicy 사이의 관계를 변경해도 외부에는 영향을 미치지 않는다.</p>
<p>즉, 합성이다.</p>
</li>
<li><p>서브타입 캡슐화</p>
<p>Movie 는 DiscountPolicy 에 대해서 알고 있지만, AmountDiscountPolicy 에 대해서는 모른다. </p>
<p>그러나 실행 시점에 협력할 수 있다.</p>
<p>서트타입의 종류를 캡슐화하고 있기 때문에, 다형성의 기반이 된다.</p>
</li>
</ol>
<h2 id="3-일관성-있는-기본-정책-구현하기"><a href="#3-일관성-있는-기본-정책-구현하기" class="headerlink" title="3 일관성 있는 기본 정책 구현하기"></a>3 일관성 있는 기본 정책 구현하기</h2><p>전체 설계는 다음과 같다.</p>
<p><img src="/image/object_all_chapter14.png" alt=""></p>
<h5 id="변경-분리하기"><a href="#변경-분리하기" class="headerlink" title="변경 분리하기"></a>변경 분리하기</h5><p>시간대별, 요일별, 구간별 방식의 공통점은 각 기본 정책을 구성하는 방식이 유사하는 것이다.</p>
<ol>
<li>기본 정책은 한 개 이상의 규칙으로 구성된다.</li>
<li>하나의 규칙은 적용 조건과 단위요금을 조합이다.</li>
</ol>
<p><img src="/image/object_rule_chapter14.png" alt=""></p>
<p>모든 규칙에 적용 조건이 포함된다는 사실은 변하지 않지만 실제 조건의 세부 내용은 다르다. </p>
<p>즉, 조건의 세부 내용이 바로 변화에 해당하는 것이다. </p>
<p>변하지 않는 ‘규칙’ 으로부터 변하는 ‘적용 조건’ 을 분리해야한다.</p>
<h5 id="변경-캡슐화하기"><a href="#변경-캡슐화하기" class="headerlink" title="변경 캡슐화하기"></a>변경 캡슐화하기</h5><p><img src="/image/object_fee_chapter14.png" alt=""></p>
<p>변하는 FeeCondition 의 서브 타입은 변하지 않는 FeeRule 로부터 캡슐화된다. </p>
<h5 id="협력-패턴-설계하기"><a href="#협력-패턴-설계하기" class="headerlink" title="협력 패턴 설계하기"></a>협력 패턴 설계하기</h5><p><img src="/image/object_basic_chapter14.png" alt=""></p>
<ol>
<li><p>BasicRatePolicy 의 calculateFee 메서드는 인자로 전달받은 통화 목록의 전체 요금을 계산한다.</p>
</li>
<li><p>BasicRatePolicy 는 목록에 포함된 각 Call 별로 FeeRule 의 calculateFee 메서드를 실행한다.</p>
</li>
<li><p>하나의 BasicRatePolicy 는 하나 이상의 FeeRule 로 구성되어서, Call 하나당 FeeRule 에 다수의 calculateFee 메세지가 전송된다.</p>
</li>
</ol>
<h5 id="추상화-수준에서-협력-패턴-구현하기"><a href="#추상화-수준에서-협력-패턴-구현하기" class="headerlink" title="추상화 수준에서 협력 패턴 구현하기"></a>추상화 수준에서 협력 패턴 구현하기</h5><p>변하지 않는 요소와 추상적인 요소만으로 요금 계산에 필요한 전체적인 협력 구조를 설명할 수 있다.</p>
<h5 id="구체적인-협력-구현하기"><a href="#구체적인-협력-구현하기" class="headerlink" title="구체적인 협력 구현하기"></a>구체적인 협력 구현하기</h5><p>code : 505 Page</p>
<p>유사한 기능에 대해 유사한 협력 패턴을 적용하는 것은 객체지향 시스템에서 개념적 무결성을 유지할 수 있는 방법이다. </p>
<p>개념적 무결성이란, 일관성이다.</p>
<hr>
<p>오브젝트 &lt;조영호&gt;</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-01-12T15:00:00.000Z" title="2020-01-12T15:00:00.000Z">2020-01-13</time><span class="level-item"><a class="link-muted" href="/categories/oop/">OOP</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/01/13/object-chapter13/">[오브젝트] 13장_서브클래싱과 서브타이핑</a></h1><div class="content"><p>상속의 두가지 용도는 다음과 같다.</p>
<ol>
<li><p>타입 계층 구현</p>
<p>동일한 메세지에 대해 서로 다르게 행동할 수 있는 다형적인 객체를 구현하기 위해서는 객체의 행동을 기반으로 타입 계층을 구성해야한다.</p>
</li>
<li><p>코드 재사용</p>
<p>부모 클래스와 자식 클래스가 강하게 결합되기 때문에 변경하기 어려운 코드를 얻게 된다.</p>
</li>
</ol>
<h2 id="01-타입"><a href="#01-타입" class="headerlink" title="01 타입"></a>01 타입</h2><p>타입을 세 가지 관점으로 정리하자.</p>
<h5 id="개념-관점의-타입"><a href="#개념-관점의-타입" class="headerlink" title="개념 관점의 타입"></a>개념 관점의 타입</h5><ol>
<li><p>타입</p>
<p>우리가 인지하는 세상의 사물의 종류를 의미한다.</p>
<p>자바, 루비, C 를 프로그래밍 언어로가 부를 때, 이것들을 프로그래밍 언어라는 타입으로 분류하고 있는 것이다.</p>
</li>
<li><p>인스턴스</p>
<p>어떤 대상이 타입으로 분류될 때 그 대상을 타입의 인스턴스라고 한다. </p>
<p>자바, 루비, C 는 프로그래밍 언어의 인스턴스이다.</p>
</li>
</ol>
<h5 id="프로그래밍-언어-관점의-타입"><a href="#프로그래밍-언어-관점의-타입" class="headerlink" title="프로그래밍 언어 관점의 타입"></a>프로그래밍 언어 관점의 타입</h5><p>하드웨어는 데이터를 0과 1로 구성된 일련의 비트 조합으로 취급한다. </p>
<p>프로그래밍 언어 관점의 타입은, 비트 묶음에 의미를 부여하기 위해 정의된 제약과 규칙을 의미한다.</p>
<p>타입은 두가지 목적으로 사용된다.</p>
<ol>
<li><p>타입에 수행될 수 있는 유효한 오퍼레이션의 집합을 정의한다.</p>
<p>자바의 ‘+’ 연산자는 원시형 숫자 타입이나 문자열 타입의 객체에는 사용할 수 있지만 다른 클래스의 인스턴스에 대해서는 사용할 수 없다.</p>
</li>
<li><p>타입에 수행되는 오퍼레이션에 대해 미리 약속된 문맥을 제공한다.</p>
<p>자바에서 a + b 라는 연산이 있을 때 a, b 의 타입이 int 라면 두 수를 더한다. a, b 의 타입이 String 이면 두 문자열을 하나의 문자열로 합친다.</p>
</li>
</ol>
<h5 id="객체-지향-패러다임-관점의-타입"><a href="#객체-지향-패러다임-관점의-타입" class="headerlink" title="객체 지향 패러다임 관점의 타입"></a>객체 지향 패러다임 관점의 타입</h5><p>프로그래밍 언어 관점에서 타입은 호출 가능한 오퍼레이션의 집합이다. </p>
<p>객체지향 프로그래밍에서 오퍼레이션은 객체가 수신할 수 있는 메세지이다. </p>
<p>객체지향 프로그래밍에서 타입을 정의하는 것은 객체가 수신할 수 있는 객체의 퍼블릭 인터페이스를 정의하는 것이다.</p>
<p>동일한 퍼블릭 인터페이스를 제공하는 객체들은 동일한 타입으로 분류된다. </p>
<h2 id="02-타입-계층"><a href="#02-타입-계층" class="headerlink" title="02 타입 계층"></a>02 타입 계층</h2><h5 id="타입-사이의-포함관계"><a href="#타입-사이의-포함관계" class="headerlink" title="타입 사이의 포함관계"></a>타입 사이의 포함관계</h5><p>타입 계층을 구성하는 두 타입 간의 관계에서,</p>
<ol>
<li><p>슈퍼타입</p>
<p>더 일반적인 타입</p>
</li>
<li><p>서브타입</p>
<p>더 특수한 타입</p>
</li>
</ol>
<h5 id="객체지향-프로그래밍과-타입-계층"><a href="#객체지향-프로그래밍과-타입-계층" class="headerlink" title="객체지향 프로그래밍과 타입 계층"></a>객체지향 프로그래밍과 타입 계층</h5><p>핵심은, 서브타입의 인스턴스는 슈퍼타입의 인스턴스로 간주 될 수 있다는 것이다.</p>
<p>퍼블릭 인터페이스의 관점에서,</p>
<ol>
<li><p>슈퍼타입</p>
<p>서브타입이 정의한 퍼블릭 인터페이스를 일반화시켜 상대적으로 범용적이고 넓은 의미로 정의한 것</p>
</li>
<li><p>서브타입</p>
<p>슈퍼타입이 정의한 퍼블릭 인터페이스를 특수화시켜 상대적으로 구체적이고 좁은 의미로 정의한 것</p>
</li>
</ol>
<h2 id="3-서브클래싱과-서브타이핑"><a href="#3-서브클래싱과-서브타이핑" class="headerlink" title="3 서브클래싱과 서브타이핑"></a>3 서브클래싱과 서브타이핑</h2><h5 id="언제-상속을-사용해야-하는가"><a href="#언제-상속을-사용해야-하는가" class="headerlink" title="언제 상속을 사용해야 하는가 ?"></a>언제 상속을 사용해야 하는가 ?</h5><p>다음 주 질문의 답이 ‘예’ 이면 상속을 사용해라.</p>
<ol>
<li>상속 관계가 is-a 관계를 모델링 하는가 ?</li>
<li>클라이언트 입장에서 부모 클래스의 타입으로 자식 클래스를 사용해도 되는가 ? (행동 호환성)</li>
</ol>
<h5 id="is-a-관계"><a href="#is-a-관계" class="headerlink" title="is-a 관계"></a>is-a 관계</h5><p>타입 S 가 타입 T 의 일종이라면 “타입 S 는 타입 T 다”</p>
<p>하지만 is-a 관계가 생각처럼 직관적이고 명쾌한 것은 아니다. 다음 예를 보자.</p>
<ol>
<li>팽귄은 새다.</li>
<li>새는 날 수 있다.</li>
</ol>
<p>이를 코드로 옮기면 다음과 같다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Penguin</span> <span class="keyword">extends</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>그런데, 팽귄은 새는 맞지만 날 수 없다. 위 코드에서는, 팽귄은 새이고 날 수 있다는 것을 주장한다.</p>
<p>이 예는, 어휘적인 정의가 아니라 기대되는 행동에 따라 타입 계층을 구성해야한다는 사실을 보여준다.</p>
<p>즉,<code>어떤 두 대상을 언어적으로 is-a 라고 표현할 수 있어도 일단은 상속을 사용할 예비 후보 정도로 생각</code>해야한다.</p>
<h5 id="행동-호환성"><a href="#행동-호환성" class="headerlink" title="행동 호환성"></a>행동 호환성</h5><p>두 타입 사이에 행동이 호환될 경우에만 타입 계층으로 묶어야 한다.</p>
<p>중요한 것은, <code>행동의 호환 여부를 판단하는 기준은 클라이언트의 관점</code>이다. 클라이언트가 두 타입이 동일하게 행동할 것이라고 기대하면 두 타입을 타입 계층으로 묶을 수 있다.</p>
<p>Penguin 이 Bird 의 서브 타입이 아닌 이유는, 클라이언트 입장에서 모든 새가 날 수 있다고 가정하기 때문이다.</p>
<p>다음과 같이 클라이언트가 날 수 있는 새만을 원한다고 해보자.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flyBird</span><span class="params">(Bird bird)</span></span>&#123;</span><br><span class="line">		bird.fly(); <span class="comment">// 인자로 전달된 모든 bird 는 날 수 있어야한다.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Penguin 은 날 수 없고 클라이언트 입장에서 모든 bird 가 날 수 있기를 기대하기 때문에 flyBird 의 메서드로 전달되어서는 안된다.</p>
<p>상속 관계를 유지하면서 문제를 해결하기 위해 시도할 수 있는 세가지 방법이 있다.</p>
<ol>
<li><p>Penguin 이 fly 메서드를 오버라이딩해서 내부 구현을 비워두는 것이다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Penguin</span> <span class="keyword">extends</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>하지만, 이 방법은 어떤 행동도 수행하지 않기 때문에 모든 bird 가 날 수 있다는 클라이언트의 기대를 만족하지 않는다. </p>
</li>
<li><p>Penguin 의 fly 메서드를 오버라이딩한 후 예외를 던지는 것이다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Penguin</span> <span class="keyword">extends</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>flyBird 메서드는 모든 bird 가 날 수 있다고 가정한다. </p>
<p>flyBird 메서드 fly 메시지를 전송한 결과로 UnsupportedOperationException 예외가 던져질 것이라고 기대하지 않을 것이다.</p>
</li>
<li><p>flyBird 메서드를 수정해서 인자로 전달된 bird 타입이 팽귄이 아닐 경우에만 fly 메세지를 전송하는 것이다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flyBird</span><span class="params">(Bird bird)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!(bird <span class="keyword">instanceof</span> Penguin))&#123;</span><br><span class="line">			bird.fly();    </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>만약 팽귄이 이외에 날 수 없는 또 다른 새가 상속 계층에 추가되면, flyBird 메서드 안에 새로운 타입을 체크하는 코드가 추가된다. 이것은 구체적인 클래스에 대한 결합도를 높여, 개방-폐쇄 원칙을 위반한다.</p>
</li>
</ol>
<h5 id="클라이언트의-기대에-따라-계층-분리하기"><a href="#클라이언트의-기대에-따라-계층-분리하기" class="headerlink" title="클라이언트의 기대에 따라 계층 분리하기"></a>클라이언트의 기대에 따라 계층 분리하기</h5><p>문제 해결을 위해서는, 위 세가지 방법 말고 클라이언트의 기대에 따라 계층을 분리해야한다.</p>
<p>날 수 있는 새와 날 수 없는 새를 명확하게 구분할 수 있게 상속 계층을 분리하면 서로 다른 요구사항을 가진 클라이언트를 만족 시킬 수 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line"> ...    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyingBird</span> <span class="keyword">extends</span> <span class="title">Bird</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Penguin</span> <span class="keyword">extends</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flyBird</span><span class="params">(FlyingBird bird)</span></span>&#123;</span><br><span class="line">		bird.fly();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>또 다른 방법으로는, 다음 그림과 같이 클라이언트에 따라 인터페이스를 분리하는 것이다.</p>
<p><img src="/image/object_subclass_interface.png" alt=""></p>
<p>더 좋은 방법은, 합성을 사용하는 것이다.</p>
<p><img src="/image/object_subclass_composition.png" alt=""></p>
<p>설계가 꼭 현실 세계를 반영할 필요는 없다. <code>자연어에 현혹되지 말고 요구사항 속에서 클라이언트가 기대하는 행동에 집중해라.</code></p>
<h5 id="서브클래싱과-서브타이핑"><a href="#서브클래싱과-서브타이핑" class="headerlink" title="서브클래싱과 서브타이핑"></a>서브클래싱과 서브타이핑</h5><p>상속을 사용하는 목적에 따라 다음과 같이 나눌 수 있다.</p>
<ol>
<li><p>서브클래싱</p>
<p>다른 클래스의 코드를 재사용할 목적으로 상속을 사용하는 경우이다.</p>
<p>구현상속, 클래스 상속이라고도 부른다. 왜냐하면, 내부 구현 자체를 상속하는 것에 초점을 맞추기 때문이다.</p>
</li>
<li><p>서브타이핑</p>
<p>타입 계층을 구성하기 위해 상속을 사용하는 것이다.</p>
<p>인터페이스 상속이라고도 부른다. 왜냐하면, 서브타입이 슈퍼타입의 퍼블릭 인터페이스를 상속하는 것 처럼 보이기 때문이다.</p>
</li>
</ol>
<h2 id="04-리스코프-치환-법칙"><a href="#04-리스코프-치환-법칙" class="headerlink" title="04 리스코프 치환 법칙"></a>04 리스코프 치환 법칙</h2><p>리스코프 치환 법칙이란, 클라이언트가 차이점을 인식하지 못한 채 파생 클래스의 인터페이스를 통해 서브 클래스를 사용할 수 있어야한다는 것이다.</p>
<p>10장의 Stack 과 Vector 는 리스코프 치환 법칙을 위반하는 전형적인 예이다. 클라이언트가 부모 클래스인 Vector 에 대해 기대하는 행동을 Stack 에 대해서는 기대할 수 없기 때문에 행동 호환성을 만족하지 못하기 때문이다.</p>
<p>다른 예로, “직사각형은 사격형이다 “ 가 있다. 하지만, 직사각형은 사각형이 아닐 수 있다.</p>
<p>다음은 사각형이다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x, y, width, height;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Rectangle</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">        <span class="keyword">this</span>.width = width;</span><br><span class="line">        <span class="keyword">this</span>.height = height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWidth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWidth</span><span class="params">(<span class="keyword">int</span> width)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.width = width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHeight</span><span class="params">(<span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.height = height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getArea</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> width * height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>다음은 정사각형이다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span>  <span class="keyword">extends</span> <span class="title">Rectangle</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Square</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(x, y, size, size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWidth</span><span class="params">(<span class="keyword">int</span> width)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setWidth(width);</span><br><span class="line">        <span class="keyword">super</span>.setHeight(width);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHeight</span><span class="params">(<span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setWidth(height);</span><br><span class="line">        <span class="keyword">super</span>.setHeight(height);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>문제는 다음과 같이, Rectangle 과 협력하는 클라이언트는 사각형의 너비와 높이가 다르다고 가정한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(Rectangle rectangle, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span>&#123;</span><br><span class="line">		rectangle.setWidth(width);</span><br><span class="line">		rectangle.setHeight(height);</span><br><span class="line">		<span class="keyword">assert</span> rectangle.getWidth() == width &amp;&amp; rectangle.getHeight() == height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>다음과 같이, 위 코드에서 resize 메서드 인자로 Rectangle 대신, Square 를 전달한다고 해보자. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Square square = <span class="keyword">new</span> Square(<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>);</span><br><span class="line">resize(square, <span class="number">50</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p>메서드의 실행이 실패하고 만다.</p>
<p>중요한 것은, 클라이언트 입장에서 행동이 호환되는지의 여부이다. 행동이 호환될 경우, 자신 클래스가 부모 클래스 대신 사용될 수 있다.</p>
<h5 id="클라이언트와-대체-가능성"><a href="#클라이언트와-대체-가능성" class="headerlink" title="클라이언트와 대체 가능성"></a>클라이언트와 대체 가능성</h5><p>Square 가 Rectangle 을 대체할 수 없는 이유는, 클라이언트 관점에서 Square와 Rectangle 이 다르기 때문이다.</p>
<p>대체 가능성을 결정하는 것은 클라이언트이다.</p>
<h5 id="is-a-관계-다시-살펴보기"><a href="#is-a-관계-다시-살펴보기" class="headerlink" title="is-a 관계 다시 살펴보기"></a>is-a 관계 다시 살펴보기</h5><p>상속이 서브타이핑을 위해 사용될 경우에만 is-a 관계이다. <code>서브 클래싱을 구현하기 위해 상속을 사용했다면 is-a 관계가 아니다.</code></p>
<h5 id="리스코프-치환-원칙은-유연한-설계의-기반이다"><a href="#리스코프-치환-원칙은-유연한-설계의-기반이다" class="headerlink" title="리스코프 치환 원칙은 유연한 설계의 기반이다."></a>리스코프 치환 원칙은 유연한 설계의 기반이다.</h5><p>클라이언트 입장에서, 퍼블릭 인터페이스의 행동방식이 변경되지 않는다면 클라이언트의 코드를 변경하지 않고도 새로운 자식 클래스와 협력할 수 있다.</p>
<p>8장에서 중복 할인 정책을 구현하기 위해 기존의 DiscountPolicy 상속 계층에 새로운 자식 클래스인 OverlappedDiscountPolicy 를 추가하더라도 클라이언트를 수정할 필요가 없었다.</p>
<p><img src="/image/object_subclass_chapter8.png" alt=""></p>
<p>위 설계는 다음 원칙을 조합한 유연할 설계이다.</p>
<ol>
<li><p>의존성 역전 원칙</p>
<p>상위 수준 모듈인 Movie 와 하위 수준 모듈인 OverlappedDiscountPolicy 모두 추상 클래스인 DiscountPolicy 에 의존한다.</p>
</li>
<li><p>리스코프 치환 원칙</p>
<p>OverlappedDiscountPolicy 는 클라이언트에 대한 영향 없이도 DiscountPolicy 를 대체할 수 있다.</p>
</li>
<li><p>개방-폐쇄 원칙</p>
<p>중복할인이라는 새로운 기능을 추가하기 위해 OverlappedDiscountPolicy 를 추가하더라도, Movie 에는 영향이 없다.</p>
</li>
</ol>
<h2 id="5-계약에-의한-설계와-서브타이핑"><a href="#5-계약에-의한-설계와-서브타이핑" class="headerlink" title="5. 계약에 의한 설계와 서브타이핑"></a>5. 계약에 의한 설계와 서브타이핑</h2><p>‘계약에 의한 설계’ 란, 클라이언트와 서버 사이의 협력을 의무와 이익으로 구성된 계약의 관점에서 표현하는 것이다.</p>
<p>서브타입이 리스코프 치환 원칙을 만족시키기 위해서는, 클라이언트와 슈퍼타입 간에 체결된 ‘계약’ 을 준수해야한다.</p>
<p>즉, 서브타입이 슈퍼타입처럼 보일 수 있는 유일한 방법은, 클라이언트가 슈퍼타입과 맺은 계약을 서브 타입이 준수하는 것이다.</p>
<hr>
<p>오브젝트 &lt;조영호&gt;</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-01-11T15:00:00.000Z" title="2020-01-11T15:00:00.000Z">2020-01-12</time><span class="level-item"><a class="link-muted" href="/categories/etc/">etc</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/01/12/review-2019/">2019년 회고</a></h1><div class="content"><h2 id="1-회사-업무"><a href="#1-회사-업무" class="headerlink" title="1. 회사 업무"></a>1. 회사 업무</h2><ol>
<li><p>Monthly Report</p>
<p>매월 대행사용 월간 리포트를 생성해서 제공한다.</p>
<p>보고서 생성 전체 파이프 라인을 단순화했다.</p>
<p>능동적으로 문제를 찾으려하지 않았다.</p>
</li>
<li><p>Report API</p>
<p>Node.js 기반 API 를  Java 기반으로 변경하는 작업이다. </p>
<p>팀 선임분이 대부분 작업을 했고, 나는 일부만 참여했다.</p>
<p>기존 코드에 대한 이해가 부족했다. 팀 선임분에게 의존도가 높았다.</p>
</li>
<li><p>Download Report</p>
<p>셀러가 필요할 때 리포트를  다운로드할 수 있는 서비스이다.</p>
<p>일정을 맞추지 못하였고, 초기 설계가 부족했다.</p>
<p>Java, Message Queue, Spark, Livy 를 배우기 좋았다.</p>
</li>
</ol>
<h2 id="2-외부-스터디"><a href="#2-외부-스터디" class="headerlink" title="2. 외부 스터디"></a>2. 외부 스터디</h2><ol>
<li><p>JPA</p>
<p>재밌게 공부하기는 했지만, 회사 업무에 당장 필요한 우선순위가 높은 주제는 아니었다.</p>
<p>상반기에 진행한 스터디였는데, JPA 스터디를 하기보다 회사 업무 파악에 집중할 필요가 있었다.</p>
</li>
<li><p>Spark</p>
<p>월간 리포트와 다운로드 리포트 작업에 필요한는 기술이기 때문에 스터디를 했다.</p>
<p>스터디하는 장소가 멀어서, 참여를 못하는 분들이 많아 원활히 스터디 진행이 안되었다.</p>
<p>스터디를 했지만 Spark 에 대한 이해도가 높아지지 않았다.</p>
<p>다시 공부할 필요가 있다.</p>
</li>
<li><p>Object</p>
<p>가장 재밌고 유익한 스터디였다.</p>
<p>다운로드 리포트를 리팩토링할 때 ‘객체지향’ 개념을 적용하려고 노력했다.</p>
</li>
</ol>
<h2 id="3-총평"><a href="#3-총평" class="headerlink" title="3. 총평"></a>3. 총평</h2><ol>
<li><p>광고 도메인 공부가 필요하다.</p>
</li>
<li><p>내 일뿐만 아니라, 다른 팀원이 하고 있는 일에도 관심을 갖고 협력해야한다.</p>
</li>
<li><p>일정 수립을 할 때는 충분히 여유롭게 해야한다.</p>
</li>
<li><p>개발 전에 설계가 충분히 잘 되어 있어야한다.</p>
</li>
<li><p>문서화를 해야한다.</p>
</li>
<li><p>공유를 해야한다.</p>
</li>
<li><p>스터디를 할 때는, 우선순위를 정하고 필요한 것부터 해야한다.</p>
</li>
</ol>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-01-05T15:00:00.000Z" title="2020-01-05T15:00:00.000Z">2020-01-06</time><span class="level-item"><a class="link-muted" href="/categories/oop/">OOP</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/01/06/object-chapter12/">[오브젝트] 12장_다형성</a></h1><div class="content"><p>상속의 진정한 목적은 코드 재사용이 아니라 <code>다형성을 위한 서브타입 계층을 구축</code> 하는 것이다.</p>
<p>상속의 관점에서 다형성이 구현되는 기술적인 메커니즘을 정리한다.</p>
<h2 id="01-다형성"><a href="#01-다형성" class="headerlink" title="01 다형성"></a>01 다형성</h2><p>다형성(Polymorphism) 은 다음 둘의 합성어이다. 즉, 많은 형태를 가질 수 있는 능력이다.</p>
<ul>
<li>ploy : 많은</li>
<li>morph : 형태</li>
</ul>
<p>다형성은 다음과 같이 분류될 수 있다. 이번장은 포함 다형성에 대해 다룬다.</p>
<ul>
<li><p>유니버셜 다형성 </p>
<ul>
<li><p>매개변수 다형성 </p>
<p>클래스의 인스턴스 변수나 메서드의 매개변수 타입을 임의의 타입으로 선언한 후 사용하는 시점에 구체적인 타입으로 지정하는 방식.</p>
<p> ex) List 인터페이스는 컬렉션에 보관할 요소의 타입을 임의의 타입 T로 지정하고 있으며 실제 인스턴스를 생성하는 시점에 T 를 구체적인 타입으로 지정</p>
</li>
<li><p>포함 다형성 (서브타입 다형성)</p>
<p>메세지가 동일해도 수신한 객체의 타입에 따라 실제로 수행되는 행동이 달라지는 능력.</p>
</li>
</ul>
</li>
<li><p>임시 다형성</p>
<ul>
<li><p>오버로딩 다형성</p>
<p>하나의 클래스 안에 동일한 이름의 메서드가 존재하는 경우.</p>
</li>
<li><p>강제 다형성</p>
<p>자동적인 타입 변환이나 사용자가 직접 구현한 타입 변환을 이용해 동일한 연산자를 다양한 타입에 사용할수 있는 방식.</p>
<p>ex) 이항 연산자인 ‘+’ 는 피연산자가 하나는 정수형이고 다른 하나는 문자열인 경우, 정수형 피연산자는 문자열 타입으로 강제 형변환</p>
</li>
</ul>
</li>
</ul>
<h2 id="02-상속의-양면성"><a href="#02-상속의-양면성" class="headerlink" title="02 상속의 양면성"></a>02 상속의 양면성</h2><ol>
<li><p>데이터 관점의 상속</p>
<p>부모 클래스에서 정의한 모든 데이터를 자식 클래스의 인스턴스에 자동으로 포함한다.</p>
</li>
<li><p>행동 관점의 상속</p>
<p>데이터뿐만 아니라 부모 클래스에서 정의한 일부 메서드 역시 자동으로 자식 클래스에 포함한다.</p>
<p>외부의 객체가 부모 클래스의 인스턴스에 전송할 수 있는 모든 메세지는 자식 클래스의 인스턴스에도 전송할 수 있다.</p>
</li>
</ol>
<h5 id="상속을-사용한-강의-평가"><a href="#상속을-사용한-강의-평가" class="headerlink" title="상속을 사용한 강의 평가"></a>상속을 사용한 강의 평가</h5><p>code : 394 p</p>
<ol>
<li><p>메서드 오버라이딩</p>
<p>자식 클래스 안에 상속 받은 메서드와 <code>동일한 시그니처의 메서드를 재정의</code>해서 부모 클래스의 구현을 새로운 구현으로 대체하는 것이다.</p>
</li>
<li><p>메서드 오버로딩</p>
<p>부모 클래스에서 정의한 <code>메서드와 이름은 동일하지만 시그니처는 다른</code> 메서드를 자식 클래스에 추가하는 것이다.</p>
</li>
</ol>
<h2 id="03-업캐스팅과-동적-바인딩"><a href="#03-업캐스팅과-동적-바인딩" class="headerlink" title="03 업캐스팅과 동적 바인딩"></a>03 업캐스팅과 동적 바인딩</h2><h5 id="같은-메세지-다른-메서드"><a href="#같은-메세지-다른-메서드" class="headerlink" title="같은 메세지, 다른 메서드"></a>같은 메세지, 다른 메서드</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Professor professor01 = <span class="keyword">new</span> Professor(<span class="string">"다익스트라"</span>, <span class="keyword">new</span> Lecture(...))</span><br><span class="line">Professor professor02 = <span class="keyword">new</span> Professor(<span class="string">"다익스트라"</span>, <span class="keyword">new</span> GradeLecture(...))</span><br><span class="line">  </span><br><span class="line">professor01.compileStatistics();</span><br><span class="line">professor02.compileStatistics();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">compileStatistics</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">	lecture.evalulate();</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>동일한 객체 참조인 lecture 에 대해 동일한 evaluate 메세지를 전송하는 동일한 코드 안에서, 서로 다른 클래스 안에 구현된 메서드를 실행할 수 있다.</p>
<p>이처럼, 코드 안에서 선언된 참조 타입과 무관하게 <code>실제로 메세지를 수신한 객체의 타입에 따라 실행되는 메서드가 달라질 수 있는 것</code>은 다음 두 메커니즘이 작용하기 때문이다.</p>
<ol>
<li><p>업캐스팅</p>
<p>부모 클래스 타입으로 선언된 변수에 자식 클래스의 인스턴스를 할당하는 것이 가능</p>
</li>
<li><p>동적 바인딩</p>
<p>메세지를 처리할 적절한 메서드를 컴파일 시점이 아니라 실행시점에 결정</p>
</li>
</ol>
<h5 id="업캐스팅"><a href="#업캐스팅" class="headerlink" title="업캐스팅"></a>업캐스팅</h5><p><img src="/image/object_polymorphism_upcasting.png" alt=""></p>
<p>업캐스팅의 대표적인 두 가지이다.</p>
<ol>
<li><p>대입문</p>
<p>명시적으로 타입을 변환하지 않고도 부모 클래스의 타입의 참조변수에 자식 클래스의 인스턴스를 대입할 수 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Lecture lecture = <span class="keyword">new</span> GradeLecture(...);</span><br></pre></td></tr></table></figure>
</li>
<li><p>메서드 파라미터</p>
<p>부모 클래스의 타입으로 선언된 파라미터에 자식 클래스의 인스턴스를 전달할 수 잇다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Professor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Professor</span><span class="params">(String name, Lecture lecture)</span></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Professor professor = <span class="keyword">new</span> Professor(<span class="string">"다익스트라"</span>, <span class="keyword">new</span> GradeLecture(...));</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>다운 캐스팅은, 부모 클래스의 인스턴스를 자식 클래스 타입으로 변환하기 위해 명시적인 타입 캐스팅이 필요하다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Lecture lecture = <span class="keyword">new</span> GradeLecture(...);</span><br><span class="line">GradeLecture gradeLecture = (GradeLecture) lecture;</span><br></pre></td></tr></table></figure>

<h5 id="동적-바인딩"><a href="#동적-바인딩" class="headerlink" title="동적 바인딩"></a>동적 바인딩</h5><ol>
<li><p>정적 바인딩</p>
<p>컴파일 타임에 호출할 함수를 결정하는 방식</p>
</li>
<li><p>동적 바인딩</p>
<p>실행될 메서드를 런타임에 결정하는 방식. </p>
<p>실행 시점에 어떤 클래스의 인스턴스를 생성해서 전달하는지 알아야만 실제로 실행될 메서드를 알 수 있다.</p>
</li>
</ol>
<h2 id="04-동적-메서드-탐색과-다형성"><a href="#04-동적-메서드-탐색과-다형성" class="headerlink" title="04 동적 메서드 탐색과 다형성"></a>04 동적 메서드 탐색과 다형성</h2><p>객체지향 시스템은 다음 규칙에 따라 실행할 메서드를 선택한다.</p>
<ol>
<li><p>메세지를 수신한 객체는 자신을 생성한 클래스에 적합한 메서드가 존재하는지 검사한다.</p>
<p>존재하면 메서드를 실행하고 탐색을 종료한다.</p>
</li>
<li><p>존재하지 않으면, 부모 클래스에서 메서드 탐색을 계속한다.</p>
<p>적합한 메서드를 찾을 때 까지 상속 계층을 따라 올라가며 계속된다.</p>
</li>
<li><p>상속 계층의 최상위 클르스에 올라갔지만 메서드를 발견하지 못하면 예외를 발생시키며 탐색을 종료한다.</p>
</li>
</ol>
<p>여기서 중요한 것이 sefl 참조 변수이다.</p>
<p>객체가 메세지를 수신하면, 컴파일러는 self 참조라는 임시 변수를 자동으로 생성해 메세지를 수신한 객체를 가리키도록 한다.</p>
<p><img src="/image/object_polymorphism_self.png" alt=""></p>
<p>위 그림에서, </p>
<ol>
<li>GradeLecture 클래스에서 적절한 메서드를 찾지 못했다면 </li>
<li>parent 참조를 따라 부모 클래스인 Lecture 클래스로 이동한후 탐색을 계속한다. </li>
<li>상속 계층을 따라 최상위 클래스인 Object 클래스에 이를 때 까지 탐색을 계속한다.  </li>
<li>최상위 클래스에서도 메서드를 찾지 못하면 에러를 발생시킨다.</li>
</ol>
<p>동적 메서드 탐색은 두 원리로 구성된다.</p>
<ol>
<li><p>자동적인 메세지 위임</p>
<p>자식 클래스는 이해할 수 없는 메세지를 전송 받으면 상속 계층을 따라 부모 클래스에 처리를 위임한다.</p>
</li>
<li><p>동적인 문맥</p>
<p>메세지를 수신했을 때, 실제로 어떤 메서드가 실행될지 결정하는 것은 컴파일 시점이 아니라 실행시점에 이뤄진다.</p>
</li>
</ol>
<h5 id="자동적인-메세지-위임"><a href="#자동적인-메세지-위임" class="headerlink" title="자동적인 메세지 위임"></a>자동적인 메세지 위임</h5><ol>
<li><p>메서드 오버라이딩 : 자식 클래스의 메서드가 부모 클래스의 메서드를 감추게 된다.</p>
<p><img src="/image/object_polymorphism_overriding.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Lecture lecture = <span class="keyword">new</span> Lecture(...);</span><br><span class="line">lecture.evaluate();</span><br></pre></td></tr></table></figure>

<p>위 그림과 위 코드에서, 메서드 탐색은 self 참조가 가리키는 객체의 클래스인 Lecuture 에서 시작한다.</p>
<p>Lecture 클래스 안에 evaluate 메서드가 존재하기 때문에, 메서드 실행한 후 탐색은 종료한다.</p>
<p><img src="/image/object_polymorphism_grade_lecture.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Lecture lecture = <span class="keyword">new</span> GradeLecture(...);</span><br><span class="line">lecture.evaluate();</span><br></pre></td></tr></table></figure>

<p>위 그림과 위 코드에서, Lecture 에 정의된 메서드가 아닌 실제 객체를 생성항 클래스인 GradeLecture 에 정의된 메서드가 실행된다. </p>
<p>self 참조가 가리키는 객체의 클래스인 GradeLecture 에서 탐색을 시작하고 GradeLecture 클래스 안에  evaluate 메서드가 구현되어 있기 때문이다.</p>
</li>
<li><p>메서드 오버로딩 :  자식 클래스의 메서드와 부모 클래스의 메서드가 공존한다.</p>
<p><img src="/image/object_polymorphism_overloading.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Lecture lecture = <span class="keyword">new</span> GradeLecture(...);</span><br><span class="line">lecture.average();</span><br></pre></td></tr></table></figure>

<p>위 그림과 위 코드에서, GradeLecture 클래스 안에서 메세지에 응답할 수 있는 적절한 메서드를 찾지 못한다.</p>
<p>그래서, 부모 클래스인 Lecture 클래스에서 메서드를 찾으려고 시도한다.</p>
</li>
</ol>
<h5 id="동적인-문맥"><a href="#동적인-문맥" class="headerlink" title="동적인 문맥"></a>동적인 문맥</h5><p>메세지를 수신한 객체가 무엇이냐에 따라 메서드 탐색을 위한 문맥이 동적으로 바뀐다. </p>
<p>이 동적인 문맥을 결정하는 것이 메세지를 수신한 객체를 가리키는 self 참조이다.</p>
<p>self 참조 가 동적 문맥을 결정한다는 것은, 종종 어떤 메서드가 실행될지 예상하기 어렵게 만든다. 대표적인 경우가 self 전송이다.</p>
<p>self 전송은 자식 클래스에서 부모 클래스 방향으로 진행되는 동적 메서드 탐색 경로를 <code>다시 self 참조가 가리키는 원래의 자식 클래스로 이동</code>시킨다. </p>
<p>다음을 보자.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lecture</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">stats</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getEvaluationMethod();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getEvaluationMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Pass or Fail"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GradeLecture</span> <span class="keyword">extends</span> <span class="title">Lecture</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getEvaluationMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Grade"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>GradeLecture 에 stats 메시지를 전송하면, 다음 그림과 같다.</p>
<p><img src="/image/object_polymorphism_self_send.png" alt=""></p>
<ol>
<li>self 참조는 GradeLecture 인스턴스를 가리키도록 설정되고 탐색은 GradeLecture 부터 시작.</li>
<li>GradeLecture 클래스에는 stats 메세지를 처리할 메서드가 없기 때문에 부모 클래스인 Lecture 에서 메서드 탐색을 계속속 하다가, Lecture 에서 stats 메서드를 발견하고 실행</li>
<li>실행 중에, self 참조가 가리키는 getEvaluationMethod 메세지를 전송하는 구문과 마주침</li>
<li>메서드 탐색은 self 참조가 가리키는 객체에서 다시 시작</li>
</ol>
<h5 id="이해할-수-없는-메세지"><a href="#이해할-수-없는-메세지" class="headerlink" title="이해할 수 없는 메세지"></a>이해할 수 없는 메세지</h5><p>이해할 수 없는 메세지 처리는 두 타입 언어에 따라 다르다.</p>
<ol>
<li><p>정적 타입 언어</p>
<p>코드를 컴파일 할 때 상속 계층 안의 클래스들이 메세지를 이해할 수 있는지 여부를 판단한다. </p>
<p>상속 계층 전체를 탐색한 후에도 메시지를 처리할 메서드를 발견하지 못하면 컴파일 에러가 발생한다. (안정적이다)</p>
</li>
<li><p>동적 타입 언어</p>
<p>실제로 코드 실행 전에는 메시지 처리 가능 여부를 판단 할 수 없다.</p>
<p>하지만, 이해할 수 없는 메세지에 대해 예외를던 는 것 외에도 doesNotUnderstand 나 method_missing 메시제에 응답 할 수 있는 메서드를 구현할 수 있다. (유연하다)</p>
</li>
</ol>
<h5 id="self-대-super"><a href="#self-대-super" class="headerlink" title="self 대 super"></a>self 대 super</h5><p><img src="/image/object_polymorphism_super.png" alt=""></p>
<p>super.average() 에 의해 호출되는 메서드는 부모 클래스의 메서드가 아니라, 더 상위에 위치한 조상 클래스의 메서드일 수 있다.</p>
<ol>
<li><p>self 전송</p>
<p>메세지를 수신한 객체의 클래스에 따라 메서드를 탐색할 시작 위치를 동적으로 결정</p>
</li>
<li><p>super 전송</p>
<p>항상 메세지를 전송하는 클래스의 부모 클래스에서부터 시작</p>
</li>
</ol>
<h2 id="5-상속-대-위임"><a href="#5-상속-대-위임" class="headerlink" title="5. 상속 대 위임"></a>5. 상속 대 위임</h2><p><img src="/image/object_polymorphism_same_self.png" alt=""></p>
<p>GradeLecture 인스턴스 입장에서 self 참조는, GradeLecture 인스턴스 자신이다.</p>
<p>GradeLecture 인스턴스에 포함된 Lecture 입장에서 self 참조는, GradeLecture 인스턴스이다. self 참조는 항상 메세지를 수신한 객체를 가리키기 때문이다.</p>
<p>즉, 상속 계층을 구성하는 객체들 사이에서는 self 참조를 공유하기 때문에 개념적으로 각 인스턴스에서 self 참조를 공유하는 self 변수를 포함하는 것처럼 표현할 수 있다.</p>
<p>상속은 동적으로 메서드를 탐샘하기 위해 현재의 실행문맥을 가지고 있는 self 참조를 전달한다. 그리고 이 객체들 사이에서는 메시지를 전달하는 과정이 자동으로 이뤄진다. 그래서, 자동적인 메세지 위임이라고 한다.</p>
<hr>
<p>오브젝트 &lt;조영호&gt;</p>
</div></article></div><nav class="pagination is-centered mt-4" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/page/5/">Previous</a></div><div class="pagination-next"><a href="/page/7/">Next</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/5/">5</a></li><li><a class="pagination-link is-current" href="/page/6/">6</a></li><li><a class="pagination-link" href="/page/7/">7</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/31/">31</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://www.gravatar.com/avatar/e6a876d587c47e3ce358b830fe131aae?s=128" alt="Junhee Ko"></figure><p class="title is-size-4 is-block line-height-inherit">Junhee Ko</p><p class="is-size-6 is-block">Always Learning</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Incheon</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">304</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">14</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">0</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/kojunhee" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/kojunhee"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://www.facebook.com/kojunheee/"><i class="fab fa-facebook"></i></a></div></div></div><!--!--><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/algorithm/"><span class="level-start"><span class="level-item">Algorithm</span></span><span class="level-end"><span class="level-item tag">180</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/big-data/"><span class="level-start"><span class="level-item">Big Data</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/boost-course/"><span class="level-start"><span class="level-item">Boost Course</span></span><span class="level-end"><span class="level-item tag">15</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/git/"><span class="level-start"><span class="level-item">Git</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/jpa/"><span class="level-start"><span class="level-item">JPA</span></span><span class="level-end"><span class="level-item tag">14</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/kafka/"><span class="level-start"><span class="level-item">Kafka</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/oop/"><span class="level-start"><span class="level-item">OOP</span></span><span class="level-end"><span class="level-item tag">18</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/os/"><span class="level-start"><span class="level-item">OS</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/spark/"><span class="level-start"><span class="level-item">Spark</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/spring/"><span class="level-start"><span class="level-item">Spring</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/tdd/"><span class="level-start"><span class="level-item">TDD</span></span><span class="level-end"><span class="level-item tag">32</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/test-code/"><span class="level-start"><span class="level-item">Test Code</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/etc/"><span class="level-start"><span class="level-item">etc</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">Recent</h3><article class="media"><div class="media-content size-small"><p><time dateTime="2020-07-21T15:00:00.000Z">2020-07-22</time></p><p class="title is-6"><a class="link-muted" href="/2020/07/22/spring-expert-ch-04/">[전문가를 위한 스프링 5] 4장_스프링 구성 상세와 스프링 부트</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/spring/">Spring</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-07-12T15:00:00.000Z">2020-07-13</time></p><p class="title is-6"><a class="link-muted" href="/2020/07/13/unit-test-ch-10/">[실용주의 단위 테스트] 13장_Mock</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/test-code/">Test Code</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-07-07T15:00:00.000Z">2020-07-08</time></p><p class="title is-6"><a class="link-muted" href="/2020/07/08/unit-test-ch-07/">[실용주의 단위 테스트] 7장_경계 조건</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/test-code/">Test Code</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-06-28T15:00:00.000Z">2020-06-29</time></p><p class="title is-6"><a class="link-muted" href="/2020/06/29/unit-test-ch-06/">[실용주의 단위 테스트] 6장_무엇을 테스트할 것인가?</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/test-code/">Test Code</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-06-27T15:00:00.000Z">2020-06-28</time></p><p class="title is-6"><a class="link-muted" href="/2020/06/28/logback/">Logback</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/spring/">Spring</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Advertisement</h3><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-6880109808178384" data-ad-slot="3347750970" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Always Learning" height="28"></a><p class="size-small"><span>&copy; 2020 junhee.ko</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'https://kojunhee.github.io',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to Top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>