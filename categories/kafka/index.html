
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="junhee.ko">
    <title>Category: Kafka - junhee.ko</title>
    <meta name="author" content="junhee.ko">
    
    
    
    <script type="application/ld+json">{}</script>
    <meta name="description" content="always learning">
<meta property="og:type" content="blog">
<meta property="og:title" content="junhee.ko">
<meta property="og:url" content="https://kojunhee.github.io/categories/kafka/index.html">
<meta property="og:site_name" content="junhee.ko">
<meta property="og:description" content="always learning">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="junhee.ko">
<meta name="twitter:description" content="always learning">
    
    
        
    
    
        <meta property="og:image" content="https://kojunhee.github.io/assets/images/profile.jpg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/all.css">
    <link rel="stylesheet" href="/assets/css/jquery.fancybox.css">
    <link rel="stylesheet" href="/assets/css/thumbs.css">
    <link rel="stylesheet" href="/assets/css/tranquilpeak.css">
    <!--STYLES END-->
    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="2">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a class="header-title-link" href="/ ">junhee.ko</a>
    </div>
    
        
            <a  class="header-right-picture "
                href="#about">
        
        
            <img class="header-picture" src="/assets/images/profile.jpg" alt="Author&#39;s picture"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="2">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a href="/#about">
                    <img class="sidebar-profile-picture" src="/assets/images/profile.jpg" alt="Author&#39;s picture"/>
                </a>
                <h4 class="sidebar-profile-name">junhee.ko</h4>
                
                    <h5 class="sidebar-profile-bio"><p>Always Learning</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/ "
                            
                            title="Home"
                        >
                    
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-categories"
                            
                            title="Categories"
                        >
                    
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-archives"
                            
                            title="Archives"
                        >
                    
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Archives</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://github.com/kojunhee" target="_blank" rel="noopener" title="GitHub">
                    
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://facebook.com/kojunheee" target="_blank" rel="noopener" title="Facebook">
                    
                        <i class="sidebar-button-icon fab fa-facebook" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Facebook</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://www.linkedin.com/in/junheeko" target="_blank" rel="noopener" title="LinkedIn">
                    
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="mailto:junheee.ko@gmail.com" target="_blank" rel="noopener" title="Mail">
                    
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="2"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2019/12/26/kafka-chapter3/">
                            [카프카] 3장_카프카 디자인
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-12-26T00:00:00+09:00">
	
		    Dec 26, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/kafka/">Kafka</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>대용량, 대규모 메세지 데이터를 빠르게 처리하도록 개발된 메시징 플랫폼이다.</p>
<h3 id="1-카프카-디자인의-특징"><a href="#1-카프카-디자인의-특징" class="headerlink" title="1. 카프카 디자인의 특징"></a>1. 카프카 디자인의 특징</h3><h4 id="1-1-분산-시스템"><a href="#1-1-분산-시스템" class="headerlink" title="1.1 분산 시스템"></a>1.1 분산 시스템</h4><p>분산 시스템이란, 같은 역할을 하는 여러 대의 서버로 이뤄진 서버 그룹이다.</p>
<p>장점은,</p>
<ol>
<li>단일 시스템 보다 높은 성능</li>
<li>하나의 서버가 장애가 발생해도 다른 서버가 대신 처리</li>
<li>시스템 확장 용이</li>
</ol>
<h4 id="1-2-페이지-캐시"><a href="#1-2-페이지-캐시" class="headerlink" title="1.2 페이지 캐시"></a>1.2 페이지 캐시</h4><p>OS 는 물리적 메모리에 애플리케이션이 사용하는 부분을 할당하고, 남은 잔여 메모리 일부를 페이지 케시로 이용한다. </p>
<p>즉, 디스크에 읽고 쓰기를 하지 않고 페이지 케시를 읽고 쓰는 방식으로 처리 속도가 빠르고 전체적인 성능을 향상 시킨다.</p>
<p>카프카는 이 특징을 이용해 디자인되었다.</p>
<h4 id="1-3-배치-전송-처리"><a href="#1-3-배치-전송-처리" class="headerlink" title="1.3 배치 전송 처리"></a>1.3 배치 전송 처리</h4><p>서버와 클라이언트 사이, 또는 서버 내부적으로 데이터를 주고 받는 과정에서 I/O 가 발한다. </p>
<p>작은 I/O 가 빈번하게 발생하는 것을 막기 위해, 작은 I/O 들을 묶어러 처리할 수 있도록 배치 작업으로 처리한다.</p>
<h3 id="2-카프카-데이터-모델"><a href="#2-카프카-데이터-모델" class="headerlink" title="2. 카프카 데이터 모델"></a>2. 카프카 데이터 모델</h3><h4 id="2-1-토픽"><a href="#2-1-토픽" class="headerlink" title="2.1 토픽"></a>2.1 토픽</h4><p>메세지를 받을 수 있도록 논리적으로 묶은 개념이다. 메일 주소라고 생각하면 쉽다.</p>
<h4 id="2-2-파티션"><a href="#2-2-파티션" class="headerlink" title="2.2 파티션"></a>2.2 파티션</h4><p>토픽을 분할한 것이다. </p>
<p><img src="/image/kafka_one_producer.png" alt></p>
<p>위 그림에서, ‘뉴스 토픽’ 으로 4 개의 메세지를 보내는데 4 초가 걸린다.</p>
<p><img src="/image/kafka_many_producer.png" alt></p>
<p>위 그림에서, ‘뉴스 토픽’ 으로 4 개의 메세지를 보내는데 1 초가 걸린다.</p>
<p>이렇게 빠른 전송을 위해서는, 토픽의 파티션 수와 프로듀서 수를 모두 늘려줘야한다.</p>
<blockquote>
<p>무조건 파티션 수를 늘려야 하나 ?</p>
</blockquote>
<p>파티션 수가 늘어나면 카프카에 좋지 않은 영향을 끼칠 수 있다.</p>
<ol>
<li><p>파일 핸들러의 낭비</p>
<p>각 파티션은 브로커의 디렉토리와 매핑되고, 저장되는 데이터는 2 개의 파일 ( 인덱스, 실제 데이터 ) 이 있다.</p>
<p>파티션이 많을 수록, 파일 핸들 수 역시 많아져 리소스가 낭비가 될 수 있다.</p>
</li>
<li><p>장애 복구 시간 증가</p>
</li>
</ol>
<blockquote>
<p>토픽의 적절한 파티션 수는 ?</p>
</blockquote>
<p>먼저, 원하는 목표 처리량의 기준을 정해야한다. </p>
<ol>
<li><p>프로듀서</p>
<p>4 개의 프로듀서가 초당 10 개의 메세지를 토픽으로 보내면, 토픽에서 초당 40 개의 메시지를 받아줘야한다.</p>
</li>
<li><p>토픽</p>
<p>해당 토픽에서 파티션을 1로 했을 때 초당 10개의 메세지만 받아준다면, 파티션 수를 4로 조정하면 목표치를 달성한다.</p>
</li>
<li><p>컨슈머</p>
<p>8 개의 컨슈머가 각각 초당 5 개의 메세지를 토픽에서 가져올 수 있으면, 토픽의 파티션수는 8개로 맞춰서 각 컨슈머마다 각각의 파티션에 접근하게 해줘야한다.</p>
</li>
</ol>
<p>주의할 점은, 파티션 수를 늘리는 것은 가능하지만 파티션 수을 줄이는 것은 불가능하다.</p>
<h4 id="2-3-오프셋과-메세지-순서"><a href="#2-3-오프셋과-메세지-순서" class="headerlink" title="2.3 오프셋과 메세지 순서"></a>2.3 오프셋과 메세지 순서</h4><p>오프셋이란, 각 파티션마다 메세지가 저장되는 위치이다. 파티션 내에서 유일한 숫자이고, 순차적으로 증가한다.</p>
<p>만약 컨슈머가 파티션 0 에서 데이터를 가져간다고 하면, 오프셋 0 1 2 3 4 5 순서대로 가져갈 수 있다. 절대로 오프셋 순서가 바뀐 상태로 가져갈 수 없다.</p>
<h3 id="3-고가용성과-리플리케이션"><a href="#3-고가용성과-리플리케이션" class="headerlink" title="3. 고가용성과 리플리케이션"></a>3. 고가용성과 리플리케이션</h3><p>토픽을 이루는 각각의 <code>파티션을</code> 리플리케이션 하는 것이다.</p>
<h4 id="3-1-리플리케이션-팩터와-리더-팔로워의-역할"><a href="#3-1-리플리케이션-팩터와-리더-팔로워의-역할" class="headerlink" title="3.1 리플리케이션 팩터와 리더, 팔로워의 역할"></a>3.1 리플리케이션 팩터와 리더, 팔로워의 역할</h4><p><img src="/image/kafka_reflecation.png" alt></p>
<p>모든 읽기와 쓰기는 리더를 통해서만 일어난다. 팔로워는 리더의 데이터를 그대로 리플리케이션만 한다.</p>
<p>리더와 팔로워는 저장된 데이터의 순서도 일치하고 동일한 오프셋과 메시지를 갖는다.</p>
<p>리플리케이션된 토픽의 서버가 다운되어도, 리더 변경으롤 문제 없이 프로듀서의 요청을 처리할 수 있다.</p>
<p>리플리케이션의 단점은,</p>
<ol>
<li><p>디스크 사용량 증가</p>
<p>토픽의 사이즈가 100 GB, 리플리케이션 팩터 3 이면, 카프카 클러스터 내 필요 저장소 크기는 300 GB 이다.</p>
</li>
<li><p>브로커 리소스 사용량 증가</p>
<p>브로커는 리플리케이션 보장을 위해, 비활성화된 토픽이 리플리케이션을 잘하고 있는지 비활성화된 토픽을 계속 체크한다. </p>
</li>
</ol>
<h4 id="3-2-리더와-팔로워의-관리"><a href="#3-2-리더와-팔로워의-관리" class="headerlink" title="3.2 리더와 팔로워의 관리"></a>3.2 리더와 팔로워의 관리</h4><p>팔로워에 문제가 있어서, 리더로부터 데이터를 가져오지 못하면 정합성이 맞지 않는다.</p>
<p>이를 해결하기 위해, ISR ( In Sync Replica ) 라는 개념이 있다. 현재 리플리케이션 되고 있는 리플리케이션 그룹이다.</p>
<p>ISR 에 속한 구성원만이 리더의 자격이 있다. </p>
<p>프로듀서 1, 브로커 3, 리플리케이션 팩터 3 일때, ISR 동작 순서는</p>
<ol>
<li>프로듀서가 메세지를 토픽의 리더에게 보낸다. </li>
<li>리더는 메세지를 저장한다.</li>
<li>팔로워는 매우 짧은 주기로 리더에 새로운 메세지가 저장된 것이 있는지 확인한다.</li>
<li>팔로워 1은 잘 동작하고 2는 잘 동작하지 않는다고 가정하자.</li>
<li>리더는 팔로워가 일정 주기 동안 확인 요청을 하지 않으면 그 팔로워를 ISR 그룹에서 추방한다.</li>
<li>리더는 팔로워 2를 ISR 그룹에서 추방한다.</li>
<li>팔로워 1은 리더에게 새로운 메세지가 있음을 확인하고 메세지를 가져가서 저장한다.</li>
</ol>
<h3 id="4-모든-브로커가-다운된다면"><a href="#4-모든-브로커가-다운된다면" class="headerlink" title="4. 모든 브로커가 다운된다면"></a>4. 모든 브로커가 다운된다면</h3><ol>
<li><p>마지막 리더가 살아나기를 기다린다.</p>
<p>마지막 리더에게 모든 메세지가 저장되어 있을 때, 나중에 다시 살아난다면 메세지 손실이 없다.</p>
<p>하지만 마지막 리더가 살아나지 않는 경우가 있을 수 있고, 결국 마지막 리더가 정상화 될때 까지 카프카 클러스터 장애가 길어진다.</p>
</li>
<li><p>ISR 에서 추방되었지만 먼저 살아나면 자동으로 리더가 된다.</p>
<p>메세지가 일부 손실되지만, 브로커 하나만이라도 정상화되어 서비스가 빠르게 정상화된다.</p>
</li>
</ol>
<p>다음 그림은, 토픽 / 파티션 / 리플리케이션 팩터 / 브로커 구성 예시이다.</p>
<p><img src="/image/kafka_example01.png" alt></p>
<p><img src="/image/kafka_example02.png" alt></p>
<hr>
<p>카프카, 데이터 플랫폼의 최강자 &lt;고승범, 공용준&gt;</p>

                    
                        

                    
                    
                        <p>
                            <a href="/2019/12/26/kafka-chapter3/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2019/12/26/kafka-chapter4/">
                            [카프카] 4장_카프카 프로듀서
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-12-26T00:00:00+09:00">
	
		    Dec 26, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/kafka/">Kafka</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>프로듀서란, 메세지를 생산해서 카프카의 토픽으로 보내는 역할을 하는 애플리케이션, 서버이다.</p>
<p>주요 기능은, 각각의 메세지를 토픽 파티션에 매핑하고 파티션의 리더에 요청을 보내는 것이다.</p>
<h3 id="1-콘솔-프로듀서로-메세지-보내기"><a href="#1-콘솔-프로듀서로-메세지-보내기" class="headerlink" title="1. 콘솔 프로듀서로 메세지 보내기"></a>1. 콘솔 프로듀서로 메세지 보내기</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto.create.topics.enable = <span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<p>위 처럼 설정되어 있으면, </p>
<p>프로듀서가 카프카에 존재하지 않는 토픽으로 메세지를 보낼 때 자동으로 토픽이 생성된다.</p>
<h3 id="2-자바와-파이썬을-이용한-프로듀서"><a href="#2-자바와-파이썬을-이용한-프로듀서" class="headerlink" title="2. 자바와 파이썬을 이용한 프로듀서"></a>2. 자바와 파이썬을 이용한 프로듀서</h3><p>프로듀서에서 send() 로 메세지를 보내는 방식은 세 가지이다.</p>
<ol>
<li><p>메세지 보내고 확인하지 않기</p>
<p>메세지 손실 가능성이 있다.</p>
</li>
<li><p>동기 전송</p>
<p>카프카의 응답을 기다린다.</p>
</li>
<li><p>비동기 전송</p>
<p>응답을 기다리지 않기 때문에 빠른 전송이 가능하다.</p>
</li>
</ol>
<h3 id="5-메세지-전송-방법"><a href="#5-메세지-전송-방법" class="headerlink" title="5. 메세지 전송 방법"></a>5. 메세지 전송 방법</h3><p>프로듀서 옵셩 중에 acks 옵션 설정에 따라, 카프카로 메세지를 전송할 때 메세지 손실 여부와 메세지 전송 속도 및 처리량이 달라진다.</p>
<h4 id="5-1-메세지-손실-가능성-높음-빠른-전송-속도"><a href="#5-1-메세지-손실-가능성-높음-빠른-전송-속도" class="headerlink" title="5.1 메세지 손실 가능성 높음, 빠른 전송 속도"></a>5.1 메세지 손실 가능성 높음, 빠른 전송 속도</h4><p>acks = 0, 카프카 서버의 응답을 기다리지 않고 메세지 보낼 준비가 되면 즉시 다음 요청을 보낸다.</p>
<h4 id="5-2-메세지-손실-가능성-낮음-적당한-전송-속도"><a href="#5-2-메세지-손실-가능성-낮음-적당한-전송-속도" class="headerlink" title="5.2 메세지 손실 가능성 낮음, 적당한 전송 속도"></a>5.2 메세지 손실 가능성 낮음, 적당한 전송 속도</h4><p><img src="/image/kafka_ack_1.png" alt></p>
<p>asks = 1, 메세지를 보내고 잘 받았는지 확인한다.</p>
<p>위 그림 처럼, 팔로워들이 주기적으로 리더를 확인하고 새로운 메세지가 확인되면 팔로워들에도 저장한다.</p>
<p>메세지 손실이 발생하는 경우는 리더에 장애가 발생하는 경우이다. 즉, </p>
<p>프로듀서가 리더에게 메세지를 보내고 리더는 메시지를 저장한 후에 바로 장애가 발생하는 경우이다.</p>
<h4 id="5-3-메세지-손실-없음-느린-전송-속도"><a href="#5-3-메세지-손실-없음-느린-전송-속도" class="headerlink" title="5.3 메세지 손실 없음, 느린 전송 속도"></a>5.3 메세지 손실 없음, 느린 전송 속도</h4><p>acks = all, 메세지를 보내고 잘 받았는지 확인하고 추가적으로 팔로워들까지 메세지를 잘 받았는지 확인한다.</p>
<p>프로듀서 설정 뿐만 아니라, 브로커 설정도 같이 해줘야한다.</p>
<blockquote>
<p>프로듀서 acks = all, 브로커 min.insync.replicas = 1 </p>
</blockquote>
<p>min.insync.replicas 는 최소 리플리케이션 팩터를 지정하는 옵션이다.</p>
<ol>
<li>프로듀서는 토픽의 리더에게 메세지를 보내고, </li>
<li>리더는 메세지를 저장한다. </li>
<li>최소 하나의 리플리케이션 조건을 갖췄기 때문에 acks 를 보낸다.</li>
</ol>
<blockquote>
<p>프로듀서 acks = all, 브로커 min.insync.replicas = 2</p>
</blockquote>
<ol>
<li>프로듀서는 토픽의 리더에게 메세지를 보내고, </li>
<li>리더는 메세지를 저장한다. </li>
<li>팔로워가 2 개가 있다고 할 때, 첫번째 팔로워는 리더로부터 주기적으로 새로운 메세지를 확인하며 새로운 메세지가 확인되면 자신도 리더의 메세지를 가져와 저장한다.</li>
<li>최소 두 개의 리플리케이션 조건을 갖췄기 때문에 acks 를 보낸다.</li>
</ol>
<p>“손실 없는 메세지 전송을 위해서는,  프로듀서 acks = all, 브로커 min.insync.replicas = 2, 리플레케이션 팩터 = 3”</p>
<blockquote>
<p>프로듀서 acks = all, 브로커 min.insync.replicas = 3</p>
</blockquote>
<p>왜 카프카는 손실 없는 메세지 전송을 위해, min.insync.replicas = 3 이 아니라, min.insync.replicas = 2 를 추천할까 ?</p>
<ol>
<li>프로듀서는 토픽의 리더에게 메세지를 보낸다.</li>
<li>팔로워가 2 개가 있다고 할 때, 팔로워가 위치한 브로커 하나를 강제 종료한다.</li>
<li>에러가 발생한다.</li>
<li>min.insync.replicas = 3 이기 때문에, 리더, 팔로워, 팔로워 이렇게 3 곳에서 모두 메세지를 받아야만 리더는 프로듀서에게 메세지를 잘 받았다는 acks 를 받을 수 있다. </li>
<li>하지만, 팔로워 한 개를 강제 종료하였기 때문에 ISR 에는 리더와 팔로워 각각 하나만 남아 있는 상태다.</li>
<li>결국 옵션의 조건을 충족시킬 수 없는 상황이기 때문에 에러가 발생한다.</li>
</ol>
<hr>
<p>카프카, 데이터 플랫폼의 최강자 &lt;고승범, 공용준&gt;</p>

                    
                        

                    
                    
                        <p>
                            <a href="/2019/12/26/kafka-chapter4/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2019/12/26/kafka-chapter1/">
                            [카프카] 1장_카프카란 무엇인가
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-12-26T00:00:00+09:00">
	
		    Dec 26, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/kafka/">Kafka</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>대용량, 대규모 메세지 데이터를 빠르게 처리하도록 개발된 메시징 플랫폼이다.</p>
<h3 id="1-탄생-배경"><a href="#1-탄생-배경" class="headerlink" title="1. 탄생 배경"></a>1. 탄생 배경</h3><p><img src="/image/kafka_end_to_end.png" alt></p>
<p>위 그림 처럼 end-to-end 아키텍쳐의 문제점은,</p>
<ol>
<li>실시간     트랜잭션 (OLTP) 처리와 비동기 처리가 동시에 이뤄지지만, 통합된 전송 영여이 없어서 복잡도 증가</li>
<li>데이터 파이프라인의 관리가 어려움</li>
</ol>
<p><img src="/image/kafka_architecture.png" alt></p>
<p>위 그림처럼 카프카는,</p>
<ol>
<li>모든 시스템으로 데이터 전송 가능 </li>
<li>실시간 처리 가능</li>
<li>확장이 용이</li>
</ol>
<h3 id="2-동작-방식과-원리"><a href="#2-동작-방식과-원리" class="headerlink" title="2. 동작 방식과 원리"></a>2. 동작 방식과 원리</h3><p>메시징 시스템을 먼저 살펴보자.</p>
<p>중앙에 메시징 시스템 서버를 두고 메시지를 Publish 하고 Subscribe 하는 형태의 통신을 Pub/Sub 모델이라고 한다.</p>
<p>프로듀서가 메시지를 컨슈머에게 직접 전달하는 것이 아니라, 중간의 메시징 시스템으로 전달한다. 그래서,</p>
<ol>
<li>프로듀서가 수신 불능 상태가 되어도 메세징 시스템이 살아있으면 메세지가 유실이 되지 않는다.</li>
<li>메세징 시스템을 중심으로 연결되기 때문에, 확장성이 용이하다.</li>
</ol>
<p>카프카의 메세지 전달 순서는,</p>
<ol>
<li>프로듀서가 메세지를 카프카에게 보낸다.</li>
<li>메세지가 Topic 에 도착해 저장된다.</li>
<li>컨슈머는 카프카 서버에 접속해 메세지를 가져간다. </li>
</ol>
<h3 id="3-특징"><a href="#3-특징" class="headerlink" title="3. 특징"></a>3. 특징</h3><ol>
<li><p>프로듀서와 컨슈머의 분리</p>
<p>어느 한쪽 시스템에서 문제가 발생해도 연쇄 작용이 발생할 확률이 낮다.</p>
<p>서버 추가에 대한 부담이 준다.</p>
</li>
<li><p>멀티 프로듀서, 멀티 컨슈머</p>
<p>데이터 분석 및 처리 프로세스에서 하나의 데이터를 다양한 용도로 사용하는 요구 사항을 충족할 수 있다.</p>
</li>
<li><p>디스크에 메세지 저장</p>
<p>컨슈머가 메세지를 읽어가도 보관 주기 동안 디스크에 메세지를 저장한다.</p>
<p>( 일반적인 메세지 시스템은 컨슈머가 메세지를 읽어가면 큐에서 바로 메세지 삭제 )</p>
</li>
<li><p>확장성</p>
<p>온라인 상태에서 확장 작업 가능</p>
</li>
<li><p>높은 성능</p>
</li>
</ol>
<hr>
<p>카프카, 데이터 플랫폼의 최강자 &lt;고승범, 공용준&gt;</p>

                    
                        

                    
                    
                        <p>
                            <a href="/2019/12/26/kafka-chapter1/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2019/12/26/kafka-chapter5/">
                            [카프카] 5장_카프카 컨슈머
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-12-26T00:00:00+09:00">
	
		    Dec 26, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/kafka/">Kafka</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>컨슈머란, 프로듀서가 메세지를 생산해서 카프카의 토픽으로 보내면 그 토픽의 메세지를 가져와 소비하는 애플리케이션, 서버이다.</p>
<p>주요 기능은, 특정 파티션을 관리하고 있는 파티션 리더에게 메세지를 가져오기 요청을 하는 것이다.</p>
<h3 id="2-콘솔-컨슈머로-메세지-가져오기"><a href="#2-콘솔-컨슈머로-메세지-가져오기" class="headerlink" title="2. 콘솔 컨슈머로 메세지 가져오기"></a>2. 콘솔 컨슈머로 메세지 가져오기</h3><p>컨슈머를 실행할 때는 항상 컨슈머 그룹이 필요하다. </p>
<p>만약 추가 옵션을 주지 않고 실행하면, 자동으로 다음 형태로 컨슈머 그룹이 생성된다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console-consumer-xxxx(숫자)</span><br></pre></td></tr></table></figure>

<h3 id="4-파티션과-메세지-순서"><a href="#4-파티션과-메세지-순서" class="headerlink" title="4. 파티션과 메세지 순서"></a>4. 파티션과 메세지 순서</h3><h4 id="4-1-파티션-3개로-구성한-토픽과-메세지-순서"><a href="#4-1-파티션-3개로-구성한-토픽과-메세지-순서" class="headerlink" title="4.1 파티션 3개로 구성한 토픽과 메세지 순서"></a>4.1 파티션 3개로 구성한 토픽과 메세지 순서</h4><p>프로듀서 다음 순서로 보낸다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">e</span><br></pre></td></tr></table></figure>

<p>컨슈머에서 –from-beginning 옵션으로 받는다. </p>
<p>메세지의 순서가 프로듀서가 보낸 순서가 아니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a</span><br><span class="line">d</span><br><span class="line">b</span><br><span class="line">e</span><br><span class="line">c</span><br></pre></td></tr></table></figure>

<p>다음으로, 프로듀서서가 숫자를 보낸다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure>

<p>컨슈머에서 –from-beginning 옵션으로 받는다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a</span><br><span class="line">d</span><br><span class="line">1</span><br><span class="line">4</span><br><span class="line">b</span><br><span class="line">e</span><br><span class="line">2</span><br><span class="line">5</span><br><span class="line">c</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<p>위 현상들은 정상이다.</p>
<p>–partition 0, –partition 1, –partition 3 로 각각 옵션을 주어서 컨슈머를 각각 실행해보면,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b</span><br><span class="line">e</span><br><span class="line">2</span><br><span class="line">5</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a</span><br><span class="line">d</span><br><span class="line">1</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<p><img src="/image/kafka_partition_message.png" alt></p>
<p>프로듀서가 메세지를 a b c d e 순서로 보냈지만, 해당 메세지들은 하나의 파티션에만 순서대로 저장되는 것이 아니라 각각의 파티션별로 메세지가 저장되었다. </p>
<p>컨슈머의 출력 내용은 각 파티션의 오프셋 순서대로 메세지를 가져온 것이다.</p>
<p>즉, </p>
<ol>
<li>카프카 컨슈머에서의 메세지 순서는 동일한 파티션 내에서는 프로듀서가 생성한 순서와 동일하게 처리하지만, </li>
<li>파티션과 파티션 사이에서는 순서를 보장하지 않는다.</li>
</ol>
<h4 id="4-2-파티션-1개로-구성한-토픽과-메세지-순서"><a href="#4-2-파티션-1개로-구성한-토픽과-메세지-순서" class="headerlink" title="4.2 파티션 1개로 구성한 토픽과 메세지 순서"></a>4.2 파티션 1개로 구성한 토픽과 메세지 순서</h4><p>메세지 순서를 정확하게 보장받기 위해서는 토픽 파티션 수를 1로 지정하면 된다.</p>
<p>단점은, </p>
<ol>
<li>분산해서 처리할 수 없고 </li>
<li>하나의 컨슈머에서만 처리할 수 있기 때문에 처리량이 낮다.</li>
</ol>
<h3 id="5-컨슈머-그룹"><a href="#5-컨슈머-그룹" class="headerlink" title="5. 컨슈머 그룹"></a>5. 컨슈머 그룹</h3><p>동일한 토픽에 대해 여러 컨슈머가 메세지를 가져갈 수 있도록 컨슈머 그룹이라는 기능을 제공한다. </p>
<p>이 방식은, 최근에 하나의 데이터를 다양한 용도로 사용하는 요구가 많아져서 좋다.</p>
<p><img src="/image/kafka_consumer_g01.png" alt></p>
<blockquote>
<p> 위 그림에서, 갑자기 프로듀서가 해당 토픽으로 많은 메세지를 전송한다고 가정해보자. </p>
</blockquote>
<p>프로듀서가 메세지를 보내는 속도가 컨슈머가 메세지를 가져가는 속도보다 빨라서, 컨슈머가 읽어가지 못하는 메세지들이 쌓인다.</p>
<p>그래서 다음과 같이 컨슈머를 확장한다.</p>
<p><img src="/image/kafka_consumer_g02.png" alt></p>
<p>컨슈머 그룹 안에서는 컨슈머들이 메세지를 가져오고 있는 토픽의 파티션에 대한 소유권을 공유한다. </p>
<p>파티션 1 의 소유권이 컨슈머 01 에서 02 로, 파티션 2 의 소유권이 컨슈머 01 에서 03 으로 이동했다.</p>
<p>이렇게 소유권이 이동하는 것을 <code>리밸런스</code> 라고 한다.</p>
<p>리밸런스의 단점은, 리밸런스 하는 동안 일시적으로 컨슈머는 메세지를 가져올 수 없다는 것이다.</p>
<blockquote>
<p>그런데, 이렇게 컨슈머를 추가했음에도 컨슈머가 가져가야하는 메세지가 쌓이면 어떻게 해야할까 ?</p>
</blockquote>
<p>컨슈머 04 를 추가해보자. 그대로다.</p>
<p>왜냐하면, 토픽의 파티션에는 하나의 컨슈머만 연결할 수 있기 때문이다. 각각의 파티션에 대해서는 메세지 순서를 보장하는데 두 개의 컨슈머가 하나의 파티션을 공유하면 안정적으로 메세지 순서를 보장할 수 없다.</p>
<p>그래서 파티션 수도 같이 늘려줘야한다.</p>
<blockquote>
<p> 컨슈머 그룹에서 컨슈머 04 가 다운되는 경우를 살펴보자.</p>
</blockquote>
<p>컨슈머가 컨슈머 그룹 안에서 멤버로 유지하고 할당된 파티션의 소유권을 유지하는 방법은 하트비트를 보내는 것이다. </p>
<p>만약, 커슈머가 오랫동안 하트비트를 보내지 않으면 세션은 타임아웃 되고 해당 커슈머가 다운되었다고 판단해서 리밸런스가 시작된다.</p>
<p>컨슈머 04 가 다운되면서 컨슈머 04 가 담당하던 파티션 3 을 컨슈머 03 이 이어받는다. </p>
<h3 id="6-커밋과-오프셋"><a href="#6-커밋과-오프셋" class="headerlink" title="6. 커밋과 오프셋"></a>6. 커밋과 오프셋</h3><p>컨슈머가 poll() 을 호출할 때마다 컨슈머 그룹은 카프카에 저장되어 있는 아직 읽지 않는 메세지를 가져온다. </p>
<p>이것이 가능한 이유는, 컨슈머 그룹이 어디까지 메세지를 가져갔는지 알 수 있기 때문이다.</p>
<p>컨슈머 그룹의 각각 컨슈머들은 각각의 파티션에 자신이 가져간 메세지의 위치 정보인 오프셋을 기록한다.</p>
<p>각 파티션에 대해 현재 위치를 업데이하는 것을 <code>커밋</code> 이라고 한다.</p>
<ol>
<li><p>올드 카프카 컨슈머 (0.9 이전 버젼)</p>
<p>오프셋 정보를 주키퍼에 저장</p>
</li>
<li><p>뉴 카프카 컨슈머 </p>
<p>내부에서 사용하는 토픽 (_consumer_offsets) 을 만들고 이 토픽에 오프셋 정보를 저장</p>
</li>
</ol>
<h4 id="6-1-자동-커밋"><a href="#6-1-자동-커밋" class="headerlink" title="6.1 자동 커밋"></a>6.1 자동 커밋</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enable.auto.commit = <span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<p>5초 마다 컨슈머가 poll() 을 호출할 때마다 가장 마지막 오프셋을 커밋한다. </p>
<p><img src="/image/kafka_auto_commit.png" alt></p>
<ol>
<li>컨슈머는 한 번의 poll() 로 메세지를 1, 2 를 가져온다.</li>
<li>5초가 되면서 마지막 오프셋 2 를 커밋한다.</li>
<li>메세지 3 과 4를 가져온다.</li>
<li>5초가 지나 오프셋 4를 커밋한다.</li>
</ol>
<h4 id="6-2-수동-커밋"><a href="#6-2-수동-커밋" class="headerlink" title="6.2 수동 커밋"></a>6.2 수동 커밋</h4><p>메세지 처리가 완료될 때까지 메세지를 가져온 것으로 간주되어서는 안되는 경우에 사용한다. </p>
<p>ex ) 메세지를 컨슈머가 가져오자마자 커밋하는 것이 아니라, 데이터베이스에 메세지를 저장한 후 커밋을 한다.</p>
<h4 id="6-3-특정-파티션-할당"><a href="#6-3-특정-파티션-할당" class="headerlink" title="6.3 특정 파티션 할당"></a>6.3 특정 파티션 할당</h4><p>수동으로 파티션을 할당해 메세지를 가져올 수 있다. </p>
<h4 id="6-4-특정-오프셋부터-메세지-가져오기"><a href="#6-4-특정-오프셋부터-메세지-가져오기" class="headerlink" title="6.4 특정 오프셋부터 메세지 가져오기"></a>6.4 특정 오프셋부터 메세지 가져오기</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">seek(파티션 번호, 오프셋 번호)</span><br></pre></td></tr></table></figure>

<hr>
<p>카프카, 데이터 플랫폼의 최강자 &lt;고승범, 공용준&gt;</p>

                    
                        

                    
                    
                        <p>
                            <a href="/2019/12/26/kafka-chapter5/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
        
        <li class="pagination-number">page 1 of 1</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2019 junhee.ko. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/profile.jpg" alt="Author&#39;s picture"/>
        
            <h4 id="about-card-name">junhee.ko</h4>
        
            <div id="about-card-bio"><p>Always Learning</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>Engineer</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                Incheon
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/jquery.js"></script>
<script src="/assets/js/jquery.fancybox.js"></script>
<script src="/assets/js/thumbs.js"></script>
<script src="/assets/js/tranquilpeak.js"></script>
<!--SCRIPTS END-->



    </body>
</html>
