<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  
  <title>junhee.ko</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="always learning">
<meta property="og:type" content="website">
<meta property="og:title" content="junhee.ko">
<meta property="og:url" content="https://kojunhee.github.io/index.html">
<meta property="og:site_name" content="junhee.ko">
<meta property="og:description" content="always learning">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="junhee.ko">
<meta name="twitter:description" content="always learning">
  
    <link rel="alternate" href="/atom.xml" title="junhee.ko" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">
  
  <link rel="stylesheet" href="/css/style.css">
  
    <link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">
  
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">junhee.ko</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">always learning</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://kojunhee.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-kafka-chapter8" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/01/26/kafka-chapter8/" class="article-date">
  <time class="dt-published" datetime="2020-01-25T15:00:00.000Z" itemprop="datePublished">2020-01-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/kafka/">Kafka</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/01/26/kafka-chapter8/">[카프카] 8장_카프카 스트림즈 API</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>카프카 스트림즈 API 를 통해 스트림을 처리하는 방법을 정리한다.</p>
<h2 id="1-스트림-프로세싱-기초"><a href="#1-스트림-프로세싱-기초" class="headerlink" title="1. 스트림 프로세싱 기초"></a>1. 스트림 프로세싱 기초</h2><p>####1.1 스트림 프로세싱과 배치 프로세싱</p>
<p>오늘날 데이터 분석 시스템은 스트림 처리 시스템과 배치 처리 시스템을 모두 갖추어서 실시간과 정확성을 보장한다.</p>
<ol>
<li><p>스트림 프로세싱</p>
<p>데이터들이 지속적으로 유입되고 나가는 과정에서 데이터에 대한 분석이나 질의를 수행하는 것이다.</p>
<p>데이터가 분석 시스템이나 프로그램에 도달하자마자 처리를 해서 실시간 분석이라고도 한다.</p>
</li>
<li><p>배치 처리</p>
<p>이미 저장된 데이터를 기반으로 분석이나 질의를 수행하고 특정 시간에 처리하는 것이다.</p>
</li>
</ol>
<p>스티름 프로세싱의 장점은,</p>
<ol>
<li>이벤트 발생, 분석, 조치에 지연시간이 없기때문에, 스트림 프로세싱을 통한 분석은 <code>최신의 데이터</code>를 반영한다.</li>
<li>데이터 저장 후 분석을 하지 않으므로, 정적 분석보다 <code>더 많은 데이터를 분석</code>할 수 있다.</li>
<li>시간에 따라 <code>지속적으로 유입되는 데이터 분석에 최적화</code>되어 있다.</li>
<li>대규모 공유 데이터베이스에 대한 요구를 줄일 수 있어 <code>인프라에 독립적</code>으로 수행될 수 있다.</li>
</ol>
<h4 id="1-2-상태-기반-스트림-처리-무상태-스트림-처리"><a href="#1-2-상태-기반-스트림-처리-무상태-스트림-처리" class="headerlink" title="1.2 상태 기반 스트림 처리, 무상태 스트림 처리"></a>1.2 상태 기반 스트림 처리, 무상태 스트림 처리</h4><ol>
<li><p>상태 기반 스트림 처리</p>
<p><code>이전 스트림을 처리한 결과를 참조하는 방식</code>의 처리이다.</p>
<p>애플리케이션에서 각각의 이벤트를 처리하고 결과를 저장할 상태 저장소가 필요하다.</p>
</li>
<li><p>무상태 스트림 처리</p>
<p>이전 스트림의 처리 결과와 관계 없이, <code>현재 애플리케이션에 도달한 스트림만을 기준으로 처리</code>한다. </p>
</li>
</ol>
<h2 id="2-카프카-스트림즈"><a href="#2-카프카-스트림즈" class="headerlink" title="2. 카프카 스트림즈"></a>2. 카프카 스트림즈</h2><h4 id="2-1-카프카-스트림즈의-특징과-개념"><a href="#2-1-카프카-스트림즈의-특징과-개념" class="headerlink" title="2.1 카프카 스트림즈의 특징과 개념"></a>2.1 카프카 스트림즈의 특징과 개념</h4><p>카프카 스트림즈는 카프카에 저장된 데이터를 처리하고 분석하기 위해 개발된 클라이언트 라이브러리이다.</p>
<p>카프카 스트림즈의 특징은,</p>
<ol>
<li>간단하고 가벼운 클라이언트 라이브러리이다.</li>
<li>시스템이나 카프카에 대한 의존성이 없다.</li>
<li>이중화된 로컬 상태 저장소를 지원한다.</li>
<li>카프카 브로커나 클라이언트에 장애가 생겨도, 스트림에 대해선 1번만 처리되도록 보장한다.</li>
<li>한 번에 한 레코드만 처리한다.</li>
<li>고수준의 스트림 DSL 를 지원하고, 저수준의 프로세싱 API 도 제공한다.</li>
</ol>
<p>카프카 스트림즈는 <code>스트림 처리를 하는 프로세서들이 서로 연결되어 항상 Topology 를 만들어 처리하는 API</code> 이다.</p>
<p>다음 그림은 카프카 스트림즈 프로세스 토폴리지의 예이다.</p>
<p><img src="/image/kafka_chapter08_01.png" alt></p>
<p>프로세서 토폴리지 중에는 특별한 프로세서가 있다.</p>
<ol>
<li><p>소스 프로세서</p>
<p>위 쪽에 연결된 프로세서가 없는 프로세서이다.<br>하나 이상의 카프카 토픽에서 데이터 레코드를읽어 아래 쪽 프로세서에 전달한다.</p>
</li>
<li><p>싱크 프로세서</p>
<p>아래 쪽에 연결된 프로세서가 없는 프로세서이다.<br>상위 프로세서로부터. 받은 데이터 레코드를 특정 토픽에 저장한다.</p>
</li>
</ol>
<p>카프카 스트림즈는 이와같은 프로세서들을 만드는 2가지 방법을 제공한다.</p>
<ol>
<li><p>카프카 스트림즈 DSL 에서 데이터 처리를 할 때 공통적으로 필요한 데이터 프로세싱 메서드를 제공</p>
<p>ex) map, filter, join, aggregations</p>
</li>
<li><p>프로세서 API 를 제공해서 저수준의 처리를 직접할 수 있게 하는 것이다.</p>
</li>
</ol>
<h4 id="2-2-카프카-스트림즈-아키텍처"><a href="#2-2-카프카-스트림즈-아키텍처" class="headerlink" title="2.2 카프카 스트림즈 아키텍처"></a>2.2 카프카 스트림즈 아키텍처</h4><p>카프카 스트림즈에 들어오는 데이터는 카프카 토픽의 메세지이다.</p>
<p>카프카 토픽과 스트림의 관계는,</p>
<ol>
<li>각 스트림 파티션은 카프카의 토픽 파티션에 저장된 졍렬된 메세지이다.</li>
<li>스트림의 데이터 레코드는 카프카 해당 토픽의 메세지이다.</li>
<li>데이터 레코드의 키를 통해 다음 스트림으로 전달된다.</li>
</ol>
<p>카프카 스트림즈는 입력 스트림의  파티션 개수만큼 태스크를 생성한다.</p>
<p>각 태스크에는 입력 스트림, 즉 카프카 토픽 파티션들이 할당된다. 이것은 한번 정해지면 입력 토픽의 파티션이 변하지 않는한 변하지 않는다.</p>
<p>카프카 스트림즈는 사용자가 스레드의 개수를 지정할 수 있게 한다. 1개의 스레드는 1개 이상의 테스크를 처리할 수 있다. 다음 그림은 1개의 스레드에서 2개의 테스크가 수행되는 모습이다.</p>
<p><img src="/image/kafka_chapter08_02.png" alt></p>
<h2 id="3-파이프-예제-프로그램"><a href="#3-파이프-예제-프로그램" class="headerlink" title="3. 파이프 예제 프로그램"></a>3. 파이프 예제 프로그램</h2><p><img src="/image/kafka_chapter08_03.png" alt></p>
<p>단순히 한쪽 토픽에 입력된 값을 다른 쪽 토픽으로 옮기는 역할을 수행한다.</p>
<h2 id="4-행-분리-예제-프로그램"><a href="#4-행-분리-예제-프로그램" class="headerlink" title="4. 행 분리 예제 프로그램"></a>4. 행 분리 예제 프로그램</h2><p><img src="/image/kafka_chapter08_04.png" alt></p>
<p>한쪽 토픽에서 읽은 데이터를 공백 기준으로 분리해서 값으로 다른 토픽에 저장하는 역할을 수행한다.</p>
<h2 id="5-단어-빈도수-세기-예제-프로그램"><a href="#5-단어-빈도수-세기-예제-프로그램" class="headerlink" title="5. 단어 빈도수 세기 예제 프로그램"></a>5. 단어 빈도수 세기 예제 프로그램</h2><p><img src="/image/kafka_chapter08_05.png" alt></p>
<p>지금까지는 이전 데이터에 영향을 받지 않고, 스트림에 들어온 현재 데이터만을 처리하는 무상태 형태의 애플리케이션이었다.</p>
<p>이번에는 이전 스트림에서 처리한 단어의 빈도를 계산에 넣어서 현재까지의 총 단어 빈도를 구하는 상태 기반 형태의 애플리케이션이다.</p>
<hr>
<p>카프카, 데이터 플랫폼의 최강자 &lt;고승범, 공용준&gt;</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kojunhee.github.io/2020/01/26/kafka-chapter8/" data-id="ck5qi9kip00mxga6wi5cb7358" data-title="[카프카] 8장_카프카 스트림즈 API" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-kafka-chapter7" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/01/26/kafka-chapter7/" class="article-date">
  <time class="dt-published" datetime="2020-01-25T15:00:00.000Z" itemprop="datePublished">2020-01-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/kafka/">Kafka</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/01/26/kafka-chapter7/">[카프카] 7장_데이터 파이프라인 구축</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>데이터 파이프라인을 직접 구성해본다. 다음 애플리케이션을 사용한다.</p>
<ol>
<li>아파치 나이파이</li>
<li>엘라스틱 파일비트</li>
<li>엘라스틱 엘라스틱서치</li>
<li>엘라스틱 키바나</li>
</ol>
<h2 id="1-카프카를-활용한-데이터-흐름도"><a href="#1-카프카를-활용한-데이터-흐름도" class="headerlink" title="1. 카프카를 활용한 데이터 흐름도"></a>1. 카프카를 활용한 데이터 흐름도</h2><p><img src="/image/kafka_chapter07_01.png" alt></p>
<p>카프카에서 발생하는 로그를 이용해 데이터 흐름도를 구성해본다.</p>
<p>아파치 나이파이는 데이터 처리 흐름을 정의하고, 정의된 흐름대로 자동으로 실행해주는 애플리케이션이다.</p>
<ol>
<li>데이터 흐름을 처리하기 위한 워크플로우</li>
<li>데이터 처리</li>
</ol>
<h2 id="2-파일-비트를-이용한-메세지-전송"><a href="#2-파일-비트를-이용한-메세지-전송" class="headerlink" title="2. 파일 비트를 이용한 메세지 전송"></a>2. 파일 비트를 이용한 메세지 전송</h2><p>카프카의 로그를 카프카의 토픽으로 전송하려면 프로듀서가 필요하다. 프로듀서는,</p>
<ol>
<li>카프카 클라이언트 라이브러리를 이용해 프로그램으로 직접 구현</li>
<li>오픈소스 애플리케이션 이용. 여기서는 파일 비트.</li>
</ol>
<h2 id="3-나이파이를-이용해-메세지-가져오기"><a href="#3-나이파이를-이용해-메세지-가져오기" class="headerlink" title="3. 나이파이를 이용해 메세지 가져오기"></a>3. 나이파이를 이용해 메세지 가져오기</h2><p>이제 컨슈머를 이용해 카프카 토픽으로부터 메세지를 가져와와야한다. 컨슈머는,</p>
<ol>
<li>프로그래밍 언어로 직접 구현</li>
<li>오픈소스 애플리케이션 이용. 여기서는 나이파이.</li>
</ol>
<h4 id="3-1-나이파이를-이용한-컨슈머-설정"><a href="#3-1-나이파이를-이용한-컨슈머-설정" class="headerlink" title="3.1 나이파이를 이용한 컨슈머 설정"></a>3.1 나이파이를 이용한 컨슈머 설정</h4><p><img src="/image/kafka_chapter07_02.png" alt></p>
<p>프로세서를 추가하는 화면이다.</p>
<p>프로세서는 나이파이에서 데이터 처리를 위한 각각의 컴포넌트이다. AMQP 컨슘, 파일로 저장, 전송하기 등 여러가지 작업이 가능하다.</p>
<p>ConsumeKafka 프로세서를 추가하고 재생 버튼을 누르면, 설정한 브로커의 토픽에서 메세지를 가져오기 시작한다.</p>
<p>컨슈머가 잘 동작하는지 확인하는 방법은,</p>
<ol>
<li><p>나이파이에서 컨슈머 프로세서를 실행 시킨 후,</p>
</li>
<li><p>카프카 컨슈머 그룹 리스트에서, 등록한 컨슈머 그룹이 잘 등록되었는지 확인한다.</p>
<p>등록한 컨슈머 그룹 : ConsumeKafka 프로세서의 Properties 를 정의할 때 그룹 ID 를 기입했음.</p>
</li>
</ol>
<h2 id="4-실시간-분석을-위해-엘라스틱서치에-메세지-저장"><a href="#4-실시간-분석을-위해-엘라스틱서치에-메세지-저장" class="headerlink" title="4. 실시간 분석을 위해 엘라스틱서치에 메세지 저장"></a>4. 실시간 분석을 위해 엘라스틱서치에 메세지 저장</h2><p>이제, 가져온 메세지들을 나이파이의 또 다른 프로세서를 이용해 엘라스틱서치에 저장하겠다.</p>
<p>엘라스틱서치는 엘라스틱 사의 분산형 RESTFul 검색 및 분석 엔진이다. 전문 검색 질의를 이용해 원하는 데이터 분석을 빠르게 할 수 있는 애플리케이션이다.</p>
<h4 id="4-1-나이파이를-이용해-엘라스틱서치로-데이터-전송"><a href="#4-1-나이파이를-이용해-엘라스틱서치로-데이터-전송" class="headerlink" title="4.1 나이파이를 이용해 엘라스틱서치로 데이터 전송"></a>4.1 나이파이를 이용해 엘라스틱서치로 데이터 전송</h4><p>PutElasticsearchHttp 프로세서를 추가한다. 데이터를 엘라스틱서치로 넣어주는 역할을 한다.</p>
<p>그리고 다음 화면처럼, ConsumeKafka 와 연결한다.</p>
<p><img src="/image/kafka_chapter07_03.png" alt></p>
<p>데이터 흐름 중에 뒤에 있는 프로세서에서 처리 속도가 느려 바로 처리하지 못하거나 프로세서에 문제가 발생한 경우, 두 프로세스를 연결하는 큐에 레코드가 쌓인다.</p>
<h2 id="5-키바나를-이용해-엘라스틱서치에-저장된-데이터-확인"><a href="#5-키바나를-이용해-엘라스틱서치에-저장된-데이터-확인" class="headerlink" title="5. 키바나를 이용해 엘라스틱서치에 저장된 데이터 확인"></a>5. 키바나를 이용해 엘라스틱서치에 저장된 데이터 확인</h2><p>웹브라우저를 이용해 원하는 시간대에 발생한 로그들을 확인할 수 있고, 필터 기능으로 원하는 패턴의 로그만 빠르게 검색 가능하다.</p>
<p>각 브로커에서 수집되는 로그가 카프카의 토픽에 있기 때문에, 엘라스틱 서치에 전송하는 것 외에 추가로 하둡이나 로컬에 저장하길 원하면, 다음 화면처럼 나이파이의 PutHDFS 프로세서를 추가해 쉽게 하둡 등의 저장소에 저장할 수 있다.</p>
<p><img src="/image/kafka_chapter07_04.png" alt></p>
<h2 id="6-현재의-토픽을-이용해-새로운-토픽으로-메세지-재생산"><a href="#6-현재의-토픽을-이용해-새로운-토픽으로-메세지-재생산" class="headerlink" title="6. 현재의 토픽을 이용해 새로운 토픽으로 메세지 재생산"></a>6. 현재의 토픽을 이용해 새로운 토픽으로 메세지 재생산</h2><p><img src="/image/kafka_chapter07_05.png" alt></p>
<p>이번에는, 메세지의 양이 굉장히 많은 토픽의 내용 중 필요한 메세지만 꺼내서 다시 새로운 토픽으로 메세지를 보내는 방법을 정리한다.</p>
<p>전체적인 데이터 흐름은,</p>
<ol>
<li>나이파이 컨슈머가 peter-log 로부터 로그 메세지를 가져오면서 호스트 이름을 확인한다.</li>
<li>peter-log 토픽으로 로그 메세지를 보내는 서버는 peter-kafka001,peter-kafka002, peter-kafka003 모두 3대이다.</li>
<li>각각의 메세지마다 호스트 이름이 peter-kafka001,ppeter-kafka002, ppeter-kafka003 이 기록되어 있다.</li>
<li>전체 메세지 중에 호스트 이름이 peter-kafka001메세지만 peter-kafka001토픽으로 다시 전송하고,</li>
<li>나머지 메세지는 peter-failure 토픽으로 전송한다.</li>
</ol>
<h4 id="6-1-나이파이를-이용한-토픽별-라우팅"><a href="#6-1-나이파이를-이용한-토픽별-라우팅" class="headerlink" title="6.1 나이파이를 이용한 토픽별 라우팅"></a>6.1 나이파이를 이용한 토픽별 라우팅</h4><p>나이파이에서 토픽의 메세지를 가져와서 peter-kafka001 에서 온 메세지인지 확인한 후에 peter-kafka001 토픽으로 전송해야한다. </p>
<p>이를 위해, 나이파이의 EvaluateJsonPath, RouteOnAttribute 프로세서를 추가해서 라우팅 작업을 한다.</p>
<ol>
<li><p>EvaluateJsonPath 프로서는, 토픽으로 전송된 JSON 의 beat.hostname 을 읽어 호스트 이름을 구분한다.</p>
</li>
<li><p>RouteOnAttribute 프로세서는, attrubute 를 이용해 라우팅을 한다.</p>
</li>
</ol>
<p>마지막으로, 카프카 프로듀서 2개를 추가한다.</p>
<ol>
<li>호스트명이 peter-kafka001 인 메세지를  peter-kafka001 토픽으로 전송할 프로듀서</li>
<li>그 외 메세지를  peter-failure 토픽으로 전송할 프로듀서</li>
</ol>
<p>최종 플로우는 다음과 같다.</p>
<p><img src="/image/kafka_chapter07_06.png" alt></p>
<hr>
<p>카프카, 데이터 플랫폼의 최강자 &lt;고승범, 공용준&gt;</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kojunhee.github.io/2020/01/26/kafka-chapter7/" data-id="ck5qi9kio00mwga6we7jz0il7" data-title="[카프카] 7장_데이터 파이프라인 구축" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-object-chapter14" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/01/20/object-chapter14/" class="article-date">
  <time class="dt-published" datetime="2020-01-19T15:00:00.000Z" itemprop="datePublished">2020-01-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/object/">Object</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/01/20/object-chapter14/">[오브젝트] 14장_일관성 있는 협력</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="01-핸드폰-과금-시스템-변경하기"><a href="#01-핸드폰-과금-시스템-변경하기" class="headerlink" title="01 핸드폰 과금 시스템 변경하기"></a>01 핸드폰 과금 시스템 변경하기</h2><p><img src="/image/object_cowork_chapter14.png" alt></p>
<h5 id="기본-정책-확장"><a href="#기본-정책-확장" class="headerlink" title="기본 정책 확장"></a>기본 정책 확장</h5><ol>
<li><p>고정 요금 방식</p>
<p>ex ) 10초당 18원</p>
</li>
<li><p>시간대별 방식</p>
<p>ex ) 00시-19시 : 10초당 19월, 19시-24시 : 10초당 15원</p>
</li>
<li><p>요일별 방식</p>
<p>ex ) 평일 : 10초당 38원, 공휴일 : 10초당 19원</p>
</li>
<li><p>구간별 방식</p>
<p>ex) 초기 1분 : 10초당 50원, 초기 1분 이후 : 10초당 20원</p>
</li>
</ol>
<h5 id="고정-요금-방식-구현하기"><a href="#고정-요금-방식-구현하기" class="headerlink" title="고정 요금 방식 구현하기"></a>고정 요금 방식 구현하기</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FixedFeePolicy</span> <span class="keyword">extends</span> <span class="title">BasicRatePolicy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Money amount;</span><br><span class="line">    <span class="keyword">private</span> Duration duration;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FixedFeePolicy</span><span class="params">(Money amount, Duration duration)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.amount = amount;</span><br><span class="line">        <span class="keyword">this</span>.duration = duration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Money <span class="title">calculateCallFee</span><span class="params">(Call call)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> amount.times(call.getDuration().getSeconds() / seconds.getSeconds());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="시간대별-방식-구현하기"><a href="#시간대별-방식-구현하기" class="headerlink" title="시간대별 방식 구현하기"></a>시간대별 방식 구현하기</h5><p>TimeOfDayDiscountPolicy 클래스에서 가장 중요한 것은, 시간에 따라 서로 다른 요금 규칙을 정의하는 방법을 결정하는 것이다. </p>
<p>이를 위해 서로 다른 List 를 가질 수 있다. 같은 규칙에 포함된 요소들은 List 의 동일한 인덱스에 위치한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeOfDayDiscountPolicy</span> <span class="keyword">extends</span> <span class="title">BasicRatePolicy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;LocalTime&gt; starts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> List&lt;LocalTime&gt; ends = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> List&lt;LocalTime&gt; duration = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> List&lt;Money&gt; amounts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Money <span class="title">calculateCallFee</span><span class="params">(Call call)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="요일별-방식-구현하기"><a href="#요일별-방식-구현하기" class="headerlink" title="요일별 방식 구현하기"></a>요일별 방식 구현하기</h5><p>시간대별 방식의 4개 List 와 다르게, 규칙을 DayOfWeekDiscountRule 이라는 하나의 클래스로 구현해보자.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DayOfWeekDiscountRule</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;DayOfWeek&gt; dayOfWeeks = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Duration duration = Duration.ZERO;</span><br><span class="line">    <span class="keyword">private</span> Money amount = Money.ZERO;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DayOfDiscountRule</span><span class="params">(List&lt;DayOfWeek&gt; dayOfWeeks, Duration duration, Money amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dayOfWeeks = dayOfWeeks;</span><br><span class="line">        <span class="keyword">this</span>.duration = duration;</span><br><span class="line">        <span class="keyword">this</span>.amount = amount;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Money <span class="title">caculate</span><span class="params">(DateTimeInterval interval)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dayOfWeeks.contains(interval.getFrom().getDayOfWeek()))&#123;</span><br><span class="line">            <span class="keyword">return</span> ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DayOfWeekDiscountPolicy</span> <span class="keyword">extends</span> <span class="title">BasicRatePolicy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;DayOfWeekDiscountRule&gt; rules = <span class="keyword">new</span> ArrayList&lt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DayOfWeekDiscountPolicy</span><span class="params">(List&lt;DayOfWeekDiscountPolicy&gt; rules)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rules = rules;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Money <span class="title">calculateCallFee</span><span class="params">(Call call)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="구간별-방식-구현하기"><a href="#구간별-방식-구현하기" class="headerlink" title="구간별 방식 구현하기"></a>구간별 방식 구현하기</h5><p>(구간별 방식 구현 코드는 생략)</p>
<p>지금까지의 구현의 가장 큰 문제는, 이 클래스들이 <code>유사한 문제를 해결하고 있음에도 불구하고 설계에 일관성이 없다</code>는 것이다.</p>
<h2 id="02-설계에-일관성-부여하기"><a href="#02-설계에-일관성-부여하기" class="headerlink" title="02 설계에 일관성 부여하기"></a>02 설계에 일관성 부여하기</h2><p><code>협력을 일관성 있게</code> 만들기 위해서는,</p>
<ol>
<li>변하는 개념을 변하지 않는 개념으로 분리하라.</li>
<li>변하는 개념을 캡슐하하라.</li>
</ol>
<h5 id="조건-로직-객체-탐색"><a href="#조건-로직-객체-탐색" class="headerlink" title="조건 로직 객체 탐색"></a>조건 로직 객체 탐색</h5><p>4장의 절차적인 방식으로 구현했던 ReservationAgency 코드를 보자.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReservationAgency</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Reservation <span class="title">reservation</span><span class="params">(Screening screening, Customer customer, <span class="keyword">int</span> audienceCount)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(DiscountCondition condition : movie.getDiscountConditions()&#123;</span><br><span class="line">            <span class="keyword">if</span>(condition.getType() == DiscountCondition.PERIOD)&#123;</span><br><span class="line">                <span class="comment">//기간조건</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//회차 조건</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span>(discountable)&#123;</span><br><span class="line">            <span class="keyword">switch</span> (movie.getMovieType())&#123;</span><br><span class="line">                <span class="keyword">case</span> AMOUNT_DISCOUNT:</span><br><span class="line">                    <span class="comment">//금액할인 정책</span></span><br><span class="line">                <span class="keyword">case</span> PERCENT_DISCOUNT:</span><br><span class="line">                    <span class="comment">// 비율 할인 정책</span></span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>객체지향에서는, 변경을 다루는 전통적인 방법은 조건 로직을 객체 사이의 이동으로 바꾸는 것이다.</p>
<p><img src="/image/object_movie_chapter14.png" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Movie</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DiscountPolicy discountPolicy;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Money <span class="title">calculateMovieFee</span><span class="params">(Screening screening)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fee.minus(discountPolicy.calculateDiscountAmount(screening));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscountPolicy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;DiscountCondition&gt; conditions = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Money <span class="title">calculateDiscountAmount</span><span class="params">(Screening screening)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(DiscountCondition each : conditions)&#123;</span><br><span class="line">            <span class="keyword">if</span>(each.isSatisfiedBy(screening))&#123;</span><br><span class="line">                <span class="keyword">return</span> getDiscountAmount(screening);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> screening.getMovieFee();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>객체지향적인 코드는 조건을 판단하지 않는다. 단지 다음 객체로 이동할 뿐이다.</p>
<ol>
<li><p>Movie 는 현재의 할인 정책이 어떤 종류인지 판단하지 않는다. 단지 DiscountPolicy 로 향하는 참조를 통해 메세지를 전달할 뿐이다. </p>
</li>
<li><p>DiscountPolicy 역시 할인 조건의 종류를 판단하지 않는다. 단지 DiscountCondition 으로 향하는 참조를 통해 메세지를 전단할 뿐이다.</p>
</li>
</ol>
<p><code>협력을 일관성 있게</code> 만들기 위한 방법을 다시 정리하면,</p>
<ol>
<li><p>변하는 개념을 변하지 않는 개념으로 분리하라.</p>
<p>각 조건문을 개별적인 객체로 분리했고 이 객체들을 일관성 있게 협력하기 위해 타입 계층을 구성했다.</p>
</li>
<li><p>변하는 개념을 캡슐하하라.</p>
<p>Movie 가 알고 있는 사실은 협력하는 객체가 단지 DiscountPolicy 클래스의 인터페이스에 정의된 calculateDiscountAmount 메세지를 이해할 수 있다는 것 뿐이다. </p>
<p>메세지 수신자 타입은 Movie 에 대해 완벽히 캡슐화되었다.</p>
</li>
</ol>
<h5 id="캡슐화-다시-살펴보기"><a href="#캡슐화-다시-살펴보기" class="headerlink" title="캡슐화 다시 살펴보기"></a>캡슐화 다시 살펴보기</h5><p>캡슐화란 변하는 어떤 것이든 감추는 것이다.</p>
<p>다음 그림에는 다양한 종류의 캡슐화가 공존한다.</p>
<p><img src="/image/object_encapsulation_chapter14.png" alt></p>
<ol>
<li><p>데이터 캡슐화</p>
<p>클래스는 내부에 관리하는 데이터를 캡슐화한다.</p>
</li>
<li><p>메서드 캡슐화</p>
<p>DiscountPolicy 클래스에 정의된 getDiscountAmount 메서드의 가시성은 protected 이다.</p>
<p>즉, 클래스의 외부에서는 이 메서드에 접근하지 못하고 클래스 내부와 서브 클래스에서만 접근이 가능하다.</p>
</li>
<li><p>객체 캡슐화</p>
<p>Movie 클래스는 DiscountPolicy 타입의 인스턴스 변수를 포함한다. </p>
<p>이 인스턴스 변수는 private 가시성을 가지므로 Movie 와 DiscountPolicy 사이의 관계를 변경해도 외부에는 영향을 미치지 않는다.</p>
<p>즉, 합성이다.</p>
</li>
<li><p>서브타입 캡슐화</p>
<p>Movie 는 DiscountPolicy 에 대해서 알고 있지만, AmountDiscountPolicy 에 대해서는 모른다. </p>
<p>그러나 실행 시점에 협력할 수 있다.</p>
<p>서트타입의 종류를 캡슐화하고 있기 때문에, 다형성의 기반이 된다.</p>
</li>
</ol>
<h2 id="3-일관성-있는-기본-정책-구현하기"><a href="#3-일관성-있는-기본-정책-구현하기" class="headerlink" title="3 일관성 있는 기본 정책 구현하기"></a>3 일관성 있는 기본 정책 구현하기</h2><p>전체 설계는 다음과 같다.</p>
<p><img src="/image/object_all_chapter14.png" alt></p>
<h5 id="변경-분리하기"><a href="#변경-분리하기" class="headerlink" title="변경 분리하기"></a>변경 분리하기</h5><p>시간대별, 요일별, 구간별 방식의 공통점은 각 기본 정책을 구성하는 방식이 유사하는 것이다.</p>
<ol>
<li>기본 정책은 한 개 이상의 규칙으로 구성된다.</li>
<li>하나의 규칙은 적용 조건과 단위요금을 조합이다.</li>
</ol>
<p><img src="/image/object_rule_chapter14.png" alt></p>
<p>모든 규칙에 적용 조건이 포함된다는 사실은 변하지 않지만 실제 조건의 세부 내용은 다르다. </p>
<p>즉, 조건의 세부 내용이 바로 변화에 해당하는 것이다. </p>
<p>변하지 않는 ‘규칙’ 으로부터 변하는 ‘적용 조건’ 을 분리해야한다.</p>
<h5 id="변경-캡슐화하기"><a href="#변경-캡슐화하기" class="headerlink" title="변경 캡슐화하기"></a>변경 캡슐화하기</h5><p><img src="/image/object_fee_chapter14.png" alt></p>
<p>변하는 FeeCondition 의 서브 타입은 변하지 않는 FeeRule 로부터 캡슐화된다. </p>
<h5 id="협력-패턴-설계하기"><a href="#협력-패턴-설계하기" class="headerlink" title="협력 패턴 설계하기"></a>협력 패턴 설계하기</h5><p><img src="/image/object_basic_chapter14.png" alt></p>
<ol>
<li><p>BasicRatePolicy 의 calculateFee 메서드는 인자로 전달받은 통화 목록의 전체 요금을 계산한다.</p>
</li>
<li><p>BasicRatePolicy 는 목록에 포함된 각 Call 별로 FeeRule 의 calculateFee 메서드를 실행한다.</p>
</li>
<li><p>하나의 BasicRatePolicy 는 하나 이상의 FeeRule 로 구성되어서, Call 하나당 FeeRule 에 다수의 calculateFee 메세지가 전송된다.</p>
</li>
</ol>
<h5 id="추상화-수준에서-협력-패턴-구현하기"><a href="#추상화-수준에서-협력-패턴-구현하기" class="headerlink" title="추상화 수준에서 협력 패턴 구현하기"></a>추상화 수준에서 협력 패턴 구현하기</h5><p>변하지 않는 요소와 추상적인 요소만으로 요금 계산에 필요한 전체적인 협력 구조를 설명할 수 있다.</p>
<h5 id="구체적인-협력-구현하기"><a href="#구체적인-협력-구현하기" class="headerlink" title="구체적인 협력 구현하기"></a>구체적인 협력 구현하기</h5><p>code : 505 Page</p>
<p>유사한 기능에 대해 유사한 협력 패턴을 적용하는 것은 객체지향 시스템에서 개념적 무결성을 유지할 수 있는 방법이다. </p>
<p>개념적 무결성이란, 일관성이다.</p>
<hr>
<p>오브젝트 &lt;조영호&gt;</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kojunhee.github.io/2020/01/20/object-chapter14/" data-id="ck5qi9kk000ooga6wggbtf5tt" data-title="[오브젝트] 14장_일관성 있는 협력" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-object-chapter13" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/01/13/object-chapter13/" class="article-date">
  <time class="dt-published" datetime="2020-01-12T15:00:00.000Z" itemprop="datePublished">2020-01-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/object/">Object</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/01/13/object-chapter13/">[오브젝트] 13장_서브클래싱과 서브타이핑</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>상속의 두가지 용도는 다음과 같다.</p>
<ol>
<li><p>타입 계층 구현</p>
<p>동일한 메세지에 대해 서로 다르게 행동할 수 있는 다형적인 객체를 구현하기 위해서는 객체의 행동을 기반으로 타입 계층을 구성해야한다.</p>
</li>
<li><p>코드 재사용</p>
<p>부모 클래스와 자식 클래스가 강하게 결합되기 때문에 변경하기 어려운 코드를 얻게 된다.</p>
</li>
</ol>
<h2 id="01-타입"><a href="#01-타입" class="headerlink" title="01 타입"></a>01 타입</h2><p>타입을 세 가지 관점으로 정리하자.</p>
<h5 id="개념-관점의-타입"><a href="#개념-관점의-타입" class="headerlink" title="개념 관점의 타입"></a>개념 관점의 타입</h5><ol>
<li><p>타입</p>
<p>우리가 인지하는 세상의 사물의 종류를 의미한다.</p>
<p>자바, 루비, C 를 프로그래밍 언어로가 부를 때, 이것들을 프로그래밍 언어라는 타입으로 분류하고 있는 것이다.</p>
</li>
<li><p>인스턴스</p>
<p>어떤 대상이 타입으로 분류될 때 그 대상을 타입의 인스턴스라고 한다. </p>
<p>자바, 루비, C 는 프로그래밍 언어의 인스턴스이다.</p>
</li>
</ol>
<h5 id="프로그래밍-언어-관점의-타입"><a href="#프로그래밍-언어-관점의-타입" class="headerlink" title="프로그래밍 언어 관점의 타입"></a>프로그래밍 언어 관점의 타입</h5><p>하드웨어는 데이터를 0과 1로 구성된 일련의 비트 조합으로 취급한다. </p>
<p>프로그래밍 언어 관점의 타입은, 비트 묶음에 의미를 부여하기 위해 정의된 제약과 규칙을 의미한다.</p>
<p>타입은 두가지 목적으로 사용된다.</p>
<ol>
<li><p>타입에 수행될 수 있는 유효한 오퍼레이션의 집합을 정의한다.</p>
<p>자바의 ‘+’ 연산자는 원시형 숫자 타입이나 문자열 타입의 객체에는 사용할 수 있지만 다른 클래스의 인스턴스에 대해서는 사용할 수 없다.</p>
</li>
<li><p>타입에 수행되는 오퍼레이션에 대해 미리 약속된 문맥을 제공한다.</p>
<p>자바에서 a + b 라는 연산이 있을 때 a, b 의 타입이 int 라면 두 수를 더한다. a, b 의 타입이 String 이면 두 문자열을 하나의 문자열로 합친다.</p>
</li>
</ol>
<h5 id="객체-지향-패러다임-관점의-타입"><a href="#객체-지향-패러다임-관점의-타입" class="headerlink" title="객체 지향 패러다임 관점의 타입"></a>객체 지향 패러다임 관점의 타입</h5><p>프로그래밍 언어 관점에서 타입은 호출 가능한 오퍼레이션의 집합이다. </p>
<p>객체지향 프로그래밍에서 오퍼레이션은 객체가 수신할 수 있는 메세지이다. </p>
<p>객체지향 프로그래밍에서 타입을 정의하는 것은 객체가 수신할 수 있는 객체의 퍼블릭 인터페이스를 정의하는 것이다.</p>
<p>동일한 퍼블릭 인터페이스를 제공하는 객체들은 동일한 타입으로 분류된다. </p>
<h2 id="02-타입-계층"><a href="#02-타입-계층" class="headerlink" title="02 타입 계층"></a>02 타입 계층</h2><h5 id="타입-사이의-포함관계"><a href="#타입-사이의-포함관계" class="headerlink" title="타입 사이의 포함관계"></a>타입 사이의 포함관계</h5><p>타입 계층을 구성하는 두 타입 간의 관계에서,</p>
<ol>
<li><p>슈퍼타입</p>
<p>더 일반적인 타입</p>
</li>
<li><p>서브타입</p>
<p>더 특수한 타입</p>
</li>
</ol>
<h5 id="객체지향-프로그래밍과-타입-계층"><a href="#객체지향-프로그래밍과-타입-계층" class="headerlink" title="객체지향 프로그래밍과 타입 계층"></a>객체지향 프로그래밍과 타입 계층</h5><p>핵심은, 서브타입의 인스턴스는 슈퍼타입의 인스턴스로 간주 될 수 있다는 것이다.</p>
<p>퍼블릭 인터페이스의 관점에서,</p>
<ol>
<li><p>슈퍼타입</p>
<p>서브타입이 정의한 퍼블릭 인터페이스를 일반화시켜 상대적으로 범용적이고 넓은 의미로 정의한 것</p>
</li>
<li><p>서브타입</p>
<p>슈퍼타입이 정의한 퍼블릭 인터페이스를 특수화시켜 상대적으로 구체적이고 좁은 의미로 정의한 것</p>
</li>
</ol>
<h2 id="3-서브클래싱과-서브타이핑"><a href="#3-서브클래싱과-서브타이핑" class="headerlink" title="3 서브클래싱과 서브타이핑"></a>3 서브클래싱과 서브타이핑</h2><h5 id="언제-상속을-사용해야-하는가"><a href="#언제-상속을-사용해야-하는가" class="headerlink" title="언제 상속을 사용해야 하는가 ?"></a>언제 상속을 사용해야 하는가 ?</h5><p>다음 주 질문의 답이 ‘예’ 이면 상속을 사용해라.</p>
<ol>
<li>상속 관계가 is-a 관계를 모델링 하는가 ?</li>
<li>클라이언트 입장에서 부모 클래스의 타입으로 자식 클래스를 사용해도 되는가 ? (행동 호환성)</li>
</ol>
<h5 id="is-a-관계"><a href="#is-a-관계" class="headerlink" title="is-a 관계"></a>is-a 관계</h5><p>타입 S 가 타입 T 의 일종이라면 “타입 S 는 타입 T 다”</p>
<p>하지만 is-a 관계가 생각처럼 직관적이고 명쾌한 것은 아니다. 다음 예를 보자.</p>
<ol>
<li>팽귄은 새다.</li>
<li>새는 날 수 있다.</li>
</ol>
<p>이를 코드로 옮기면 다음과 같다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Penguin</span> <span class="keyword">extends</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>그런데, 팽귄은 새는 맞지만 날 수 없다. 위 코드에서는, 팽귄은 새이고 날 수 있다는 것을 주장한다.</p>
<p>이 예는, 어휘적인 정의가 아니라 기대되는 행동에 따라 타입 계층을 구성해야한다는 사실을 보여준다.</p>
<p>즉,<code>어떤 두 대상을 언어적으로 is-a 라고 표현할 수 있어도 일단은 상속을 사용할 예비 후보 정도로 생각</code>해야한다.</p>
<h5 id="행동-호환성"><a href="#행동-호환성" class="headerlink" title="행동 호환성"></a>행동 호환성</h5><p>두 타입 사이에 행동이 호환될 경우에만 타입 계층으로 묶어야 한다.</p>
<p>중요한 것은, <code>행동의 호환 여부를 판단하는 기준은 클라이언트의 관점</code>이다. 클라이언트가 두 타입이 동일하게 행동할 것이라고 기대하면 두 타입을 타입 계층으로 묶을 수 있다.</p>
<p>Penguin 이 Bird 의 서브 타입이 아닌 이유는, 클라이언트 입장에서 모든 새가 날 수 있다고 가정하기 때문이다.</p>
<p>다음과 같이 클라이언트가 날 수 있는 새만을 원한다고 해보자.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flyBird</span><span class="params">(Bird bird)</span></span>&#123;</span><br><span class="line">		bird.fly(); <span class="comment">// 인자로 전달된 모든 bird 는 날 수 있어야한다.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Penguin 은 날 수 없고 클라이언트 입장에서 모든 bird 가 날 수 있기를 기대하기 때문에 flyBird 의 메서드로 전달되어서는 안된다.</p>
<p>상속 관계를 유지하면서 문제를 해결하기 위해 시도할 수 있는 세가지 방법이 있다.</p>
<ol>
<li><p>Penguin 이 fly 메서드를 오버라이딩해서 내부 구현을 비워두는 것이다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Penguin</span> <span class="keyword">extends</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>하지만, 이 방법은 어떤 행동도 수행하지 않기 때문에 모든 bird 가 날 수 있다는 클라이언트의 기대를 만족하지 않는다. </p>
</li>
<li><p>Penguin 의 fly 메서드를 오버라이딩한 후 예외를 던지는 것이다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Penguin</span> <span class="keyword">extends</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>flyBird 메서드는 모든 bird 가 날 수 있다고 가정한다. </p>
<p>flyBird 메서드 fly 메시지를 전송한 결과로 UnsupportedOperationException 예외가 던져질 것이라고 기대하지 않을 것이다.</p>
</li>
<li><p>flyBird 메서드를 수정해서 인자로 전달된 bird 타입이 팽귄이 아닐 경우에만 fly 메세지를 전송하는 것이다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flyBird</span><span class="params">(Bird bird)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!(bird <span class="keyword">instanceof</span> Penguin))&#123;</span><br><span class="line">			bird.fly();    </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>만약 팽귄이 이외에 날 수 없는 또 다른 새가 상속 계층에 추가되면, flyBird 메서드 안에 새로운 타입을 체크하는 코드가 추가된다. 이것은 구체적인 클래스에 대한 결합도를 높여, 개방-폐쇄 원칙을 위반한다.</p>
</li>
</ol>
<h5 id="클라이언트의-기대에-따라-계층-분리하기"><a href="#클라이언트의-기대에-따라-계층-분리하기" class="headerlink" title="클라이언트의 기대에 따라 계층 분리하기"></a>클라이언트의 기대에 따라 계층 분리하기</h5><p>문제 해결을 위해서는, 위 세가지 방법 말고 클라이언트의 기대에 따라 계층을 분리해야한다.</p>
<p>날 수 있는 새와 날 수 없는 새를 명확하게 구분할 수 있게 상속 계층을 분리하면 서로 다른 요구사항을 가진 클라이언트를 만족 시킬 수 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line"> ...    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyingBird</span> <span class="keyword">extends</span> <span class="title">Bird</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Penguin</span> <span class="keyword">extends</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flyBird</span><span class="params">(FlyingBird bird)</span></span>&#123;</span><br><span class="line">		bird.fly();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>또 다른 방법으로는, 다음 그림과 같이 클라이언트에 따라 인터페이스를 분리하는 것이다.</p>
<p><img src="/image/object_subclass_interface.png" alt></p>
<p>더 좋은 방법은, 합성을 사용하는 것이다.</p>
<p><img src="/image/object_subclass_composition.png" alt></p>
<p>설계가 꼭 현실 세계를 반영할 필요는 없다. <code>자연어에 현혹되지 말고 요구사항 속에서 클라이언트가 기대하는 행동에 집중해라.</code></p>
<h5 id="서브클래싱과-서브타이핑"><a href="#서브클래싱과-서브타이핑" class="headerlink" title="서브클래싱과 서브타이핑"></a>서브클래싱과 서브타이핑</h5><p>상속을 사용하는 목적에 따라 다음과 같이 나눌 수 있다.</p>
<ol>
<li><p>서브클래싱</p>
<p>다른 클래스의 코드를 재사용할 목적으로 상속을 사용하는 경우이다.</p>
<p>구현상속, 클래스 상속이라고도 부른다. 왜냐하면, 내부 구현 자체를 상속하는 것에 초점을 맞추기 때문이다.</p>
</li>
<li><p>서브타이핑</p>
<p>타입 계층을 구성하기 위해 상속을 사용하는 것이다.</p>
<p>인터페이스 상속이라고도 부른다. 왜냐하면, 서브타입이 슈퍼타입의 퍼블릭 인터페이스를 상속하는 것 처럼 보이기 때문이다.</p>
</li>
</ol>
<h2 id="04-리스코프-치환-법칙"><a href="#04-리스코프-치환-법칙" class="headerlink" title="04 리스코프 치환 법칙"></a>04 리스코프 치환 법칙</h2><p>리스코프 치환 법칙이란, 클라이언트가 차이점을 인식하지 못한 채 파생 클래스의 인터페이스를 통해 서브 클래스를 사용할 수 있어야한다는 것이다.</p>
<p>10장의 Stack 과 Vector 는 리스코프 치환 법칙을 위반하는 전형적인 예이다. 클라이언트가 부모 클래스인 Vector 에 대해 기대하는 행동을 Stack 에 대해서는 기대할 수 없기 때문에 행동 호환성을 만족하지 못하기 때문이다.</p>
<p>다른 예로, “직사각형은 사격형이다 “ 가 있다. 하지만, 직사각형은 사각형이 아닐 수 있다.</p>
<p>다음은 사각형이다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x, y, width, height;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Rectangle</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">        <span class="keyword">this</span>.width = width;</span><br><span class="line">        <span class="keyword">this</span>.height = height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWidth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWidth</span><span class="params">(<span class="keyword">int</span> width)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.width = width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHeight</span><span class="params">(<span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.height = height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getArea</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> width * height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>다음은 정사각형이다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span>  <span class="keyword">extends</span> <span class="title">Rectangle</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Square</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(x, y, size, size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWidth</span><span class="params">(<span class="keyword">int</span> width)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setWidth(width);</span><br><span class="line">        <span class="keyword">super</span>.setHeight(width);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHeight</span><span class="params">(<span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setWidth(height);</span><br><span class="line">        <span class="keyword">super</span>.setHeight(height);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>문제는 다음과 같이, Rectangle 과 협력하는 클라이언트는 사각형의 너비와 높이가 다르다고 가정한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(Rectangle rectangle, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span>&#123;</span><br><span class="line">		rectangle.setWidth(width);</span><br><span class="line">		rectangle.setHeight(height);</span><br><span class="line">		<span class="keyword">assert</span> rectangle.getWidth() == width &amp;&amp; rectangle.getHeight() == height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>다음과 같이, 위 코드에서 resize 메서드 인자로 Rectangle 대신, Square 를 전달한다고 해보자. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Square square = <span class="keyword">new</span> Square(<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>);</span><br><span class="line">resize(square, <span class="number">50</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p>메서드의 실행이 실패하고 만다.</p>
<p>중요한 것은, 클라이언트 입장에서 행동이 호환되는지의 여부이다. 행동이 호환될 경우, 자신 클래스가 부모 클래스 대신 사용될 수 있다.</p>
<h5 id="클라이언트와-대체-가능성"><a href="#클라이언트와-대체-가능성" class="headerlink" title="클라이언트와 대체 가능성"></a>클라이언트와 대체 가능성</h5><p>Square 가 Rectangle 을 대체할 수 없는 이유는, 클라이언트 관점에서 Square와 Rectangle 이 다르기 때문이다.</p>
<p>대체 가능성을 결정하는 것은 클라이언트이다.</p>
<h5 id="is-a-관계-다시-살펴보기"><a href="#is-a-관계-다시-살펴보기" class="headerlink" title="is-a 관계 다시 살펴보기"></a>is-a 관계 다시 살펴보기</h5><p>상속이 서브타이핑을 위해 사용될 경우에만 is-a 관계이다. <code>서브 클래싱을 구현하기 위해 상속을 사용했다면 is-a 관계가 아니다.</code></p>
<h5 id="리스코프-치환-원칙은-유연한-설계의-기반이다"><a href="#리스코프-치환-원칙은-유연한-설계의-기반이다" class="headerlink" title="리스코프 치환 원칙은 유연한 설계의 기반이다."></a>리스코프 치환 원칙은 유연한 설계의 기반이다.</h5><p>클라이언트 입장에서, 퍼블릭 인터페이스의 행동방식이 변경되지 않는다면 클라이언트의 코드를 변경하지 않고도 새로운 자식 클래스와 협력할 수 있다.</p>
<p>8장에서 중복 할인 정책을 구현하기 위해 기존의 DiscountPolicy 상속 계층에 새로운 자식 클래스인 OverlappedDiscountPolicy 를 추가하더라도 클라이언트를 수정할 필요가 없었다.</p>
<p><img src="/image/object_subclass_chapter8.png" alt></p>
<p>위 설계는 다음 원칙을 조합한 유연할 설계이다.</p>
<ol>
<li><p>의존성 역전 원칙</p>
<p>상위 수준 모듈인 Movie 와 하위 수준 모듈인 OverlappedDiscountPolicy 모두 추상 클래스인 DiscountPolicy 에 의존한다.</p>
</li>
<li><p>리스코프 치환 원칙</p>
<p>OverlappedDiscountPolicy 는 클라이언트에 대한 영향 없이도 DiscountPolicy 를 대체할 수 있다.</p>
</li>
<li><p>개방-폐쇄 원칙</p>
<p>중복할인이라는 새로운 기능을 추가하기 위해 OverlappedDiscountPolicy 를 추가하더라도, Movie 에는 영향이 없다.</p>
</li>
</ol>
<h2 id="5-계약에-의한-설계와-서브타이핑"><a href="#5-계약에-의한-설계와-서브타이핑" class="headerlink" title="5. 계약에 의한 설계와 서브타이핑"></a>5. 계약에 의한 설계와 서브타이핑</h2><p>‘계약에 의한 설계’ 란, 클라이언트와 서버 사이의 협력을 의무와 이익으로 구성된 계약의 관점에서 표현하는 것이다.</p>
<p>서브타입이 리스코프 치환 원칙을 만족시키기 위해서는, 클라이언트와 슈퍼타입 간에 체결된 ‘계약’ 을 준수해야한다.</p>
<p>즉, 서브타입이 슈퍼타입처럼 보일 수 있는 유일한 방법은, 클라이언트가 슈퍼타입과 맺은 계약을 서브 타입이 준수하는 것이다.</p>
<hr>
<p>오브젝트 &lt;조영호&gt;</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kojunhee.github.io/2020/01/13/object-chapter13/" data-id="ck5qi9kjz00omga6w8uhyrma5" data-title="[오브젝트] 13장_서브클래싱과 서브타이핑" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-review-2019" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/01/12/review-2019/" class="article-date">
  <time class="dt-published" datetime="2020-01-11T15:00:00.000Z" itemprop="datePublished">2020-01-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/etc/">etc</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/01/12/review-2019/">2019년 회고</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="1-회사-업무"><a href="#1-회사-업무" class="headerlink" title="1. 회사 업무"></a>1. 회사 업무</h2><ol>
<li><p>Monthly Report</p>
<p>매월 대행사용 월간 리포트를 생성해서 제공한다.</p>
<p>보고서 생성 전체 파이프 라인을 단순화했다.</p>
<p>능동적으로 문제를 찾으려하지 않았다.</p>
</li>
<li><p>Report API</p>
<p>Node.js 기반 API 를  Java 기반으로 변경하는 작업이다. </p>
<p>팀 선임분이 대부분 작업을 했고, 나는 일부만 참여했다.</p>
<p>기존 코드에 대한 이해가 부족했다. 팀 선임분에게 의존도가 높았다.</p>
</li>
<li><p>Download Report</p>
<p>셀러가 필요할 때 리포트를  다운로드할 수 있는 서비스이다.</p>
<p>일정을 맞추지 못하였고, 초기 설계가 부족했다.</p>
<p>Java, Message Queue, Spark, Livy 를 배우기 좋았다.</p>
</li>
</ol>
<h2 id="2-외부-스터디"><a href="#2-외부-스터디" class="headerlink" title="2. 외부 스터디"></a>2. 외부 스터디</h2><ol>
<li><p>JPA</p>
<p>재밌게 공부하기는 했지만, 회사 업무에 당장 필요한 우선순위가 높은 주제는 아니었다.</p>
<p>상반기에 진행한 스터디였는데, JPA 스터디를 하기보다 회사 업무 파악에 집중할 필요가 있었다.</p>
</li>
<li><p>Spark</p>
<p>월간 리포트와 다운로드 리포트 작업에 필요한는 기술이기 때문에 스터디를 했다.</p>
<p>스터디하는 장소가 멀어서, 참여를 못하는 분들이 많아 원활히 스터디 진행이 안되었다.</p>
<p>스터디를 했지만 Spark 에 대한 이해도가 높아지지 않았다.</p>
<p>다시 공부할 필요가 있다.</p>
</li>
<li><p>Object</p>
<p>가장 재밌고 유익한 스터디였다.</p>
<p>다운로드 리포트를 리팩토링할 때 ‘객체지향’ 개념을 적용하려고 노력했다.</p>
</li>
</ol>
<h2 id="3-총평"><a href="#3-총평" class="headerlink" title="3. 총평"></a>3. 총평</h2><ol>
<li><p>광고 도메인 공부가 필요하다.</p>
</li>
<li><p>내 일뿐만 아니라, 다른 팀원이 하고 있는 일에도 관심을 갖고 협력해야한다.</p>
</li>
<li><p>일정 수립을 할 때는 충분히 여유롭게 해야한다.</p>
</li>
<li><p>개발 전에 설계가 충분히 잘 되어 있어야한다.</p>
</li>
<li><p>문서화를 해야한다.</p>
</li>
<li><p>공유를 해야한다.</p>
</li>
<li><p>스터디를 할 때는, 우선순위를 정하고 필요한 것부터 해야한다.</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kojunhee.github.io/2020/01/12/review-2019/" data-id="ck5qi9kin00mtga6wzj8kfbbf" data-title="2019년 회고" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-object-chapter12" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/01/06/object-chapter12/" class="article-date">
  <time class="dt-published" datetime="2020-01-05T15:00:00.000Z" itemprop="datePublished">2020-01-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/object/">Object</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/01/06/object-chapter12/">[오브젝트] 12장_다형성</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>상속의 진정한 목적은 코드 재사용이 아니라 <code>다형성을 위한 서브타입 계층을 구축</code> 하는 것이다.</p>
<p>상속의 관점에서 다형성이 구현되는 기술적인 메커니즘을 정리한다.</p>
<h2 id="01-다형성"><a href="#01-다형성" class="headerlink" title="01 다형성"></a>01 다형성</h2><p>다형성(Polymorphism) 은 다음 둘의 합성어이다. 즉, 많은 형태를 가질 수 있는 능력이다.</p>
<ul>
<li>ploy : 많은</li>
<li>morph : 형태</li>
</ul>
<p>다형성은 다음과 같이 분류될 수 있다. 이번장은 포함 다형성에 대해 다룬다.</p>
<ul>
<li><p>유니버셜 다형성 </p>
<ul>
<li><p>매개변수 다형성 </p>
<p>클래스의 인스턴스 변수나 메서드의 매개변수 타입을 임의의 타입으로 선언한 후 사용하는 시점에 구체적인 타입으로 지정하는 방식.</p>
<p> ex) List 인터페이스는 컬렉션에 보관할 요소의 타입을 임의의 타입 T로 지정하고 있으며 실제 인스턴스를 생성하는 시점에 T 를 구체적인 타입으로 지정</p>
</li>
<li><p>포함 다형성 (서브타입 다형성)</p>
<p>메세지가 동일해도 수신한 객체의 타입에 따라 실제로 수행되는 행동이 달라지는 능력.</p>
</li>
</ul>
</li>
<li><p>임시 다형성</p>
<ul>
<li><p>오버로딩 다형성</p>
<p>하나의 클래스 안에 동일한 이름의 메서드가 존재하는 경우.</p>
</li>
<li><p>강제 다형성</p>
<p>자동적인 타입 변환이나 사용자가 직접 구현한 타입 변환을 이용해 동일한 연산자를 다양한 타입에 사용할수 있는 방식.</p>
<p>ex) 이항 연산자인 ‘+’ 는 피연산자가 하나는 정수형이고 다른 하나는 문자열인 경우, 정수형 피연산자는 문자열 타입으로 강제 형변환</p>
</li>
</ul>
</li>
</ul>
<h2 id="02-상속의-양면성"><a href="#02-상속의-양면성" class="headerlink" title="02 상속의 양면성"></a>02 상속의 양면성</h2><ol>
<li><p>데이터 관점의 상속</p>
<p>부모 클래스에서 정의한 모든 데이터를 자식 클래스의 인스턴스에 자동으로 포함한다.</p>
</li>
<li><p>행동 관점의 상속</p>
<p>데이터뿐만 아니라 부모 클래스에서 정의한 일부 메서드 역시 자동으로 자식 클래스에 포함한다.</p>
<p>외부의 객체가 부모 클래스의 인스턴스에 전송할 수 있는 모든 메세지는 자식 클래스의 인스턴스에도 전송할 수 있다.</p>
</li>
</ol>
<h5 id="상속을-사용한-강의-평가"><a href="#상속을-사용한-강의-평가" class="headerlink" title="상속을 사용한 강의 평가"></a>상속을 사용한 강의 평가</h5><p>code : 394 p</p>
<ol>
<li><p>메서드 오버라이딩</p>
<p>자식 클래스 안에 상속 받은 메서드와 <code>동일한 시그니처의 메서드를 재정의</code>해서 부모 클래스의 구현을 새로운 구현으로 대체하는 것이다.</p>
</li>
<li><p>메서드 오버로딩</p>
<p>부모 클래스에서 정의한 <code>메서드와 이름은 동일하지만 시그니처는 다른</code> 메서드를 자식 클래스에 추가하는 것이다.</p>
</li>
</ol>
<h2 id="03-업캐스팅과-동적-바인딩"><a href="#03-업캐스팅과-동적-바인딩" class="headerlink" title="03 업캐스팅과 동적 바인딩"></a>03 업캐스팅과 동적 바인딩</h2><h5 id="같은-메세지-다른-메서드"><a href="#같은-메세지-다른-메서드" class="headerlink" title="같은 메세지, 다른 메서드"></a>같은 메세지, 다른 메서드</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Professor professor01 = <span class="keyword">new</span> Professor(<span class="string">"다익스트라"</span>, <span class="keyword">new</span> Lecture(...))</span><br><span class="line">Professor professor02 = <span class="keyword">new</span> Professor(<span class="string">"다익스트라"</span>, <span class="keyword">new</span> GradeLecture(...))</span><br><span class="line">  </span><br><span class="line">professor01.compileStatistics();</span><br><span class="line">professor02.compileStatistics();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">compileStatistics</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">	lecture.evalulate();</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>동일한 객체 참조인 lecture 에 대해 동일한 evaluate 메세지를 전송하는 동일한 코드 안에서, 서로 다른 클래스 안에 구현된 메서드를 실행할 수 있다.</p>
<p>이처럼, 코드 안에서 선언된 참조 타입과 무관하게 <code>실제로 메세지를 수신한 객체의 타입에 따라 실행되는 메서드가 달라질 수 있는 것</code>은 다음 두 메커니즘이 작용하기 때문이다.</p>
<ol>
<li><p>업캐스팅</p>
<p>부모 클래스 타입으로 선언된 변수에 자식 클래스의 인스턴스를 할당하는 것이 가능</p>
</li>
<li><p>동적 바인딩</p>
<p>메세지를 처리할 적절한 메서드를 컴파일 시점이 아니라 실행시점에 결정</p>
</li>
</ol>
<h5 id="업캐스팅"><a href="#업캐스팅" class="headerlink" title="업캐스팅"></a>업캐스팅</h5><p><img src="/image/object_polymorphism_upcasting.png" alt></p>
<p>업캐스팅의 대표적인 두 가지이다.</p>
<ol>
<li><p>대입문</p>
<p>명시적으로 타입을 변환하지 않고도 부모 클래스의 타입의 참조변수에 자식 클래스의 인스턴스를 대입할 수 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Lecture lecture = <span class="keyword">new</span> GradeLecture(...);</span><br></pre></td></tr></table></figure>
</li>
<li><p>메서드 파라미터</p>
<p>부모 클래스의 타입으로 선언된 파라미터에 자식 클래스의 인스턴스를 전달할 수 잇다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Professor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Professor</span><span class="params">(String name, Lecture lecture)</span></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Professor professor = <span class="keyword">new</span> Professor(<span class="string">"다익스트라"</span>, <span class="keyword">new</span> GradeLecture(...));</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>다운 캐스팅은, 부모 클래스의 인스턴스를 자식 클래스 타입으로 변환하기 위해 명시적인 타입 캐스팅이 필요하다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Lecture lecture = <span class="keyword">new</span> GradeLecture(...);</span><br><span class="line">GradeLecture gradeLecture = (GradeLecture) lecture;</span><br></pre></td></tr></table></figure>

<h5 id="동적-바인딩"><a href="#동적-바인딩" class="headerlink" title="동적 바인딩"></a>동적 바인딩</h5><ol>
<li><p>정적 바인딩</p>
<p>컴파일 타임에 호출할 함수를 결정하는 방식</p>
</li>
<li><p>동적 바인딩</p>
<p>실행될 메서드를 런타임에 결정하는 방식. </p>
<p>실행 시점에 어떤 클래스의 인스턴스를 생성해서 전달하는지 알아야만 실제로 실행될 메서드를 알 수 있다.</p>
</li>
</ol>
<h2 id="04-동적-메서드-탐색과-다형성"><a href="#04-동적-메서드-탐색과-다형성" class="headerlink" title="04 동적 메서드 탐색과 다형성"></a>04 동적 메서드 탐색과 다형성</h2><p>객체지향 시스템은 다음 규칙에 따라 실행할 메서드를 선택한다.</p>
<ol>
<li><p>메세지를 수신한 객체는 자신을 생성한 클래스에 적합한 메서드가 존재하는지 검사한다.</p>
<p>존재하면 메서드를 실행하고 탐색을 종료한다.</p>
</li>
<li><p>존재하지 않으면, 부모 클래스에서 메서드 탐색을 계속한다.</p>
<p>적합한 메서드를 찾을 때 까지 상속 계층을 따라 올라가며 계속된다.</p>
</li>
<li><p>상속 계층의 최상위 클르스에 올라갔지만 메서드를 발견하지 못하면 예외를 발생시키며 탐색을 종료한다.</p>
</li>
</ol>
<p>여기서 중요한 것이 sefl 참조 변수이다.</p>
<p>객체가 메세지를 수신하면, 컴파일러는 self 참조라는 임시 변수를 자동으로 생성해 메세지를 수신한 객체를 가리키도록 한다.</p>
<p><img src="/image/object_polymorphism_self.png" alt></p>
<p>위 그림에서, </p>
<ol>
<li>GradeLecture 클래스에서 적절한 메서드를 찾지 못했다면 </li>
<li>parent 참조를 따라 부모 클래스인 Lecture 클래스로 이동한후 탐색을 계속한다. </li>
<li>상속 계층을 따라 최상위 클래스인 Object 클래스에 이를 때 까지 탐색을 계속한다.  </li>
<li>최상위 클래스에서도 메서드를 찾지 못하면 에러를 발생시킨다.</li>
</ol>
<p>동적 메서드 탐색은 두 원리로 구성된다.</p>
<ol>
<li><p>자동적인 메세지 위임</p>
<p>자식 클래스는 이해할 수 없는 메세지를 전송 받으면 상속 계층을 따라 부모 클래스에 처리를 위임한다.</p>
</li>
<li><p>동적인 문맥</p>
<p>메세지를 수신했을 때, 실제로 어떤 메서드가 실행될지 결정하는 것은 컴파일 시점이 아니라 실행시점에 이뤄진다.</p>
</li>
</ol>
<h5 id="자동적인-메세지-위임"><a href="#자동적인-메세지-위임" class="headerlink" title="자동적인 메세지 위임"></a>자동적인 메세지 위임</h5><ol>
<li><p>메서드 오버라이딩 : 자식 클래스의 메서드가 부모 클래스의 메서드를 감추게 된다.</p>
<p><img src="/image/object_polymorphism_overriding.png" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Lecture lecture = <span class="keyword">new</span> Lecture(...);</span><br><span class="line">lecture.evaluate();</span><br></pre></td></tr></table></figure>

<p>위 그림과 위 코드에서, 메서드 탐색은 self 참조가 가리키는 객체의 클래스인 Lecuture 에서 시작한다.</p>
<p>Lecture 클래스 안에 evaluate 메서드가 존재하기 때문에, 메서드 실행한 후 탐색은 종료한다.</p>
<p><img src="/image/object_polymorphism_grade_lecture.png" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Lecture lecture = <span class="keyword">new</span> GradeLecture(...);</span><br><span class="line">lecture.evaluate();</span><br></pre></td></tr></table></figure>

<p>위 그림과 위 코드에서, Lecture 에 정의된 메서드가 아닌 실제 객체를 생성항 클래스인 GradeLecture 에 정의된 메서드가 실행된다. </p>
<p>self 참조가 가리키는 객체의 클래스인 GradeLecture 에서 탐색을 시작하고 GradeLecture 클래스 안에  evaluate 메서드가 구현되어 있기 때문이다.</p>
</li>
<li><p>메서드 오버로딩 :  자식 클래스의 메서드와 부모 클래스의 메서드가 공존한다.</p>
<p><img src="/image/object_polymorphism_overloading.png" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Lecture lecture = <span class="keyword">new</span> GradeLecture(...);</span><br><span class="line">lecture.average();</span><br></pre></td></tr></table></figure>

<p>위 그림과 위 코드에서, GradeLecture 클래스 안에서 메세지에 응답할 수 있는 적절한 메서드를 찾지 못한다.</p>
<p>그래서, 부모 클래스인 Lecture 클래스에서 메서드를 찾으려고 시도한다.</p>
</li>
</ol>
<h5 id="동적인-문맥"><a href="#동적인-문맥" class="headerlink" title="동적인 문맥"></a>동적인 문맥</h5><p>메세지를 수신한 객체가 무엇이냐에 따라 메서드 탐색을 위한 문맥이 동적으로 바뀐다. </p>
<p>이 동적인 문맥을 결정하는 것이 메세지를 수신한 객체를 가리키는 self 참조이다.</p>
<p>self 참조 가 동적 문맥을 결정한다는 것은, 종종 어떤 메서드가 실행될지 예상하기 어렵게 만든다. 대표적인 경우가 self 전송이다.</p>
<p>self 전송은 자식 클래스에서 부모 클래스 방향으로 진행되는 동적 메서드 탐색 경로를 <code>다시 self 참조가 가리키는 원래의 자식 클래스로 이동</code>시킨다. </p>
<p>다음을 보자.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lecture</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">stats</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getEvaluationMethod();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getEvaluationMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Pass or Fail"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GradeLecture</span> <span class="keyword">extends</span> <span class="title">Lecture</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getEvaluationMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Grade"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>GradeLecture 에 stats 메시지를 전송하면, 다음 그림과 같다.</p>
<p><img src="/image/object_polymorphism_self_send.png" alt></p>
<ol>
<li>self 참조는 GradeLecture 인스턴스를 가리키도록 설정되고 탐색은 GradeLecture 부터 시작.</li>
<li>GradeLecture 클래스에는 stats 메세지를 처리할 메서드가 없기 때문에 부모 클래스인 Lecture 에서 메서드 탐색을 계속속 하다가, Lecture 에서 stats 메서드를 발견하고 실행</li>
<li>실행 중에, self 참조가 가리키는 getEvaluationMethod 메세지를 전송하는 구문과 마주침</li>
<li>메서드 탐색은 self 참조가 가리키는 객체에서 다시 시작</li>
</ol>
<h5 id="이해할-수-없는-메세지"><a href="#이해할-수-없는-메세지" class="headerlink" title="이해할 수 없는 메세지"></a>이해할 수 없는 메세지</h5><p>이해할 수 없는 메세지 처리는 두 타입 언어에 따라 다르다.</p>
<ol>
<li><p>정적 타입 언어</p>
<p>코드를 컴파일 할 때 상속 계층 안의 클래스들이 메세지를 이해할 수 있는지 여부를 판단한다. </p>
<p>상속 계층 전체를 탐색한 후에도 메시지를 처리할 메서드를 발견하지 못하면 컴파일 에러가 발생한다. (안정적이다)</p>
</li>
<li><p>동적 타입 언어</p>
<p>실제로 코드 실행 전에는 메시지 처리 가능 여부를 판단 할 수 없다.</p>
<p>하지만, 이해할 수 없는 메세지에 대해 예외를던 는 것 외에도 doesNotUnderstand 나 method_missing 메시제에 응답 할 수 있는 메서드를 구현할 수 있다. (유연하다)</p>
</li>
</ol>
<h5 id="self-대-super"><a href="#self-대-super" class="headerlink" title="self 대 super"></a>self 대 super</h5><p><img src="/image/object_polymorphism_super.png" alt></p>
<p>super.average() 에 의해 호출되는 메서드는 부모 클래스의 메서드가 아니라, 더 상위에 위치한 조상 클래스의 메서드일 수 있다.</p>
<ol>
<li><p>self 전송</p>
<p>메세지를 수신한 객체의 클래스에 따라 메서드를 탐색할 시작 위치를 동적으로 결정</p>
</li>
<li><p>super 전송</p>
<p>항상 메세지를 전송하는 클래스의 부모 클래스에서부터 시작</p>
</li>
</ol>
<h2 id="5-상속-대-위임"><a href="#5-상속-대-위임" class="headerlink" title="5. 상속 대 위임"></a>5. 상속 대 위임</h2><p><img src="/image/object_polymorphism_same_self.png" alt></p>
<p>GradeLecture 인스턴스 입장에서 self 참조는, GradeLecture 인스턴스 자신이다.</p>
<p>GradeLecture 인스턴스에 포함된 Lecture 입장에서 self 참조는, GradeLecture 인스턴스이다. self 참조는 항상 메세지를 수신한 객체를 가리키기 때문이다.</p>
<p>즉, 상속 계층을 구성하는 객체들 사이에서는 self 참조를 공유하기 때문에 개념적으로 각 인스턴스에서 self 참조를 공유하는 self 변수를 포함하는 것처럼 표현할 수 있다.</p>
<p>상속은 동적으로 메서드를 탐샘하기 위해 현재의 실행문맥을 가지고 있는 self 참조를 전달한다. 그리고 이 객체들 사이에서는 메시지를 전달하는 과정이 자동으로 이뤄진다. 그래서, 자동적인 메세지 위임이라고 한다.</p>
<hr>
<p>오브젝트 &lt;조영호&gt;</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kojunhee.github.io/2020/01/06/object-chapter12/" data-id="ck5qi9kjy00oiga6wxqmnyu93" data-title="[오브젝트] 12장_다형성" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-big-data-chapter5" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/01/05/big-data-chapter5/" class="article-date">
  <time class="dt-published" datetime="2020-01-04T15:00:00.000Z" itemprop="datePublished">2020-01-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/big-data/">Big Data</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/01/05/big-data-chapter5/">[빅데이터를 지탱하는 기술] 5장_빅데이터 파이프라인</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="1-워크-플로우-관리"><a href="#1-워크-플로우-관리" class="headerlink" title="1. 워크 플로우 관리"></a>1. 워크 플로우 관리</h2><h5 id="기초-지식"><a href="#기초-지식" class="headerlink" title="기초 지식"></a>기초 지식</h5><ol>
<li><p>워크 플로우 관리 도구</p>
<p>워크 플로우 관리 도구의 주요 역할은, 정기적으로 태스크를 실행하고 비정상적인 상태를 감지하여 해결을 돕는 것이다.</p>
<p>ex) Airflow, Azkaban, Digdag, Luigi, Oozie</p>
</li>
<li><p>태스크</p>
<p>데이터 파이프라인의 실행 과정에서 데이터를 잇달아 이동하면서 정해진 처리를 반복하는데, 이때 실행되는 개별 처리이다.</p>
</li>
<li><p>기본 기능</p>
<ul>
<li><p>테스크를 정기적인 스케쥴로 실행하고 결과 통지</p>
</li>
<li><p>테스크 간의 의존 관계를 정하고 순서대로 빠지없이 실행</p>
</li>
<li><p>테스크의 실행 결과를 보관하고, 오류 발생하면 재실행 할 수 있도록 하기</p>
</li>
</ul>
</li>
<li><p>선언 형과 스크립트 형</p>
<ul>
<li>선언형 : XML 이나 YAML 등의 서식으로 워크플로우 기술</li>
<li>스크립트형 : 스크립트 언어로 워크플로우 정의</li>
</ul>
</li>
</ol>
<h5 id="오류로부터-복구-방법"><a href="#오류로부터-복구-방법" class="headerlink" title="오류로부터 복구 방법"></a>오류로부터 복구 방법</h5><p>모든 오류를 사전에 예상하는 것은 불가능하기 때문에, 오류 발생 가능성을 고려하여 대처 방법을 결정해야한다.</p>
<ol>
<li><p>Retry</p>
<p>재시도를 반복해도 문제가 없는 태스크라면, 1회나 2회의 재시도를 실행해도 좋다.</p>
<p>그러나, 그 이상은 재시도가 아니라 올바른 문제 해결 방법을 찾아야한다.</p>
</li>
<li><p>Backfill</p>
<p>플로우 전체를 처음부터 다시 실행한다. 다음 상황에 사용한다.</p>
<ul>
<li>태스크의 실패가 며칠 동안이나 계속된 후에 이를 모아서 재시도 하고 싶을 때</li>
<li>새롭게 만든 워크 플로우를 과거로 거슬라 올라가 실행하고 싶을 때</li>
</ul>
</li>
</ol>
<h5 id="재실행의-안정성을-위한-두가지-방법"><a href="#재실행의-안정성을-위한-두가지-방법" class="headerlink" title="재실행의 안정성을 위한 두가지 방법"></a>재실행의 안정성을 위한 두가지 방법</h5><ol>
<li><p>원자성 조작 (Atomic Operation)</p>
<p>예를 들어, INSERT 문 2회를 호출하는 태스크가 있다고 하자.</p>
<p>첫 번째의 INSERT 가 종료되고 오류가 발생하면 태스크를 재실행하면 동일한 데이터가 다시 쓰이게 될 수 있다.</p>
<p>이 문제를 회피하기 위해, 각 태스크가 <code>시스템에 변경을 가하는 것을 한 번만 할 수 있도록</code> 하는 것이다.</p>
<p>쓰기가 필요한 수 만큼 테스크를 나누는 것이다. </p>
<p>하지만, 태스크 구현상의 버그 등으로 원자성 조작 직후에 문제가 발생하면 원자성 조작 자체는 성공했어도 워크 플로우 관리 도구에서는 오류로 여길 수 있다.</p>
</li>
<li><p>멱등한 조작</p>
<p>더 확실한 방법은, <code>동일한 태스크를 여러 번 실행해도 동일한 결과</code>가 되도록 하는 것이다.</p>
<p>예를 들어 분산 스토리지에 파일을 업로드할 때, </p>
<ul>
<li>매번 새로운 파일명을 만들 경우 데이터를 추가 (append) 하는 것이고, </li>
<li>동일 파일명으로 덮어쓰면 치환 (replace)하는 것이다. 치환은 반복해도 결과가 변하지 않으므로 멱등하다.</li>
</ul>
</li>
</ol>
<h5 id="데이터-추가"><a href="#데이터-추가" class="headerlink" title="데이터 추가"></a>데이터 추가</h5><ol>
<li><p>멱등한 추가</p>
<p>과거의 모든 데이터를 치환하면 멱등하지만 부하가 커진다. 그래서, Table Partitioning 이 필요하다.</p>
<p>예를 들면 테이블을 1일마다 또는 1시간 마다 파티션으로 분할하고 파티션 단위로 치환하는 것이다.</p>
<p>파티션의 모든 데이터를 삭제할 때, TRUNCATE 문이나 INSESRT OVERWRITER 문 등을 사용할 수 있다.</p>
<p>ex) Hive 는 파티셔닝 지원, Amazon Redshift 는 파티셔닝을 지원하지 않아 UNION ALL 사용</p>
</li>
<li><p>원자성을 지닌 추가</p>
<p>하나의 테이블에 여러번 데이터를 써넣는 경우, 중간 테이블을 이용해 마지막에 목적 테이블에 한 번 추가한다.</p>
<p>즉, 전반 부분에서는 중간 테이블을 만들기 위해 테이블을 치환하므로 멱등하다.</p>
<p>그러나 마지막에 INSESRT 는 단순히 추가이므로 전체로서는 멱등하지 않다.</p>
<p>단, 마지막에 쓰기를 1회만 실시하므로 이것은 원자성을 지닌 조작이다. </p>
<p>그래서 플로우가 실패해도 아무것도 쓰이지 않아 실패한 태스크를 재실행해도 복구가 완료된다.</p>
</li>
</ol>
<h5 id="워크-플로우-전체를-멱등하게-하기"><a href="#워크-플로우-전체를-멱등하게-하기" class="headerlink" title="워크 플로우 전체를 멱등하게 하기"></a>워크 플로우 전체를 멱등하게 하기</h5><p>재실행의 안정성을 위해서는, 멱등하게 구현해야한다.</p>
<p><img src="/image/big_data_workflow_idemponent.png" alt></p>
<h5 id="Task-Queue-자원의-소비량-컨트롤"><a href="#Task-Queue-자원의-소비량-컨트롤" class="headerlink" title="Task Queue : 자원의 소비량 컨트롤"></a>Task Queue : 자원의 소비량 컨트롤</h5><p>대량의 테스크를 동시 실행하면 서버에 과부하가 걸리므로 어느 정도 제한 해야한다.</p>
<p>워크 플로우 관리 도구는, 태스크의 크기나 동시 실행 수를 변화시켜 자원의 소비량을 조정해 모든 태스크가 원활하게 실행되도록 할 수 있다. </p>
<p>이 때, Job Queue 또는 Task Queue 를 사용할 수 있다. </p>
<p>모든 태스크는 큐에 저장되고 일정 수의 워커 프로세스가 순서대로 꺼내며 병렬화가 실현된다.</p>
<h2 id="2-배치-형-데이터-플로우"><a href="#2-배치-형-데이터-플로우" class="headerlink" title="2. 배치 형 데이터 플로우"></a>2. 배치 형 데이터 플로우</h2><h5 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h5><p><img src="/image/big_data_workflow_mapreduce.png" alt></p>
<p>데이터 처리 첫 번째 단계를 Map, 그 결과를 모아서 집계하는 두 번째 단계를 Reduce 라고 한다.</p>
<p>이렇게 Map 과 Reduce 를 반복하면서 목적하는 결과를 얻을 때 까지 계속 데이터를 변화하는 구조가 MapReduce 이다.</p>
<p>MapReduce 는 Map 과 Reduce 의 하나의 사이클이 끝나지 않으면 다음 처리로 이동하지 않는다. 즉, 하나의 사이클에서 다음 사이클로 이동할 때 까지 대기 시간이 발생한다.</p>
<h5 id="데이터-플로우"><a href="#데이터-플로우" class="headerlink" title="데이터 플로우"></a>데이터 플로우</h5><p>이전의 MapReduce 를 사용한 데이터 처리에서는, MapReduce 프로그램을 워크플로우의 태스크로 등록해 다단계의 복잡한 데이터 처리를 할 수 있었다.</p>
<p>현재는, 다단계의 데이터 처리를 분산 시스템 내부에서 실행할 수 있다. 이것을 데이터 플로우라고 한다. </p>
<p>ex) 데이터 플로우를 위한 프레임워크 :  Google Cloud Dataflow, Apache Spark, Apache Flick</p>
<h5 id="MapReduce-를-대신할-세로운-프레임워크"><a href="#MapReduce-를-대신할-세로운-프레임워크" class="headerlink" title="MapReduce 를 대신할 세로운 프레임워크"></a>MapReduce 를 대신할 세로운 프레임워크</h5><p>세로운 프레임워크의 공통 특징은 DAG (Direct Acyclic Graph) 이다.</p>
<p>다음 두 가지 성질이 있다.</p>
<ol>
<li>방향성 : 노드와 노드가 화살표로 연결</li>
<li>비순환 : 화살표를 따라가도 동일 노드로 돌아오지 않음</li>
</ol>
<p>DAG 관점에서 MapReduce 와 데이터 플로우의 차이는,</p>
<ol>
<li><p>MapReduce</p>
<p>MapReduce 도 Map 과 Reduce 의 두 종류 노드로 이루어진 DAG 라 생각할 수 있다. </p>
<p>하지만, 하나의 노드에서 처리가 끝나지 않으면 다음 처리로 진행할 수 없다.</p>
</li>
<li><p>데이터플로우</p>
<p>DAG 를 구성하는 노드가 모두 동싱 병행으로 실행된다.</p>
<p>처리가 끝난 데이터는 네트워크를 거쳐 차례대로 전달된다. </p>
<p>먼저 데이터 파이프라인 전체를 DAG 로 조립한 뒤 실행해서, 내부 스캐쥴러가 분산 시스템에 효과적인 실행 계획을 세운다.</p>
</li>
</ol>
<h5 id="데이터-플로우와-워크플로우-조합하기"><a href="#데이터-플로우와-워크플로우-조합하기" class="headerlink" title="데이터 플로우와 워크플로우 조합하기"></a>데이터 플로우와 워크플로우 조합하기</h5><p>테스크를 정기적으로 실행하거나 실패한 테스크를 기록하여 복구하는 것은, 데이터플로우가 아니라 워크 플로우의 관리가 필요하다. 따라서, 데이터 플로우의 프로그램도 워크 플로우의 일부로 실행되는 하나의 태스크로 고려될 수 있다.</p>
<ol>
<li><p>데이터를 읽어들이는 플로우</p>
<p><img src="/image/big_data_workflow_store.png" alt></p>
<p>데이터 플로우로부터 읽어 들일 데이터는 성능적으로 안정된 분산 스토리지에 배치해야한다. 외부의 데이터 소스에서 데이터를 읽어들일 때는 읽기 속도에 한계가 있으므로 데이터 플로우를 사용한다고 해도 빨라진다고 단언할 수 없다.</p>
<p><img src="/image/big_data_workflow_after_store.png" alt></p>
<p>분산스토리지로 데이터 복사가 완료되면 데이터 플로우로 처리한다.</p>
</li>
<li><p>데이터를 써서 내보내는 워크플로우</p>
<p>데이터 플로우 안에서 대량의 데이터를 외부에 전송해서는 안된다. 왜냐하면,</p>
<ul>
<li><p>쓰기 작업에 오래 걸리면, 실행이 완료되지 않아 자원을 계속해서 소비 할 수 있다.</p>
</li>
<li><p>최악의 경우, 쓰기 작업이 실패해 처음부터 다시 데이터 처리를 재실행 해야 할 수 있다.</p>
</li>
</ul>
<p>그래서, 데이터 플로우는 CSV 파일과 같이 취합하기 쉬운 형식으로 분산 스토리지에 넣는 것 까지한다. </p>
<p>외부 시스템에 데이터를 전송하는 것은 워크 플로우의 역할이다. </p>
<ul>
<li><p>벌크 형 전송 도구를 사용해 태스크를 구현하거나</p>
</li>
<li><p>외부 시스템쪽에 파일을 읽어들이도록 지시한다.</p>
</li>
</ul>
<p><img src="/image/big_data_workflow_write.png" alt></p>
</li>
</ol>
<h5 id="데이터-플로우와-SQL-을-나누어-사용하기"><a href="#데이터-플로우와-SQL-을-나누어-사용하기" class="headerlink" title="데이터 플로우와 SQL 을 나누어 사용하기"></a>데이터 플로우와 SQL 을 나누어 사용하기</h5><p><img src="/image/big_data_workflow_sql.png" alt></p>
<ol>
<li><p>SQL을 MPP 데이터베이스에서 실행</p>
<p>데이터웨어하우스의 파이프라인 </p>
<p>로드되는 데이터를 만드는 부분까지가 데이터 플로의 역할</p>
</li>
<li><p>SQL을 분산 시스템 상의 쿼리 엔진에서 실행 </p>
<p>데이터마트의 파이프라인</p>
<p>구조화된 데이터를 만드는 부분까지가 데이터플로우의 역할</p>
</li>
</ol>
<h2 id="3-스트리밍-형-데이터-플로우"><a href="#3-스트리밍-형-데이터-플로우" class="headerlink" title="3. 스트리밍 형 데이터 플로우"></a>3. 스트리밍 형 데이터 플로우</h2><h5 id="배치-처리와-스트림-처리"><a href="#배치-처리와-스트림-처리" class="headerlink" title="배치 처리와 스트림 처리"></a>배치 처리와 스트림 처리</h5><p><img src="/image/big_data_workflow_stream.png" alt></p>
<ol>
<li><p>배치 처리</p>
<p>도달한 데이터를 우선 분산 스토리지에 보관한다.</p>
<p>데이터가 영속적으로 보관되기 때문에 몇 번이고 재실행 가능하다. </p>
<p>집계 효율이 높은 열 지향 스토리지를 구축할 수 있다. </p>
<p>실행 시에 데이터 양이 정해지기 때문에 유한 데이터 (bounded data)</p>
</li>
<li><p>스트림 처리</p>
<p>데이터 도달과 동시에 처리가 시작된다.</p>
<p>재실행하는 것은 고려하지 않는다.</p>
<p>처리한 결과는 시계열 데이터에 적합한 데이터 스토어에 보관하거나 실시간 시스템에 전송한다.</p>
<p>제한 없이 데이터가 보내지기 때문에 무한 데이터 (unbounded data)</p>
<p>ex) Spark Streaming</p>
</li>
</ol>
<h5 id="스트림-처리에-의한-1차-집계"><a href="#스트림-처리에-의한-1차-집계" class="headerlink" title="스트림 처리에 의한 1차 집계"></a>스트림 처리에 의한 1차 집계</h5><p><img src="/image/big_data_workflow_stream_first.png" alt></p>
<p>분산 스토리지에도 성능 상이나 비용 상의 한계가 있다.</p>
<p>데이터 양이 많아 한계를 넘어서면, 스트림 처리를 사용해 흐름량을 줄일 수 있다.</p>
<h5 id="스트림-처리의-두-가지-문제에-대한-대처"><a href="#스트림-처리의-두-가지-문제에-대한-대처" class="headerlink" title="스트림 처리의 두 가지 문제에 대한 대처"></a>스트림 처리의 두 가지 문제에 대한 대처</h5><p>스트림 처리의 문제 두 가지가 있다.</p>
<ol>
<li><p>틀린 결과를 어떻게 수정할 것인가</p>
<p>새롭게 도달한 데이터만 처리한다.</p>
</li>
<li><p>늦게 전송된 데이터 취급을 어떻게 할 것인가</p>
<p>집계가 종료된 후에 도착한 데이터가 있어서, 스트림 처리의 결과가 부정확해질 수 있다.</p>
</li>
</ol>
<p>이 문제 해결을 위해, 스트림 처리와 별개로 배치 처리를 실행시켜 배치 처리의 결과가 옳다고 할 수 있다.</p>
<p>예를 들어, 일별 보고서를 속보 값으로 하고 월별 보고서를 확정값으로 분류하는 것이다.</p>
<p>이를 발전 시킨 방법이 람다 아키텍쳐, 람다 아키텍쳐를 단순화한 카파 아키텍쳐가 있다.</p>
<ol>
<li><p>람다</p>
<p><img src="/image/big_data_workflow_lamda.png" alt></p>
<p>세 레이어로 구성된다.</p>
<ul>
<li><p>배치 레이어</p>
<p>모든 데이터는 배치 레이어에서 처리한다. 대규모 배치 처리를 위해 실행하며 1회 처리가 오래 걸린다.</p>
</li>
<li><p>서빙 레이어</p>
<p>배치 처리 결과는 서빙 레이어를 통해 접근한다. 응답이 빠른 데이터베이스를 설치해서 집계 결과를 바로 추출한다. </p>
<p>서빙 레이어에서 얻어진 결과를 배치 뷰 라고 한다. 정기적으로 업데이트 되지만 실시간 정보는 얻을 수 없다.</p>
</li>
<li><p>스피드 레이어</p>
<p>스피드 레이어에서 얻은 결과를 실시간 뷰라고 한다. 배치 뷰가 업데이트 될 동안에만 이용되고 오래된 데이터를 순서대로 삭제된다.</p>
</li>
</ul>
<p>배치뷰와 실시간 뷰를 조합시키는 형태로 쿼리를 실행한다. 최근 24시간 집계 결과는 실시간 뷰를 참고하고 그 이전 데이터는 배치뷰를 이용할 수 있다. </p>
<p>실시간 뷰의 결과는 나중에 배치 뷰로 치환된다. 그래서 스트림 처리가 정확하지 않아도 길게 보면 문제가 없다.</p>
</li>
<li><p>카파</p>
<p>람다 아키텍쳐는 스피드 레이어와 배치 레이어가 모두 같은 처리를 구현하고 있으므로 번거롭다.</p>
<p>그래서, 카파 아키테쳐는 스피드 레이어만 남긴다. 대신, 메세지 브로커의 데이터 보관 기한을 길게하여 문제 발생시 메세지 배송 시간을 과거로 다시 설정한다. 그러면 과거의 데이터가 다시 스트림 처리로 흘러 들어 실질적으로 재실행이 이루어진다.</p>
<p>문제점은, 부하가 높아진다는 것이다. 대량의 과거 데이터를 흘려보내면 평상시와 비교해 몇 배의 자원을 소비하기 때문이다. 클라우드 서비스 보급에 그런 자원을 확보하는 것이 어렵지 않으므로 필요에 따라 스트림 처리를 다시 하는것이 간단하는 것이 카파 아키텍쳐의 주장이다.</p>
</li>
</ol>
<h5 id="Out-of-Order-의-데이터-처리"><a href="#Out-of-Order-의-데이터-처리" class="headerlink" title="Out of Order 의 데이터 처리"></a>Out of Order 의 데이터 처리</h5><p><img src="/image/big_data_workflow_out_of_order.png" alt></p>
<p>스트림 처리를 할때 늦게 도달한 메세지, 즉 프로세스 시간과 이벤트 시간의 차이는, 이벤트 시간 윈도윙으로 해결한다.</p>
<p>즉, 이벤트 시간에 의해 윈도우를 나누는 것이다. </p>
<p>메세지가 배송된 데이터는 무작위 순이기 때문에 적절히 순서를 바꿔 집계 결과를 업데이트해야한다.</p>
<p>데이터가 도달할 때마다 해당하는 윈도우를 재집계한다. 데이터를 무한히 계속 보관할 수 없으므로 일정 이상 늦게 온 데이터는 무시한다.</p>
<hr>
<p>빅데이터를 지탱하는 기술 &lt;니시다 케이스케&gt;</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kojunhee.github.io/2020/01/05/big-data-chapter5/" data-id="ck5qi9kjx00ogga6wglammmnm" data-title="[빅데이터를 지탱하는 기술] 5장_빅데이터 파이프라인" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-big-data-chapter4" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/01/02/big-data-chapter4/" class="article-date">
  <time class="dt-published" datetime="2020-01-01T15:00:00.000Z" itemprop="datePublished">2020-01-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/big-data/">Big Data</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/01/02/big-data-chapter4/">[빅데이터를 지탱하는 기술] 4장_빅데이터 축적</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="1-벌크-형과-스트리밍-형의-데이터-수집"><a href="#1-벌크-형과-스트리밍-형의-데이터-수집" class="headerlink" title="1. 벌크 형과 스트리밍 형의 데이터 수집"></a>1. 벌크 형과 스트리밍 형의 데이터 수집</h2><p>데이터 수집 방법으로 두 가지 방법이 있다. </p>
<p>이 챕터에서는 각각의 방법으로, 분산 스토리지에 데이터가 저장되기 까지의 흐름을 정리한다.</p>
<ol>
<li>벌크 형 </li>
<li>스트리밍 형</li>
</ol>
<h5 id="객체-스토리지와-데이터-수집"><a href="#객체-스토리지와-데이터-수집" class="headerlink" title="객체 스토리지와 데이터 수집"></a>객체 스토리지와 데이터 수집</h5><p>빅데이터는 확장성이 높은 분산 스토리지에 저장된다. 분산 스토리지로,</p>
<ol>
<li><p>분산형 데이터베이스</p>
</li>
<li><p>대량으로 파일을 저장하는 객체 스토리지</p>
<p>객체 스토리지는 다수의 컴퓨터를 사용해 파일을 여러 디스크에 복사해서 데이터 중복화 및 부하 분산을 실현한다.</p>
<p>객체 스토리지의 구조는 데이터 양이 많을 때는 우수하지만, 소량의 데이터에 대해서는 비효율적이다.</p>
<p>하둡의 HDFS, 클라우드 서비스의 Amazon S3 가 대표적이다.</p>
</li>
</ol>
<h5 id="데이터-수집"><a href="#데이터-수집" class="headerlink" title="데이터 수집"></a>데이터 수집</h5><p>데이터 수집이란, 수집한 데이터를 가공해 집계 효율이 좋은 분산 스토리지를 만드는 일련의 프로세스이다. </p>
<p>작은 데이터는 적당히 모아서 하나의 큰 파일로 만들어 효율을 높이는데 도움이 된다. </p>
<p>파일이 지나치게 크면, 네트워크 전송 시간이 오래 걸려 오류 발생률이 높다. </p>
<h5 id="벌크-형-데이터-전송"><a href="#벌크-형-데이터-전송" class="headerlink" title="벌크 형 데이터 전송"></a>벌크 형 데이터 전송</h5><p><img src="/image/big_data_bulk_data.png" alt></p>
<p>전통적인 데이터 웨어하우스에서는 주로 벌크 형 방식으로 데이터베이스나 파일 서버 또는 웹 서비스 등에서 각각의 방식 (SQL, API …) 으로 정리해 데이터를 추출한다.</p>
<p>처음부터 분산 스토리지에 데이터가 저장되어 있지 않으면 데이터 전송을 위한 ETL 서버를 설치한다. </p>
<p>데이터 전송의 신뢰성이 중요하면 벌크형 도구를 사용하는 것이 좋다.</p>
<h5 id="파일-사이즈의-적정화"><a href="#파일-사이즈의-적정화" class="headerlink" title="파일 사이즈의 적정화"></a>파일 사이즈의 적정화</h5><p>ETL 프로세스는 하루마다 또는 한시간 마다의 간격으로 정기적인 실행을 하므로 그 동안 축적된 데이터는 하나로 모인다.</p>
<p>데이터 양이 많을 떄는 한 달씩이나 하루 단위로 전송하도록 작은 태스크로 분해해 한 번의 태스크 실행이 커지지 않도록 조정해야한다. </p>
<p>워크 플로우 관리 도구를 사용하면 쉽게 관리 할 수 있다.</p>
<h5 id="스트리밍-형의-데이터-전송"><a href="#스트리밍-형의-데이터-전송" class="headerlink" title="스트리밍 형의 데이터 전송"></a>스트리밍 형의 데이터 전송</h5><p><img src="/image/big_data_message_delivery.png" alt></p>
<p>계속해서 전송되어 오는 작은 데이터를 취급하기 위한 데이터 전송이다.</p>
<p>이러한 데이터 전송은 다수의 클라이언트에서 계속 작은 데이터가 전송된다. 이러한 데이터 전송 방식이 메세지 배송 (Message Delivery) 이다. </p>
<p>보내온 메세지를 저장하는 방법으로,</p>
<ol>
<li><p>NoSQL 데이터베이스</p>
<p>Hive 와 같은 쿼리 엔진으로 NoSQL 데이터베이스에 연결해 데이터를 읽을 수 있다. </p>
</li>
<li><p>Message Queue</p>
<p>데이터를 일정 간격으로 꺼내고 모아서 분산 스토리지에 저장한다.</p>
</li>
</ol>
<h5 id="웹-브라우저에서-메세지-배송"><a href="#웹-브라우저에서-메세지-배송" class="headerlink" title="웹 브라우저에서 메세지 배송"></a>웹 브라우저에서 메세지 배송</h5><p><img src="/image/big_data_message_web_browser.png" alt></p>
<ol>
<li><p>상주형 로그 수집 소프트웨어</p>
<p>자체 개발한 웹 애플리케이션 등에서는 웹 서버 안에서 메세지를 만들어서 배송한다. 전송 효율을 높이기 위해 서버상에서 일단 데이터를 축적해 놓고 나중에 모아서 보내는 경우가 있다. 이 때, Fluentd 나 Logstash 같은 상주형 로그 수집 소프트웨어가 자주 사용된다.</p>
</li>
<li><p>웹 이벤트 추적</p>
<p>자바스크립트를 이용해 웹 브라우에서 직접 메세지를 보내는 경우도 있다.</p>
</li>
</ol>
<h5 id="모바일-앱에서-메세지-배송"><a href="#모바일-앱에서-메세지-배송" class="headerlink" title="모바일 앱에서 메세지 배송"></a>모바일 앱에서 메세지 배송</h5><p><img src="/image/big_data_message_mobile.png" alt></p>
<ol>
<li><p>MBaaS</p>
<p>모바일 앱에서는 서버를 직접 마련하는 것이 아니라, MBaaS (Mobile Backend as a Serivce) 라는 백엔드의 각종 서비스를 이용할 수 있다. </p>
</li>
<li><p>SDK</p>
<p>모바일 앱이 오프라인이 되었을 때는 발생한 이벤트를 SDK 내부에 축적하고 온라인 상태 되었을 때 모아서 보낼 수 있다.</p>
</li>
</ol>
<h5 id="디바이스에서-메세지-배송"><a href="#디바이스에서-메세지-배송" class="headerlink" title="디바이스에서 메세지 배송"></a>디바이스에서 메세지 배송</h5><p><img src="/image/big_data_message_device.png" alt></p>
<p>MQTT (MQ Telemetry Transport) 는 TCP/IP 를 이용하여 데이터 전송하는 프로토콜 중 하나이다. 일반적으로 Pub/Sub 메세지 배송 구조이다. </p>
<h5 id="메세지-배송의-공통화"><a href="#메세지-배송의-공통화" class="headerlink" title="메세지 배송의 공통화"></a>메세지 배송의 공통화</h5><p>메세지가 처음 생성되는 기기를 클라이언트, 해당 메세지를 먼저 받는 서버를 프론트엔드라고 한다.</p>
<p>프론트 엔드는 단지 데이터를 받는 것에 전념하고, 그 이후의 문제는 백엔드의 공통 시스템에 맡길 수 있다.</p>
<h2 id="2-성능-신뢰성-메세지-배송의-트레이드오프"><a href="#2-성능-신뢰성-메세지-배송의-트레이드오프" class="headerlink" title="2. 성능, 신뢰성 : 메세지 배송의 트레이드오프"></a>2. 성능, 신뢰성 : 메세지 배송의 트레이드오프</h2><p>이 챕터는 메세지 브로커를 중심으로 메세지 배송 구조와 한계를 정리한다.</p>
<h5 id="메세지-브로커"><a href="#메세지-브로커" class="headerlink" title="메세지 브로커"></a>메세지 브로커</h5><p>메세지 배송에 의해 보내진 데이터를 분산 스토리지에 저장할 때, 데이터 양이 적을 때는 문제가 되지 않지만 쓰기의 빈도가 증가하면 디스크 성능의 한계에 도달해 더 쓸 수 없게 될 우려가 있다.</p>
<p>대량의 메세지를 안정적으로 받기 위해서는 빈번한 쓰기에도 견딜 수 있는 성능이 높고, 필요에 따라 성능을 얼마든지 올릴 수 있는 스토리지가 필요하다.</p>
<p>분산 스토리지가 반드시 이 성격을 가질 수 있다고 할 수 없기 때문에, 메세지를 일시적으로 축적하는 중산층이 설치된다. 이것이 메세지 브로커이다.</p>
<p>ex) Apache Kafka, Amazon Kinesis</p>
<h5 id="push-형-pull-형"><a href="#push-형-pull-형" class="headerlink" title="push 형, pull 형"></a>push 형, pull 형</h5><p>송신 측의 제어로 데이터를 보내는 방식을 push 형, 수신 측 주도로 데이터를 가져오는 것을 pull 형이라고 한다.</p>
<p>메세지 브로커에 데이터를 push 하는 것을 producer, pull 하는 것을 consumer 라고 한다.</p>
<p>push 형의 메세지 배송은 모두 메세지 브로커에 집중 시키고 거기에서 일정한 빈도로 꺼낸 데이터를 분산 스토리지에 기록한다.</p>
<p>또한, pull 형의 메세지 배송은 파일 사이즈 적정화에도 도움이 된다. consumer 는 메세지 브로커로부터 일정한 간격으로 데이터를 취해 적당히 모아진 데이터를 분산 스토리지에 저장한다.</p>
<h5 id="메세지-라우팅"><a href="#메세지-라우팅" class="headerlink" title="메세지 라우팅"></a>메세지 라우팅</h5><p>메세지 브로커에 써넣은 데이터는 다수의 다른 consumer 에서 읽을 수 있다. 이를 통해 메세지가 복사되어 데이터를 여러 경로로 분기 시킬 수 있다. 이것이 메세지 라우팅이다.</p>
<p>예를 들어, 메세지 일부를 실시간 장애 감지를 사용하면서, 같은 메세지를 장기적인 데이터 분석을 위한 분산 스토리지에 저장하는 것도 가능하다.</p>
<h5 id="메세지-배송-신뢰성-문제와-세-가지-설계-방식"><a href="#메세지-배송-신뢰성-문제와-세-가지-설계-방식" class="headerlink" title="메세지 배송 신뢰성 문제와 세 가지 설계 방식"></a>메세지 배송 신뢰성 문제와 세 가지 설계 방식</h5><p>대부분의 경우 다음 중 하나를 보장하도록 설계된다.</p>
<ol>
<li><p>at most once</p>
<p>메세지는 한 번만 전송된다. 도중에 전송 실패로 사라질 가능성이 있다.</p>
</li>
<li><p>exactly once</p>
<p>메세지는 손실 되거나 중복 없이 한 번만 전달된다.</p>
<p>네트워크 상에 두 개의 노드가 있는 경우 양쪽의 통신 내용을 보장하기 위해 coorninator 가 필요하다. 문제가 생기면 송신 측과 수신 측 모두 서로의 정보를 코디네이터에게 전달해서 문제가 발생하면 코디네이터의 지시에 따라 해결할 수 있다.</p>
<p>그러나 분산 시스템에서는 코디네이터와의 통신이 끊길 수 있고 코데네이터가 정지될 수도 있다. 따라서 코디네이터의 부재 시에 어덯게 할 것인지에 대한 consensus 가 필요하다. 보통, 단시간 장애 가능성은 받아 들인다.</p>
<p>또한, 코디네이터의 판단에만 따르고 있으면 시간이 너무 소요된다. </p>
<p>그래서 메세지 배송 시스템에서는 코디네이터를 도입하지 않고 at least once 를 따른다. </p>
</li>
<li><p>at least once</p>
<p>메세지는 확실히 전달된다. 단, 같은 것이 여러번 전달될 가능성이 있다.</p>
<p>메세지가 재전송되어도 그것을 없앨 수 있는 구조가 있으면 보기에 중복이 없는 것처럼 할 수 있다. 이러한 구조를 ‘중복 제거’ 라고 한다. </p>
<p>예를 들어, TCP 는 메세지 수신 확인을 위해 ‘ack’ 플래그를 도입했다. 메세지 재전송에 의한 중복이 발생하지만, 모든 TCP 패킷에서는 이것을 식별하는 시퀀스 번호를 이용해 중복 제거가 이뤄진다.</p>
<p>대부분의 메세지 배송 시스템은 at least once 를 보장하는 한편, 중복 제거는 이용자에게 맡기고 있어서 TCP/IP 처럼 자동으로 중복을 제거해주지 않는다. (ex) Apache Kafka, Apache Flume, Logstash</p>
</li>
</ol>
<h5 id="중복-제거는-높은-비용의-오퍼레이션"><a href="#중복-제거는-높은-비용의-오퍼레이션" class="headerlink" title="중복 제거는 높은 비용의 오퍼레이션"></a>중복 제거는 높은 비용의 오퍼레이션</h5><p>중복 제거 방법으로 다음과 같은 방법이 있다.</p>
<ol>
<li><p>오프셋 이용</p>
<p>각 메세지에는 파일 안의 시작 위치 (오프셋) 를 붙인다.</p>
<p>메세지가 중복되어도 같은 파일의 같은 장소를 덮어쓸 뿐이므로 문제되지 않는다.</p>
<p>벌 크형 데이터 전송과 같이 데이터양이 고정된 경우에 사용한다.</p>
</li>
<li><p>고유 ID 이용</p>
<p>모든 메세지에 UUID 등의 고유 ID 를 지정한다.</p>
<p>메세지가 늘어남에 따라 ID 가 증가하므로 그것을 어떻게 관리하느냐가 문제이다.</p>
<p>스트리밍 형의 메세지 배송에서 자주 사용된다. </p>
</li>
</ol>
<h5 id="End-to-End-신뢰성"><a href="#End-to-End-신뢰성" class="headerlink" title="End to End 신뢰성"></a>End to End 신뢰성</h5><p>클라이언트가 생성한 메세지를 최종 도달 지점인 분산 스토리지에 기록하는 단계에서 중복 없는 상태로 해야한다.</p>
<p>중간에 한 부분이라도 at most once 가 있으면 메세지를 빠뜨릴 가능성이 있고, at least once 가 있으면 중복될 수 있다. </p>
<p>신뢰성이 높은 메세지 배송을 실현하려면 중간 경로를 모두 at least once 로 통일한 후 클라이언트 상에서 모든 메세지에 고유 ID 를 포함하도록 하고 경로의 말단에서 중복 제거를 실행해야한다.</p>
<h5 id="고유-ID-를-사용한-중복-제거-방법"><a href="#고유-ID-를-사용한-중복-제거-방법" class="headerlink" title="고유 ID 를 사용한 중복 제거 방법"></a>고유 ID 를 사용한 중복 제거 방법</h5><p>두가지 방법이 있다.</p>
<ol>
<li><p>분산 스토리지로 NoSQL 데이터베이스 사용</p>
<p>Cassandra 나 Elasticsearch 등은 데이터를 쓸 대 고유 ID 를 지정하게 되어 있어 동일한 ID 의 데이터는 덮어쓴다.</p>
</li>
<li><p>SQL</p>
<p>보내온 데이터는 일단 그대로 객체 스토리지 등에 저장하고, 나중에 읽어 들이는 단계에서 중복을 제거한다. </p>
<p>Hive 와 같은 배치형 쿼리 엔진에서 실행할 수 있다.</p>
</li>
</ol>
<h5 id="데이터-수집-파이프라인"><a href="#데이터-수집-파이프라인" class="headerlink" title="데이터 수집 파이프라인"></a>데이터 수집 파이프라인</h5><p><img src="/image/big_data_stream_pipeline.png" alt></p>
<p>일련의 프로세스를 거쳐 마지막으로 데이터를 구조화해서 열 지향 스토리지로 변환함으로써, 장기간의 데이터 분석에 적합한 스토리가 완성된다. 이것인 데이터 수집 파이프라인이다.</p>
<p>실제로 어떤 파이프라인을 만들지는 요구사항에 따라 다르므로, 필요에 따라 시스템을 조합한다. </p>
<p>예를 들어, 쓰기 성능에 불안감이 없으면 메세지 브로커가 불필요 하므로 클라이언트에서 직접 NoSQL 데이터베이스에 데이터를 써도 된다. 중복이 허용된다면 중복 제거를 생략할 수 있다.</p>
<h5 id="중복을-고려한-시스템-설계"><a href="#중복을-고려한-시스템-설계" class="headerlink" title="중복을 고려한 시스템 설계"></a>중복을 고려한 시스템 설계</h5><p>스트리밍 형의 메세지 배송 방식에서는 중간에 중복 제거 방식을 도입하지 않으면 중복 가능성이 있다고 생각하면 된다.</p>
<p>신뢰성이 중시되는 경우에는 스트리밍 형의 메세지 배송을 피하는 것이 좋다.</p>
<p>예를 들어, 과금 데이터같은 오차가 불허용 되는 경우 트랜잭션 처리르 지원하는 데이터베이스에 직접 애플리케이션이 기록해야한다. 그 후에 벌크 형의 데이터 전송을 함으로써 중복도 결손도 확실히 피해야한다.</p>
<h2 id="3-TODO"><a href="#3-TODO" class="headerlink" title="3. TODO"></a>3. TODO</h2><h5 id="ㅇㅇㅇ"><a href="#ㅇㅇㅇ" class="headerlink" title="ㅇㅇㅇ"></a>ㅇㅇㅇ</h5><p>팩트 테이블 작성 방법으로,</p>
<ol>
<li><p>추가</p>
<p>새로 도착한 데이터만을 증분으로 추가</p>
</li>
<li><p>치환</p>
<p>과거 데이터를 포함하여 테이블 전체 치환</p>
</li>
</ol>
<h5 id="테이블-파티셔닝"><a href="#테이블-파티셔닝" class="headerlink" title="테이블 파티셔닝"></a>테이블 파티셔닝</h5><p>위의 ‘추가’ 방법은 다음 문제가 있다.</p>
<ol>
<li>추가에 실패한것을 알아채지 못하면, 팩트 테이블의 일부에 결손</li>
<li>추가를 잘못해서 여러번 실행하면, 일부 중복</li>
<li>나중에 팩트 테이블 다시 만들고 싶으면, 관리 복잡</li>
</ol>
<p>그래서 파티셔닝이 필요하다.</p>
<p>하나의 테이블을 여러 물리적인 파티션으로 나눠서 파티션 단위로 정리하여 데이터를 쓰거나 삭제하는 것이다.</p>
<h5 id="집계-테이블"><a href="#집계-테이블" class="headerlink" title="집계 테이블"></a>집계 테이블</h5><p>팩트 테이블을 어느 정도 모아서 집계하면 데이터의 양이 줄어든다. 이것은 집계 테이블이라고 한다.</p>
<p>각 칼럼이 취하는 값의 범위란, 카디널리티이다. ‘성별’ 과 같이 취할 수 있는 값이 적은 것은 카디널리티가 작은 것이다.</p>
<p>집계 테이블을 작게 하려면 모든 칼럼의 카디널리티를 줄여야한다.</p>
<h5 id="스냅샷-테이블-이력-테이블"><a href="#스냅샷-테이블-이력-테이블" class="headerlink" title="스냅샷 테이블, 이력 테이블"></a>스냅샷 테이블, 이력 테이블</h5><p>마스터 데이터처럼 업데이트 될 가능성이 있는 테이블은,</p>
<p>정기적으로 테이블을 통째로 저장하는 스탭샷 테이블, 또는 변경 내용만을 저장하는 이력 테이블로 관리할 수 있다.</p>
<h5 id="디멘전을-추가하여-비정규화-테이블-완성시키기"><a href="#디멘전을-추가하여-비정규화-테이블-완성시키기" class="headerlink" title="디멘전을 추가하여 비정규화 테이블 완성시키기"></a>디멘전을 추가하여 비정규화 테이블 완성시키기</h5><p>팩트 테이블과 디멘젼 테이블을 결합하여 비정규화 테이블을 만든다.</p>
<hr>
<p>빅데이터를 지탱하는 기술 &lt;니시다 케이스케&gt;</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kojunhee.github.io/2020/01/02/big-data-chapter4/" data-id="ck5qi9kjw00ocga6w0dlf611l" data-title="[빅데이터를 지탱하는 기술] 4장_빅데이터 축적" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-big-data-chapter3" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/12/30/big-data-chapter3/" class="article-date">
  <time class="dt-published" datetime="2019-12-29T15:00:00.000Z" itemprop="datePublished">2019-12-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/big-data/">Big Data</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/12/30/big-data-chapter3/">[빅데이터를 지탱하는 기술] 3장_빅데이터 분산처리</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="1-대규모-분산-처리의-프레임워크"><a href="#1-대규모-분산-처리의-프레임워크" class="headerlink" title="1. 대규모 분산 처리의 프레임워크"></a>1. 대규모 분산 처리의 프레임워크</h2><p>비구조화 데이터를 읽어 들여 열 지향 스토리지로 변환하는 과정에서, 데이터의 가공 및 압축을 위해 많은 컴퓨터 리소스가 소비된다. </p>
<p>그래서 사용하는 것이 Hadoop, Spark 같은 분산 처리 프레임워크다.</p>
<h5 id="구조화-데이터-비구조화-데이터-스키마리스-데이터"><a href="#구조화-데이터-비구조화-데이터-스키마리스-데이터" class="headerlink" title="구조화 데이터, 비구조화 데이터, 스키마리스 데이터"></a>구조화 데이터, 비구조화 데이터, 스키마리스 데이터</h5><ol>
<li><p>구조화 데이터</p>
<p>스키마가 명확하게 정의된 데이터.</p>
<p>기존의 데이터 웨어하우스에서는 항상 구조화 데이터로 축적하는 것이 일반적이었다.</p>
</li>
<li><p>비구조화 데이터</p>
<p>스키마가 없는 데이터.</p>
<p>이 상태로는 SQL 로 제대로 집계할 수 없다.</p>
</li>
<li><p>스키마리스 데이터</p>
<p>CSV, JSON, XML 등의 데이터는 서식은 정해져 있지만, 칼럼 수나 데이터 형은 명확하지 않다.</p>
</li>
</ol>
<h5 id="데이터-구조화의-파이프라인"><a href="#데이터-구조화의-파이프라인" class="headerlink" title="데이터 구조화의 파이프라인"></a>데이터 구조화의 파이프라인</h5><p><img src="/image/structured_data.png" alt></p>
<p>분산 스토리지에 수집된 데이터는 명확한 스키마를 갖지 않아 그대로는 SQL 로 집계할 수 없다. </p>
<p>그래서, 먼저 스키마를 명확하게 한 테이블 형식으로 변환해야한다.</p>
<p>구조화된 데이터는 데이터 압축률을 높이기 위해 열 지향 스토리지에 저장한다. </p>
<h5 id="열-지향-스토리지의-작성"><a href="#열-지향-스토리지의-작성" class="headerlink" title="열 지향 스토리지의 작성"></a>열 지향 스토리지의 작성</h5><p>Hadoop 의 열 지향 스토리지는,</p>
<ol>
<li><p>Apache ORC</p>
<p>처음에 스키마를 정한 후 데이터를 저장</p>
</li>
<li><p>Apache Parquet</p>
<p>스키마리스에 가까운 데이터 구조로 되어 있어서 JSON 같은 데이터도 그대로 저장</p>
</li>
</ol>
<h5 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h5><p><img src="/image/big_data_hadoop.png" alt></p>
<p>단일 소프트웨어가 아니라 분산 시스템을 구성하는 다수의 소프트웨어로 이루어진 집합체이다.</p>
<p>기본 구성 요소는,</p>
<ol>
<li><p>분산 파일 시스템</p>
<p>HDFS.</p>
<p>다수의 컴퓨터에 파일을 복사하여 중복성을 높이는 특징이 있다.</p>
</li>
<li><p>리소스 관리자</p>
<p>YARN, Mesos.</p>
<p>YARN 은 애플리케이션이 사용하는 CPU 코어와 메모리를 컨테이너라는 단위로 관리한다.</p>
<p>Hadoop 에서 분산 애플리케이션을 실행하면 YARN 이 클러스터 전체의 부하를 보고 비어 있는 호스트부터 컨테이너를 할당한다.</p>
<p>어느 애플리케이션에 얼마만큼의 리소스를 할당할 지 관리해서 모든 애플리케이션이 실행되도록 제어한다.</p>
</li>
<li><p>분산 데이터 처리</p>
<p>MapReduce, Tez.</p>
<p>MapReduce 도 YARN 위에서 동작하는 분산 애플리케이션 중 하나이다.</p>
</li>
</ol>
<h5 id="쿼리-엔진"><a href="#쿼리-엔진" class="headerlink" title="쿼리 엔진"></a>쿼리 엔진</h5><p><img src="/image/big_data_hive_mr.png" alt></p>
<p>하둡에서는 다수의 쿼리 엔진이 개발되었다. 총칭해서 SQL-on-Hadoop 이라고 한다.</p>
<p>SQL 등의 쿼리 언어에 의한 데이터 집계가 목적이면, 이를 위해 설계된 쿼리 엔진을 사용한다.</p>
<p>Apache Hive 가 대표적이다. 쿼리를 자동으로 MapReduce 프로그램으로 변환하는 소프트웨어이다.</p>
<p>시간이 걸리는 배치 처리에는 적합하나, 애드 혹 쿼리를 여러 번 실행하는데는 부적합하다. </p>
<p>왜냐하면 위 그림처럼, 스테이지가 바뀔 때 대기 시간이 있기 때문이다.</p>
<p><img src="/image/big_data_hive_tez.png" alt></p>
<p>Apache Tez 는 Hive 를 가속화하기 위해 개발되었다. 기존의 MapReduce 를 대체할 목적이다.</p>
<p>Hive on MR 은, 1회의 MapReduce 스테이지가 끝날 때까지 다음의 처리를 진행할 수 없다.</p>
<p>Hive on Tez 는, 위 그림처럼 스테이지의 종료를 기다리지 않고 데이터를 차례대로 후속 처리에 전달하여 쿼리 전체 실행 시간을 단축한다.</p>
<h5 id="대화형-쿼리엔진"><a href="#대화형-쿼리엔진" class="headerlink" title="대화형 쿼리엔진"></a>대화형 쿼리엔진</h5><p><img src="/image/big_data_presto.png" alt></p>
<p>Apache Impala 와 Presto 가 대표적이다.</p>
<p>YARN 과 같은 리소스 관리자를 사용하지 않고, SQL 의 실행만으로 분산처리를 구현한다.</p>
<p>순간 최대 속도를 높이기 위해 모든 오버 헤드가 제거되어, 사용할 수 있는 리소스를 최대한 활용하여 쿼리를 실행한다.</p>
<h5 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h5><p><img src="/image/big_data_spark.png" alt></p>
<p>MapReduce, Tez 모두 데이터 처리 과정에서 만들어진 중간 데이터를 디스크에 기록한다.</p>
<p>Spark 는 대량의 메모리를 활용하여 고속화를 실현한다.</p>
<p>Hadoop 을 대체하는 것이 아니라, MapReduce 를 대체하는 존재다.</p>
<h2 id="2-쿼리-엔진"><a href="#2-쿼리-엔진" class="headerlink" title="2. 쿼리 엔진"></a>2. 쿼리 엔진</h2><p><img src="/image/big_data_hive_presto.png" alt></p>
<h5 id="데이터-마트-구축의-파이프라인"><a href="#데이터-마트-구축의-파이프라인" class="headerlink" title="데이터 마트 구축의 파이프라인"></a>데이터 마트 구축의 파이프라인</h5><ol>
<li><p>Hive</p>
<p>분산 스토리지에 저장된 데이터를 구조화하고 열 지향 스토리지 형식으로 저장</p>
</li>
<li><p>Presto</p>
<p>완성한 구조화 데이터를 결합, 집계하고 비정규화 테이블로 만든 데이터 마트에 써서 보냄</p>
</li>
</ol>
<h5 id="Hive-에-의한-구조화-데이터-작성"><a href="#Hive-에-의한-구조화-데이터-작성" class="headerlink" title="Hive 에 의한 구조화 데이터 작성"></a>Hive 에 의한 구조화 데이터 작성</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; CREATE EXTERNAL TABLE access_log_csv (...)</span><br></pre></td></tr></table></figure>

<p>CSV 파일을 읽어들여 외부 테이블을 정의한다.</p>
<p>외부테이블이란, Hive 의 외부에 있는 특정 파일을 참고해 마치 거기에 테이블이 존재하는 것처럼 읽어 들이기 위해 지정한다.</p>
<p>쿼리를 실행할 때마다 매번 텍스트를 읽어들이기 때문에 느리다. 그래서 열 지향 스토리지로 변환해야한다.</p>
<h5 id="열-지향-스토리지로의-변환"><a href="#열-지향-스토리지로의-변환" class="headerlink" title="열 지향 스토리지로의 변환"></a>열 지향 스토리지로의 변환</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; CREATE TABLE access_log_orc STROED as ORC as SELECT ..</span><br></pre></td></tr></table></figure>

<p>텍스트 데이터를 열 지향 스토리지로 변환함으로써 데이터의 집계가 크게 고속화된다.</p>
<h5 id="Hive-로-비정규화-테이블-작성하기"><a href="#Hive-로-비정규화-테이블-작성하기" class="headerlink" title="Hive 로 비정규화 테이블 작성하기"></a>Hive 로 비정규화 테이블 작성하기</h5><p>데이터 구조화가 완료되면 데이터 마트를 구축해야한다. 즉, 테이블을 결합 및 집약해서 ‘비정규화 테이블’ 을 만든다.</p>
<p>Preso 와 같은 대화형 쿼리 엔진, Hive 같은 배치형 쿼리 엔진을 사용할 수 있다. 시간이 걸리는 배치 처리는 Hive 를 사용해야한다.</p>
<p>비정규화 테이블을 만드는 데 오랜 시간이 걸리므로, 가능한 효율적인 쿼리를 작성해야한다. </p>
<ol>
<li><p>서브 쿼리 안에서 레코드 수 줄이기</p>
<p>서브 쿼리 안에서 팩트 테이블을 작게 해야한다.</p>
<p>데이터의 양의 감소 시킨 후에 테이블을 결합하는 것이 쿼리 실행 시간을 단축시킨다.</p>
</li>
<li><p>데이터 편향 피하기</p>
<p>분산 시스템의 성능을 발휘하기 위해서, 모든 노드에 데이터가 균등하게 분산되도록 해야한다.</p>
</li>
</ol>
<h5 id="대화형-쿼리-엔진-Presto-구조"><a href="#대화형-쿼리-엔진-Presto-구조" class="headerlink" title="대화형 쿼리 엔진 Presto 구조"></a>대화형 쿼리 엔진 Presto 구조</h5><p>쿼리 실행의 지연을 감소시키는 목적으로 개발된 것이 대화형 쿼리 엔진이다.</p>
<p>Presto 의 특징은,</p>
<ol>
<li><p>플러그인 가능한 스토리지</p>
<p>다양한 데이터 소스를 테이블로 참고할 수 있다.</p>
<p>ex) 하나의 쿼리 안에서 분산 스토리지 상의 팩트 테이블과 MySQL 의 마스터 테이블을 조인할 있다.</p>
</li>
<li><p>CPU 처리의 최적화</p>
<p>코드의 실행을 멀티 스레드화되어 단일 머신에서 수백 태스크나 병렬로 실행된다.</p>
<p>그래서, CPU 이용 효율이 높다.</p>
</li>
<li><p>인 메모리 처리에 의한 고속화</p>
<p>모든 데이터 처리는 메모리 상에서 실시하고 메모리가 부족하면 여유가 생길 때까지 기다리거나 오류로 실패한다.</p>
</li>
</ol>
<h5 id="데이터-분석의-프레임워크-선택하기"><a href="#데이터-분석의-프레임워크-선택하기" class="headerlink" title="데이터 분석의 프레임워크 선택하기"></a>데이터 분석의 프레임워크 선택하기</h5><ol>
<li><p>MPP Database</p>
<p>비정규화 테이블을 고속으로 집계하는 데에 최적</p>
</li>
<li><p>Hive</p>
<p>데이터 양에 좌우되지 않는 쿼리 엔진</p>
</li>
<li><p>Presto</p>
<p>속도 중시, 대화식으로 특화된 쿼리 엔진</p>
</li>
<li><p>Spark</p>
<p>분산 시스템을 사용한 프로그래밍 환경.</p>
<p>ETL 프로세스에서 SQL 에 이르기 까지의 일련의 흐름을 하나의 데이터 파이프라인으로 기술 가능.</p>
</li>
</ol>
<h2 id="3-데이터-마트의-구축"><a href="#3-데이터-마트의-구축" class="headerlink" title="3. 데이터 마트의 구축"></a>3. 데이터 마트의 구축</h2><p>분산 시스템이 준비되면 시각화를 위해 데이터 마트를 만든다.</p>
<h5 id="팩트-테이블"><a href="#팩트-테이블" class="headerlink" title="팩트 테이블"></a>팩트 테이블</h5><p>팩트 테이블 작성 방법으로,</p>
<ol>
<li><p>추가</p>
<p>새로 도착한 데이터만을 증분으로 추가</p>
</li>
<li><p>치환</p>
<p>과거 데이터를 포함하여 테이블 전체 치환</p>
</li>
</ol>
<h5 id="테이블-파티셔닝"><a href="#테이블-파티셔닝" class="headerlink" title="테이블 파티셔닝"></a>테이블 파티셔닝</h5><p>위의 ‘추가’ 방법은 다음 문제가 있다.</p>
<ol>
<li>추가에 실패한것을 알아채지 못하면, 팩트 테이블의 일부에 결손</li>
<li>추가를 잘못해서 여러번 실행하면, 일부 중복</li>
<li>나중에 팩트 테이블 다시 만들고 싶으면, 관리 복잡</li>
</ol>
<p>그래서 파티셔닝이 필요하다.</p>
<p>하나의 테이블을 여러 물리적인 파티션으로 나눠서 파티션 단위로 정리하여 데이터를 쓰거나 삭제하는 것이다.</p>
<h5 id="집계-테이블"><a href="#집계-테이블" class="headerlink" title="집계 테이블"></a>집계 테이블</h5><p>팩트 테이블을 어느 정도 모아서 집계하면 데이터의 양이 줄어든다. 이것은 집계 테이블이라고 한다.</p>
<p>각 칼럼이 취하는 값의 범위란, 카디널리티이다. ‘성별’ 과 같이 취할 수 있는 값이 적은 것은 카디널리티가 작은 것이다.</p>
<p>집계 테이블을 작게 하려면 모든 칼럼의 카디널리티를 줄여야한다.</p>
<h5 id="스냅샷-테이블-이력-테이블"><a href="#스냅샷-테이블-이력-테이블" class="headerlink" title="스냅샷 테이블, 이력 테이블"></a>스냅샷 테이블, 이력 테이블</h5><p>마스터 데이터처럼 업데이트 될 가능성이 있는 테이블은,</p>
<p>정기적으로 테이블을 통째로 저장하는 스탭샷 테이블, 또는 변경 내용만을 저장하는 이력 테이블로 관리할 수 있다.</p>
<h5 id="디멘전을-추가하여-비정규화-테이블-완성시키기"><a href="#디멘전을-추가하여-비정규화-테이블-완성시키기" class="headerlink" title="디멘전을 추가하여 비정규화 테이블 완성시키기"></a>디멘전을 추가하여 비정규화 테이블 완성시키기</h5><p>팩트 테이블과 디멘젼 테이블을 결합하여 비정규화 테이블을 만든다.</p>
<hr>
<p>빅데이터를 지탱하는 기술 &lt;니시다 케이스케&gt;</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kojunhee.github.io/2019/12/30/big-data-chapter3/" data-id="ck5qi9kjy00okga6w858ym6j7" data-title="[빅데이터를 지탱하는 기술] 3장_빅데이터 분산처리" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-big-data-chapter1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/12/30/big-data-chapter1/" class="article-date">
  <time class="dt-published" datetime="2019-12-29T15:00:00.000Z" itemprop="datePublished">2019-12-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/big-data/">Big Data</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/12/30/big-data-chapter1/">[빅데이터를 지탱하는 기술] 1장_빅데이터 기초 지식</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="1-빅데이터의-정착"><a href="#1-빅데이터의-정착" class="headerlink" title="1.빅데이터의 정착"></a>1.빅데이터의 정착</h2><h5 id="빅데이터-기술의-요구-Hadoop-과-NoSQL-의-대두"><a href="#빅데이터-기술의-요구-Hadoop-과-NoSQL-의-대두" class="headerlink" title="빅데이터 기술의 요구 : Hadoop 과 NoSQL 의 대두"></a>빅데이터 기술의 요구 : Hadoop 과 NoSQL 의 대두</h5><p>세계 곳곳에서 엑세스 되는 시스템 증가로, 전통적인 관계형 데이터베이스로는 취급 할 수 없는 데이터가 쌓이게 되었다.</p>
<p>그래서 다른 구조가 필요했다.</p>
<ol>
<li><p>Hadoop </p>
<p>다수의 컴퓨터에서 대량의 데이터 처리</p>
</li>
<li><p>NoSQL Database </p>
<p>빈번한 읽기/ 쓰기 및 분산처리가 강점</p>
</li>
</ol>
<h5 id="분산-시스템의-비즈니스-이용-개척-데이터-웨어하우스와의-공존"><a href="#분산-시스템의-비즈니스-이용-개척-데이터-웨어하우스와의-공존" class="headerlink" title="분산 시스템의 비즈니스 이용 개척 : 데이터 웨어하우스와의 공존"></a>분산 시스템의 비즈니스 이용 개척 : 데이터 웨어하우스와의 공존</h5><p><img src="/image/bigdata_datawarehouse.png" alt></p>
<p>위 그림처럼, 확장성이 뛰어난 Hadoop 에 데이터 처리를 맡겨 데이터 웨어하우스의 부하를 줄이고 있다.</p>
<h5 id="직접-할-수-있는-데이터-분석-폭-확대"><a href="#직접-할-수-있는-데이터-분석-폭-확대" class="headerlink" title="직접 할 수 있는 데이터 분석 폭 확대"></a>직접 할 수 있는 데이터 분석 폭 확대</h5><p>‘여러 컴퓨터에서 분산 처리한다’ 는 빅데이터의 특징으로 하드웨어를 준비하고 관리하는게 어려웠다. </p>
<p>하지만, 클라우드 시대에서는 필요한 자원 확보가 쉬워서 얼마든지 빅데이터를 이용할 수 있다.</p>
<h5 id="데이터-디스커버리의-기초-지식"><a href="#데이터-디스커버리의-기초-지식" class="headerlink" title="데이터 디스커버리의 기초 지식"></a>데이터 디스커버리의 기초 지식</h5><ol>
<li><p>데이터 디스커버리</p>
<p>대화형으로 데이터를 시각화하여 가치있는 정보를 찾으려고하는 프로세스</p>
</li>
<li><p>BI 도구</p>
<p>데이터 디스커버리를 위한 셀프 서비스용 시각화 시스템</p>
</li>
</ol>
<h2 id="2-빅데이터-시대의-데이터-분석-기반"><a href="#2-빅데이터-시대의-데이터-분석-기반" class="headerlink" title="2. 빅데이터 시대의 데이터 분석 기반"></a>2. 빅데이터 시대의 데이터 분석 기반</h2><p>빅데이터 기술이 기존 데이터 웨어하우스와 다른 점은,</p>
<p>다수의 분산 시스템을 조합하여 확장성이 뛰어난 데이터 처리 구조를 만든다는 것이다.</p>
<h5 id="데이터-파이프라인"><a href="#데이터-파이프라인" class="headerlink" title="데이터 파이프라인"></a>데이터 파이프라인</h5><p><img src="/image/bigdata_data_pipeline.png" alt></p>
<p>차례대로 전달해다가는 데이터로 구성된 시스템이다. 데이터 파이프라인의 기본적인 흐름은,</p>
<ol>
<li>데이터를 모아서 축적</li>
<li>데이터 마트 구성</li>
<li>시각화 도구</li>
</ol>
<h5 id="데이터-수집"><a href="#데이터-수집" class="headerlink" title="데이터 수집"></a>데이터 수집</h5><p>데이터 파이프라인은 데이터를 모으는 부분부터 시작한다. 수집 방법은,</p>
<ol>
<li><p>벌크형</p>
<p>이미 어딘가에 있는 데이터를 정리해서 추출</p>
<p>ex ) 데이터베이스와 파일 서버 등에서 정기적으로 데이터 수집</p>
</li>
<li><p>스트리밍형</p>
<p>차례대로 생성되는 데이터를 끊임없이 보냄</p>
<p>ex) 모바일 어플리케이션, 임베디드 장비</p>
</li>
</ol>
<h5 id="스트림-처리와-배치처리"><a href="#스트림-처리와-배치처리" class="headerlink" title="스트림 처리와 배치처리"></a>스트림 처리와 배치처리</h5><ol>
<li><p>스트림 처리</p>
<p>스트리밍 형 방법으로 받은 데이터를 실시간으로 처리.</p>
<p>장기적인 데이터 분석에는 적합하지 않음.</p>
</li>
<li><p>배치 처리</p>
<p>정리된 데이터를 효율적으로 가공하기 위한 처리.</p>
<p>장기적인 데이터 분석을 위해 대량의 데이터를 저장하고 처리하는데 적합한 분산 시스템이 필요.</p>
</li>
</ol>
<h5 id="분산-스토리지"><a href="#분산-스토리지" class="headerlink" title="분산 스토리지"></a>분산 스토리지</h5><p>여러 컴퓨터와 디스크로 구성된 스토리지 시스템이다. 데이터 저장 방법으로,</p>
<ol>
<li><p>객체 스토리지</p>
<p>한 덩어리로 모인 데이터에 이름을 부여해서 파일로 저장.</p>
<p>ex ) Amazon S3</p>
</li>
<li><p>NoSQL 데이터베이스</p>
<p>많은 데이터를 읽고 쓰기에 유리.</p>
</li>
</ol>
<h5 id="분산-데이터-처리"><a href="#분산-데이터-처리" class="headerlink" title="분산 데이터 처리"></a>분산 데이터 처리</h5><p>분산 스토리지에 저장된 데이터를 처리하기 위해, 분산 데이터 처리 프레임워크가 필요하다. ex) MapReduce</p>
<p>주 역할은, 나중에 분석하기 쉽도록 데이터를 가공해서 그 결과를 외부 데이터베이스에 저장하는 것이다.</p>
<p>빅데이터를 SQL 로 집계하는 방법으로,</p>
<ol>
<li><p>쿼리 엔진</p>
<p>Hive, 대화형 쿼리엔진</p>
</li>
<li><p>데이터 웨어하우스 제품</p>
<p>ETL. </p>
<p>데이터를 추출하고 가공한후, 데이터 웨어하우스에 로드한다.</p>
</li>
</ol>
<h5 id="워크플로우-관리"><a href="#워크플로우-관리" class="headerlink" title="워크플로우 관리"></a>워크플로우 관리</h5><p>데이터파이프라인이 복잡해지면, 한곳에서 제어하지 않으면 전체 움직임 파악이 어렵다.</p>
<h5 id="데이터-웨어하우스와-데이터-마트"><a href="#데이터-웨어하우스와-데이터-마트" class="headerlink" title="데이터 웨어하우스와 데이터 마트"></a>데이터 웨어하우스와 데이터 마트</h5><p><img src="/image/bigdata_data_pipeline_warehouse.png" alt></p>
<ol>
<li><p>데이터 소스</p>
<p>RDB 나 로그 등을 저장하는 파일 서버</p>
</li>
<li><p>ETL 플로세스</p>
<p>데이터 소스에 보존된 raw data 를 추출하고 필요에 따라 가공한 후 데이터 웨어하우스에 저장하기까지의 흐름</p>
</li>
<li><p>데이터 마트</p>
<p>데이터웨어 하우스에서 필요한 데이터만을 추출하여 데이터마트를 구축</p>
</li>
</ol>
<h5 id="데이터-레이크"><a href="#데이터-레이크" class="headerlink" title="데이터 레이크"></a>데이터 레이크</h5><p><img src="/image/bigdata_data_pipeline_lake.png" alt></p>
<p>모든 데이터를 원래의 형태로 추적해두고 나중에 필요에 따라 가공하는 구조가 필요하다.</p>
<p>이 데이터 축적 장소가 데이터 레이크이다. 분산 스토리지가 데이터 레이크로 이용된다. </p>
<p>데이터 레이크의 데이터를 가공하기 위해 MapReduce 같은 분산 데이터 처리 기술이 필요하다.</p>
<h5 id="데이터-분석-기반을-단계적으로-발전시키기"><a href="#데이터-분석-기반을-단계적으로-발전시키기" class="headerlink" title="데이터 분석 기반을 단계적으로 발전시키기"></a>데이터 분석 기반을 단계적으로 발전시키기</h5><ol>
<li><p>데이터 엔지니어</p>
<p>시스템의 구축 및 운용, 자동화</p>
</li>
<li><p>데이터 분석가</p>
<p>데이터에서 가치있는 정보 추출</p>
</li>
</ol>
<h5 id="확증적-데이터-분석과-탐색적-데이터-분석"><a href="#확증적-데이터-분석과-탐색적-데이터-분석" class="headerlink" title="확증적 데이터 분석과 탐색적 데이터 분석"></a>확증적 데이터 분석과 탐색적 데이터 분석</h5><ol>
<li><p>확증적 데이터 분석</p>
<p>가설을 세우고 검증.</p>
<p>통계학적 모델링에 의한 데이터 분석.</p>
</li>
<li><p>탐색적 데이터 분석</p>
<p>데이터를 보며 의미를 읽어냄.</p>
<p>데이터를 시각화하여 사람의 힘으로 의미를 읽어냄</p>
</li>
</ol>
<hr>
<p>빅데이터를 지탱하는 기술 &lt;니시다 케이스케&gt;</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kojunhee.github.io/2019/12/30/big-data-chapter1/" data-id="ck5qi9kil00moga6wj1h7micd" data-title="[빅데이터를 지탱하는 기술] 1장_빅데이터 기초 지식" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/43/">43</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/algorithm/">Algorithm</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/big-data/">Big Data</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/boost-course/">Boost Course</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/dip/">DIP</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/data-structure/">Data Structure</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/database/">Database</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/design-pattern/">Design Pattern</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/git/">Git</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/jpa/">JPA</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kafka/">Kafka</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/network/">Network</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/node-js/">Node.js</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/os/">OS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/object/">Object</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/software-engineering/">Software Engineering</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/spark/">Spark</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/etc/">etc</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ios/">iOS</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/01/26/kafka-chapter8/">[카프카] 8장_카프카 스트림즈 API</a>
          </li>
        
          <li>
            <a href="/2020/01/26/kafka-chapter7/">[카프카] 7장_데이터 파이프라인 구축</a>
          </li>
        
          <li>
            <a href="/2020/01/20/object-chapter14/">[오브젝트] 14장_일관성 있는 협력</a>
          </li>
        
          <li>
            <a href="/2020/01/13/object-chapter13/">[오브젝트] 13장_서브클래싱과 서브타이핑</a>
          </li>
        
          <li>
            <a href="/2020/01/12/review-2019/">2019년 회고</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 junhee.ko<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="/js/jquery-3.4.1.min.js"></script>


  <script src="/fancybox/jquery.fancybox.min.js"></script>


<script src="/js/script.js"></script>




  </div>
</body>
</html>